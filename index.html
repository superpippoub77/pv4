<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Editor con libreria di componenti</title>
<style>
    body{font-family:Arial,Helvetica,sans-serif;margin:0;display:flex;justify-content:center;align-items:center;height:100vh;background:#f0f0f0}
    .container{display:flex;width:92%;height:92%;border:1px solid #ccc;box-shadow:0 0 10px rgba(0,0,0,.1);background:#fff;position:relative}
    .sidebar{width:200px;padding:20px;background:#f9f9f9;border-right:1px solid #ccc;flex-shrink:0;overflow-y:auto}
    .object-category{margin-bottom:10px}
    .category-header{padding:10px;background:#e0e0e0;cursor:pointer;font-weight:bold;border-radius:5px;transition:background-color .2s}
    .category-header:hover{background-color:#d0d0d0}
    .category-content{display:none;padding:10px 0;border:1px solid #ccc;border-top:none;border-radius:0 0 5px 5px}
    .category-content.active{display:flex;flex-wrap:wrap;gap:5px;padding:10px}
    .object{padding:8px;border:1px solid #ddd;cursor:grab;text-align:center;background:#e9e9e9;border-radius:5px;flex-basis:calc(50% - 5px);box-sizing:border-box;font-size:12px}
    .canvas{flex-grow:1;position:relative;overflow:hidden;background-color: transparent;}
    .canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform-origin: top left; }
    .canvas.grayscale { filter: grayscale(100%); }
    #connection-layer{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0}
    .dropped-object{position:absolute;border:2px solid transparent;cursor:move;display:flex;justify-content:center;align-items:center;font-weight:bold;font-size:14px;text-align:center;box-sizing:border-box;pointer-events:all}
    .dropped-object.selected{border:2px dashed #007bff}
    .dropped-object .resizer,.dropped-object .rotator{position:absolute;width:10px;height:10px;background:#007bff;border:1px solid #fff;border-radius:50%;display:none;pointer-events:all}
    .dropped-object.selected .resizer,.dropped-object.selected .rotator{display:block}
    .resizer{bottom:-5px;right:-5px;cursor:nwse-resize}
    .rotator{top:-15px;left:50%;transform:translateX(-50%);cursor:grab}
    .circle-object{width:50px;height:50px;border-radius:50%;color:#fff;background:#4682b4}
    .square-object{width:50px;height:50px;color:#fff;background:#4682b4}
    .triangle-object{width:0;height:0;border-left:25px solid transparent;border-right:25px solid transparent;border-bottom:50px solid #3cb371;position:relative}
    .triangle-object .object-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:max-content;color:#fff}
    .object-text{pointer-events:auto;padding:5px;min-width:10px;min-height:10px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;user-select:text}
    .text-box-object{background:transparent;border:2px solid transparent;color:#000;padding:10px;min-width:100px;min-height:30px;pointer-events:auto}
    .text-box-object .object-text{white-space:normal;text-overflow:clip;text-align:left;font-weight:normal;color:#000}
    .dropped-object.selected .object-text:focus{outline:1px dotted #fff}
    .controls{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);background:#fff;padding:10px 20px;border:1px solid #ccc;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);display:none;gap:10px;align-items:center;z-index:1000}
    .controls.visible{display:flex}
    .controls label{font-weight:bold;font-size:14px}
    .controls input[type=color]{border:none;width:30px;height:30px;border-radius:50%;padding:0;cursor:pointer}
    .connection-node{position:absolute;width:10px;height:10px;background:#333;border-radius:50%;cursor:crosshair;z-index:10;display:none;pointer-events:all}
    .dropped-object.selected .connection-node,.dropped-object.show-nodes .connection-node{display:block}
    .connection-node.top{top:-5px;left:calc(50% - 5px)}
    .connection-node.bottom{bottom:-5px;left:calc(50% - 5px)}
    .connection-node.left{left:-5px;top:calc(50% - 5px)}
    .connection-node.right{right:-5px;top:calc(50% - 5px)}
    .connection-line{stroke:#333;stroke-width:2;pointer-events:auto;fill:none;marker-end:url(#arrowhead);}
    .selected-line{stroke:red;stroke-width:3}
    .curve-handle{position:absolute;width:10px;height:10px;background:#007bff;border:1px solid #fff;border-radius:50%;cursor:grab;z-index:10;display:none;pointer-events:all;}
    .top-controls { position:absolute; top:10px; left:10px; display:flex; gap:10px; align-items:center; z-index:1000; }
    .top-controls button { width: 30px; height: 30px; font-size: 20px; font-weight: bold; }
    #zoom-level { min-width: 50px; text-align: center; }
    .background-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-color: transparent;}
    .canvas-grid {
        background-image: linear-gradient(to right, #e0e0e0 1px, transparent 1px),
                          linear-gradient(to bottom, #e0e0e0 1px, transparent 1px);
        background-size: 20px 20px;
    }
    .file-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 1000;
        padding: 10px;
        background-color: rgba(255, 255, 255, 0.8);
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    .file-controls input, .file-controls select, .file-controls button {
        padding: 5px;
        border-radius: 4px;
        border: 1px solid #ccc;
    }
    .file-controls input[type="text"] {
        width: 150px;
    }
	
    .player-object{
        background-color: #007bff;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        color: white;
    }
    .mat-object{
        width: 100px;
        height: 50px;
        background-color: #8B4513;
        border: 2px solid #5C3317;
    }
    .wall-object{
        width: 250px;
        height: 20px;
        background-color: #a0422d;
        background-image: linear-gradient(45deg, rgba(0,0,0,.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,.1) 75%, rgba(0,0,0,.1)), linear-gradient(45deg, rgba(0,0,0,.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,.1) 75%, rgba(0,0,0,.1));
        background-size: 15px 15px;
        background-position: 0 0, 7.5px 7.5px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .ball-cart-object{
        width: 80px;
        height: 60px;
        background-color: #555;
        position: relative;
        clip-path: polygon(10% 0, 90% 0, 100% 100%, 0% 100%);
        box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
    }
    .ball-cart-object:after, .ball-cart-object:before{
        content: '';
        position: absolute;
        bottom: -10px;
        width: 15px;
        height: 15px;
        background-color: #333;
        border-radius: 50%;
        border: 2px solid #ccc;
        z-index: -1;
    }
    .ball-cart-object:before{left: 5px;}
    .ball-cart-object:after{right: 5px;}
    .ball-object {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background-color: white;
        border: 1px solid #ccc;
        box-shadow: inset -1px -1px 3px rgba(0,0,0,0.2);
    }
    .net-object{
        width: 150px;
        height: 5px;
        background-image: linear-gradient(to right, #ccc 1px, transparent 1px), linear-gradient(to bottom, #ccc 1px, transparent 1px);
        background-size: 10px 10px;
        background-color: transparent;
        border: none;
        position: relative;
    }
    .net-object::before, .net-object::after{
        content: '';
        position: absolute;
        top: -20px;
        width: 5px;
        height: 25px;
        background-color: #666;
        border: 1px solid #444;
    }
    .net-object::before{ left: 0; }
    .net-object::after{ right: 0; }

    .hoop-object {
        width: 60px;
        height: 60px;
        background: transparent;
        border: 3px solid #ff8c00; /* Arancione per l'anello */
        border-radius: 50%;
        position: relative;
    }
    .hoop-object::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 40px;
        height: 40px;
        transform: translate(-50%, -50%);
        background-image: linear-gradient(45deg, transparent 49%, #fff 49%, #fff 51%, transparent 51%),
                          linear-gradient(135deg, transparent 49%, #fff 49%, #fff 51%, transparent 51%);
        background-size: 10px 10px;
        background-color: transparent;
        border: none;
    }
    .plinth-object {
        width: 60px;
        height: 40px;
        background-color: #8b4513; /* Colore legno scuro */
        border: 2px solid #5c3317;
        position: relative;
        clip-path: polygon(20% 0, 80% 0, 100% 100%, 0% 100%);
    }
    .cone-object {
        width: 40px;
        height: 40px;
        background-color: #ff4500;
        position: relative;
        border-radius: 50%;
        box-shadow: 0 4px 6px rgba(0,0,0,0.2);
    }
    .cone-object::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 10px;
        height: 10px;
        background-color: white;
        border-radius: 50%;
    }
    .whistle-object {
        width: 50px;
        height: 20px;
        background-color: #333; /* Nero per il corpo */
        position: relative;
        border-radius: 5px;
    }
    .whistle-object::before {
        content: '';
        position: absolute;
        top: 50%;
        left: -10px;
        transform: translateY(-50%);
        width: 15px;
        height: 15px;
        border: 2px solid #555;
        border-radius: 50%;
    }
    .timer-object {
        width: 60px;
        height: 35px;
        background-color: #333;
        position: relative;
        border-radius: 5px;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    }
    .timer-object::before {
        content: '';
        position: absolute;
        top: -5px;
        left: 50%;
        transform: translateX(-50%);
        width: 10px;
        height: 10px;
        background-color: #e0e0e0;
        border: 1px solid #555;
        border-radius: 50%;
    }
    .hoop-side-object {
        width: 80px;
        height: 60px;
        background-color: #f0f0f0;
        border: 2px solid #333;
        position: relative;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        transform: perspective(100px) rotateX(10deg);
    }
    .hoop-side-object::before {
        content: '';
        position: absolute;
        bottom: -15px;
        left: 10px;
        width: 60px;
        height: 10px;
        border: 2px solid #ff8c00;
        border-radius: 50%;
        transform: rotateX(80deg) scaleY(0.7);
        background-color: transparent;
    }
    .hoop-side-object::after {
        content: '';
        position: absolute;
        bottom: -25px;
        left: 10px;
        width: 60px;
        height: 15px;
        background-image: linear-gradient(45deg, transparent 49%, #fff 49%, #fff 51%, transparent 51%),
                          linear-gradient(135deg, transparent 49%, #fff 49%, #fff 51%, transparent 51%);
        background-size: 10px 10px;
        background-color: transparent;
        border: none;
    }
    .tool-btn {
        padding: 8px;
        border: 1px solid #ddd;
        cursor: pointer;
        text-align: center;
        background: #e9e9e9;
        border-radius: 5px;
        flex-basis: 100%;
        box-sizing: border-box;
        font-size: 12px;
        margin-bottom: 5px;
    }
    .tool-btn.active {
        background-color: #007bff;
        color: white;
    }

    /* New Arrow Object Style */
    .arrow-object {
        width: 60px;
        height: 15px;
        background-color: #333;
        position: relative;
    }
    .arrow-object::before {
        content: '';
        position: absolute;
        right: -15px;
        top: 0;
        width: 0;
        height: 0;
        border-top: 7.5px solid transparent;
        border-bottom: 7.5px solid transparent;
        border-left: 15px solid;
    }

    .dropdown {
        position: relative;
        display: inline-block;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        background-color: #f9f9f9;
        min-width: 100px;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
        right: 0;
        top: 100%;
        border-radius: 5px;
    }

    .dropdown-content button {
        color: black;
        padding: 8px 12px;
        text-decoration: none;
        display: block;
        width: 100%;
        text-align: left;
        border: none;
        background: none;
        cursor: pointer;
    }

    .dropdown-content button:hover {
        background-color: #f1f1f1;
    }

    .dropdown.active .dropdown-content {
        display: block;
    }
</style>
</head>
<body>
<div class="container">
    <div class="sidebar">
        <h3>Libreria Componenti</h3>
        <div class="object-category">
            <div class="category-header">Giocatori</div>
            <div class="category-content" data-category="giocatori">
                <div class="object" draggable="true" data-shape="player" data-text="L1">L1</div>
                <div class="object" draggable="true" data-shape="player" data-text="L2">L2</div>
                <div class="object" draggable="true" data-shape="player" data-text="S1">S1</div>
                <div class="object" draggable="true" data-shape="player" data-text="S2">S2</div>
                <div class="object" draggable="true" data-shape="player" data-text="C1">C1</div>
                <div class="object" draggable="true" data-shape="player" data-text="C2">C2</div>
                <div class="object" draggable="true" data-shape="player" data-text="O">O</div>
                <div class="object" draggable="true" data-shape="player" data-text="P">P</div>
                <div class="object" draggable="true" data-shape="player" data-text="All">All</div>
                <div class="object" draggable="true" data-shape="player" data-text="Extra">Extra</div>
            </div>
        </div>

        <div class="object-category">
            <div class="category-header">Materiale</div>
            <div class="category-content" data-category="materiale">
                <div class="object" draggable="true" data-shape="mat" data-text="Tappetino">Tappetino</div>
                <div class="object" draggable="true" data-shape="ball-cart" data-text="">Carrello palloni</div>
                <div class="object" draggable="true" data-shape="ball" data-text="">pallone</div>
                <div class="object" draggable="true" data-shape="whistle" data-text="fischietto">fischietto</div>
                <div class="object" draggable="true" data-shape="plinth" data-text="">plinto</div>
                <div class="object" draggable="true" data-shape="net" data-text="">rete</div>
                <div class="object" draggable="true" data-shape="cone" data-text="">cinesino</div>
                <div class="object" draggable="true" data-shape="hoop" data-text="">canestro</div>
                <div class="object" draggable="true" data-shape="hoop-side" data-text="">canestro fr</div>
                <div class="object" draggable="true" data-shape="square" data-text="tappetone">tappetone</div>
                <div class="object" draggable="true" data-shape="wall" data-text="">muro palestra</div>
                <div class="object" draggable="true" data-shape="timer" data-text="00:00">timer</div>
                <div class="object" draggable="true" data-shape="arrow" data-text="">freccia</div>
            </div>
        </div>
        
        <div class="object-category">
            <div class="category-header">Strumenti</div>
            <div class="category-content" data-category="strumenti">
                <div class="tool-btn active" data-tool="curved">Freccia Curva</div>
                <div class="tool-btn" data-tool="linear">Freccia Lineare</div>
                <div class="tool-btn" data-tool="zigzag">Freccia a Zigzag</div>
            </div>
        </div>

        <div class="object-category">
            <div class="category-header">Campi</div>
            <div class="category-content" data-category="campi">
                <div class="object" draggable="true" data-shape="square" data-text="Singolo">Singolo</div>
                <div class="object" draggable="true" data-shape="square" data-text="Completo">Completo</div>
                <div class="object" draggable="true" data-shape="3D">3D</div>
            </div>
        </div>

        <div class="object-category">
            <div class="category-header">Corpo</div>
            <div class="category-content" data-category="corpo">
                <div class="object" draggable="true" data-shape="square" data-text="Mani">Mani</div>
                <div class="object" draggable="true" data-shape="square" data-text="bagher">bagher</div>
                <div class="object" draggable="true" data-shape="square" data-text="palleggio">palleggio</div>
                <div class="object" draggable="true" data-shape="square" data-text="schiacciata">schiacciata</div>
                <div class="object" draggable="true" data-shape="square" data-text="difesa">difesa</div>
                <div class="object" draggable="true" data-shape="square" data-text="ricezione">ricezione</div>
                <div class="object" draggable="true" data-shape="square" data-text="servizio">servizio</div>
            </div>
        </div>

        <div class="object-category">
            <div class="category-header">Testo</div>
            <div class="category-content" data-category="testo">
                <div class="object" draggable="true" data-shape="text-box" data-text="Note">Note</div>
            </div>
        </div>
        
        <div class="object-category">
            <div class="category-header">Dettagli</div>
            <div class="category-content" data-category="details">
                <div class="object" draggable="true" data-shape="text-box" data-text="x1">x1</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="x2">x2</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="x3">x3</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="x4">x4</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="10''">10''</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="20''">20''</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="30''">30''</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="40''">40''</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="50''">50''</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="1'">1'</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="10'">10'</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="20'">20'</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="30'">30'</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="x2S">x2S</div>
                <div class="object" draggable="true" data-shape="text-box" data-text="x4S">x4S</div>
            </div>
        </div>

        <div style="margin-top:18px">
            <strong>Shortcuts</strong>
            <div>Delete → elimina</div>
            <div>Ctrl+Z → undo</div>
            <div>Ctrl+Y → redo</div>
        </div>

        <div style="margin-top:18px">
            <strong>Descrizione Esercizio</strong>
            <textarea id="exercise-description" placeholder="Inserisci la descrizione dell'esercizio..." style="width:100%; height:100px; padding:5px; box-sizing:border-box;"></textarea>
        </div>
    </div>

    <div class="canvas" id="canvas">
        <div class="top-controls">
            <select id="background-selector">
                <option value="none">Trasparente</option>
                <option value="half-court">Metà Campo</option>
                <option value="full-court">Campo Completo</option>
                <option value="3d-court">Campo 3D</option>
            </select>
            <button id="toggle-grid-btn">Griglia OFF</button>
            <label for="bw-toggle">B/N</label>
            <input type="checkbox" id="bw-toggle">
            <button id="zoom-out-btn">-</button>
            <span id="zoom-level">100%</span>
            <button id="zoom-in-btn">+</button>
            <div class="dropdown">
                <button class="export-btn">Esporta</button>
                <div class="dropdown-content">
                    <button id="export-png-btn">PNG</button>
                    <button id="export-jpg-btn">JPG</button>
                    <button id="export-pdf-btn">PDF</button>
                </div>
            </div>
        </div>
        <div class="file-controls">
            <label for="drawing-title">Titolo:</label>
            <input type="text" id="drawing-title" placeholder="Inserisci titolo">
            <label for="drawing-category">Categoria:</label>
            <select id="drawing-category">
                <option value="">Seleziona...</option>
                <option value="riscaldamento">Riscaldamento</option>
                <option value="attivazione">Attivazione</option>
                <option value="analitico">Analitico</option>
                <option value="super-analitico">Super Analitico</option>
                <option value="sintetico">Sintetico</option>
                <option value="globale">Globale</option>
                <option value="globale-punteggio">Globale con punteggio</option>
                <option value="globale-gioco">Globale di gioco</option>
            </select>
            <label for="drawing-typology">Tipologia:</label>
            <select id="drawing-typology">
                <option value="">Seleziona...</option>
                <option value="preparazione">Preparazione</option>
                <option value="pre-campionato">Pre-campionato</option>
                <option value="post-campionato">Post-campionato</option>
                <option value="transitorio">Transitorio</option>
            </select>
            <button id="save-btn">Salva Disegno</button>
            <label for="file-input">Carica Disegno:</label>
            <input type="file" id="file-input" accept=".json">
        </div>
        <div class="canvas-container" id="canvas-container">
            <svg id="background-layer" class="background-container"></svg>
            <svg id="connection-layer">
                <defs>
                    <marker id="arrowhead" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" fill="#333" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div class="controls" id="object-controls">
        <label for="color-picker">Colore:</label>
        <input type="color" id="color-picker" value="#4682b4">
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const sidebarObjects = document.querySelectorAll('.object');
    const categoryHeaders = document.querySelectorAll('.category-header');
    const canvas = document.getElementById('canvas');
    const canvasContainer = document.getElementById('canvas-container');
    const svg = document.getElementById('connection-layer');
    const backgroundSvg = document.getElementById('background-layer');
    const controls = document.getElementById('object-controls');
    const colorPicker = document.getElementById('color-picker');
    const backgroundSelector = document.getElementById('background-selector');
    const zoomInBtn = document.getElementById('zoom-in-btn');
    const zoomOutBtn = document.getElementById('zoom-out-btn');
    const zoomLevelSpan = document.getElementById('zoom-level');
    const toggleGridBtn = document.getElementById('toggle-grid-btn');
    const saveBtn = document.getElementById('save-btn');
    const fileInput = document.getElementById('file-input');
    const drawingTitleInput = document.getElementById('drawing-title');
    const drawingCategorySelect = document.getElementById('drawing-category');
    const drawingTypologySelect = document.getElementById('drawing-typology');
    const exerciseDescriptionTextarea = document.getElementById('exercise-description');
    const toolButtons = document.querySelectorAll('.tool-btn');
    const bwToggle = document.getElementById('bw-toggle');
    const exportBtn = document.querySelector('.export-btn');
    const exportPngBtn = document.getElementById('export-png-btn');
    const exportJpgBtn = document.getElementById('export-jpg-btn');
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    const exportDropdown = document.querySelector('.dropdown');

    let selectedObject = null;
    let selectedLine = null;
    let isDragging = false, isResizing = false, isRotating = false, isConnecting = false, isDraggingCurve = false;
    let startX = 0, startY = 0, dragOffsetX = 0, dragOffsetY = 0;
    let startWidth = 0, startHeight = 0, startAngle = 0;
    let currentLine = null, startNode = null;
    let zoomLevel = 1.0;
    let isGridEnabled = false;
    let isGrayscaleEnabled = false;
    let currentArrowType = 'curved'; // New state variable

    let connections = [];
    let undoStack = [], redoStack = [];

    const defaultCurveOffset = { x: 0, y: 0 };

    function uid(prefix='o'){ return prefix + '-' + Date.now().toString(36) + '-' + Math.floor(Math.random()*1000) }

    function getCanvasRect(){ return canvasContainer.getBoundingClientRect() }

    function parsePos(val){
        if(val === undefined || val === null || val === '') return 0;
        return parseFloat((val+'').replace('px','')) || 0;
    }

    function getInitialColor(shape) {
        switch(shape) {
            case 'player': return '#007bff';
            case 'mat': return '#8B4513';
            case 'wall': return '#a0422d';
            case 'ball-cart': return '#555';
            case 'ball': return 'white';
            case 'whistle': return '#333';
            case 'plinth': return '#8b4513';
            case 'net': return 'transparent';
            case 'cone': return '#ff4500';
            case 'hoop': return 'transparent';
            case 'hoop-side': return '#f0f0f0';
            case 'timer': return '#333';
            case 'circle': return '#4682b4';
            case 'square': return '#4682b4';
            case 'triangle': return '#3cb371';
            case 'text-box': return '#000';
            case 'arrow': return '#333';
            case '3D': return '#4682b4'; // Assumi un colore per la rappresentazione 3D se necessario
            default: return '#4682b4'; // Colore di fallback
        }
    }

    function createObjectElement(model){
        const newObject = document.createElement('div');
        newObject.className = `dropped-object ${model.shape}-object`;
        newObject.id = model.id;
        newObject.style.left = (model.x || 0) + 'px';
        newObject.style.top = (model.y || 0) + 'px';
        
        if (model.width) newObject.style.width = model.width + 'px';
        if (model.height) newObject.style.height = model.height + 'px';
        if (model.rotation) newObject.style.transform = `rotate(${model.rotation}deg)`;

        if (model.shape === 'triangle'){
            newObject.style.borderBottomColor = model.color || getInitialColor(model.shape);
        } else if (model.shape === 'text-box' || model.shape === 'net'){
            newObject.style.color = model.color || getInitialColor(model.shape);
        } else {
            newObject.style.backgroundColor = model.color || getInitialColor(model.shape);
        }

        if (model.shape !== 'text-box' && model.shape !== 'arrow' && model.shape !== 'net') {
            const resizer = document.createElement('div'); resizer.className='resizer'; newObject.appendChild(resizer);
            const rotator = document.createElement('div'); rotator.className='rotator'; newObject.appendChild(rotator);
        }

        const textDiv = document.createElement('div'); textDiv.className='object-text'; textDiv.contentEditable="true";
        textDiv.textContent = model.text || '';
        newObject.appendChild(textDiv);

        if (model.shape !== 'text-box' && model.shape !== 'arrow' && model.shape !== 'net'){
            ['top','bottom','left','right'].forEach(pos=>{
                const node = document.createElement('div');
                node.className = `connection-node ${pos}`;
                node.dataset.parent = model.id;
                node.dataset.pos = pos;
                newObject.appendChild(node);
            });
        }

        canvasContainer.appendChild(newObject);
        return newObject;
    }

    function serializeState(){
        const objs = [];
        canvasContainer.querySelectorAll('.dropped-object').forEach(el=>{
            const shape = Array.from(el.classList).find(c=>c.endsWith('-object') && !c.includes('dropped')).replace('-object','');
            objs.push({
                id: el.id,
                shape,
                x: parsePos(el.style.left || getComputedStyle(el).left),
                y: parsePos(el.style.top || getComputedStyle(el).top),
                width: el.style.width ? parsePos(el.style.width) : (el.offsetWidth || undefined),
                height: el.style.height ? parsePos(el.style.height) : (el.offsetHeight || undefined),
                text: (el.querySelector('.object-text')?.textContent) || '',
                color: el.style.color || el.style.backgroundColor || getComputedStyle(el).borderBottomColor || '',
                rotation: el.style.transform.includes('rotate') ? parseFloat(el.style.transform.replace(/[^0-9-.]/g, '')) || 0 : 0
            });
        });

        const conns = connections.map(c => ({
            startId: c.startId,
            startPos: c.startPos,
            endId: c.endId,
            endPos: c.endPos,
            curveOffset: c.curveOffset,
            arrowType: c.arrowType // Save arrow type
        }));

        const background = backgroundSelector.value;
        const zoom = zoomLevel;
        const grid = isGridEnabled;
        const grayscale = isGrayscaleEnabled;
        const title = drawingTitleInput.value;
        const category = drawingCategorySelect.value;
        const typology = drawingTypologySelect.value;
        const description = exerciseDescriptionTextarea.value;


        return { objects: objs, connections: conns, background, zoom, grid, grayscale, title, category, typology, description };
    }

    function restoreState(snapshot){
        const defs = svg.querySelector('defs');
        const defsClone = defs ? defs.cloneNode(true) : null;

        canvasContainer.querySelectorAll('.dropped-object').forEach(el=>el.remove());
        while(svg.firstChild) svg.removeChild(svg.firstChild);
        if (defsClone) svg.appendChild(defsClone);

        canvasContainer.querySelectorAll('.curve-handle').forEach(el => el.remove());

        connections = [];

        snapshot.objects.forEach(m=>{
            createObjectElement(m);
        });

        snapshot.connections.forEach(c=>{
            const startParent = document.getElementById(c.startId);
            const endParent = document.getElementById(c.endId);
            if (!startParent || !endParent) return;
            const startNode = Array.from(startParent.querySelectorAll('.connection-node')).find(n=>n.dataset.pos===c.startPos);
            const endNode = Array.from(endParent.querySelectorAll('.connection-node')).find(n=>n.dataset.pos===c.endPos);
            if (!startNode || !endNode) return;
            const path = document.createElementNS('http://www.w3.org/2000/svg','path');
            path.setAttribute('class','connection-line');
            path.setAttribute('pointer-events','stroke');
            path.dataset.startId = c.startId;
            path.dataset.startPos = c.startPos;
            path.dataset.endId = c.endId;
            path.dataset.endPos = c.endPos;
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', '#333');
            path.setAttribute('marker-end', 'url(#arrowhead)');
            svg.appendChild(path);

            let curveHandle = null;
            if (c.arrowType === 'curved' && c.curveOffset) {
                curveHandle = document.createElement('div');
                curveHandle.className = 'curve-handle';
                canvasContainer.appendChild(curveHandle);
            }
            
            connections.push({
                startId: c.startId, 
                startPos: c.startPos, 
                endId: c.endId, 
                endPos: c.endPos, 
                lineElement: path, 
                startNode, 
                endNode, 
                curveHandle, 
                curveOffset: c.curveOffset || defaultCurveOffset,
                arrowType: c.arrowType || 'curved'
            });
        });

        if (snapshot.background) {
            backgroundSelector.value = snapshot.background;
            updateBackground();
        }
        if (snapshot.zoom) {
            zoomLevel = snapshot.zoom;
            updateZoom();
        }
        if (snapshot.grid !== undefined) {
            isGridEnabled = snapshot.grid;
            if (isGridEnabled) {
                canvas.classList.add('canvas-grid');
                toggleGridBtn.textContent = 'Griglia ON';
            } else {
                canvas.classList.remove('canvas-grid');
                toggleGridBtn.textContent = 'Griglia OFF';
            }
        }
        if (snapshot.grayscale !== undefined) {
            isGrayscaleEnabled = snapshot.grayscale;
            bwToggle.checked = isGrayscaleEnabled;
            if (isGrayscaleEnabled) {
                canvas.classList.add('grayscale');
            } else {
                canvas.classList.remove('grayscale');
            }
        }
        if (snapshot.title !== undefined) {
            drawingTitleInput.value = snapshot.title;
        }
        if (snapshot.category !== undefined) {
            drawingCategorySelect.value = snapshot.category;
        }
        if (snapshot.typology !== undefined) {
            drawingTypologySelect.value = snapshot.typology;
        }
        if (snapshot.description !== undefined) {
            exerciseDescriptionTextarea.value = snapshot.description;
        }

        updateConnections();
    }

    function saveState(pushToUndo=true){
        const snapshot = serializeState();
        if (pushToUndo){
            undoStack.push(JSON.stringify(snapshot));
            if (undoStack.length > 100) undoStack.shift();
            redoStack = [];
        }
    }

    function doUndo(){
        if (undoStack.length <= 1) return;
        const top = undoStack.pop();
        redoStack.push(top);
        const prev = undoStack[undoStack.length-1];
        if (prev) restoreState(JSON.parse(prev));
    }

    function doRedo(){
        if (redoStack.length === 0) return;
        const next = redoStack.pop();
        undoStack.push(next);
        restoreState(JSON.parse(next));
    }

    function getNodeCenterByIds(parentEl, nodeEl){
        const parentRect = parentEl.getBoundingClientRect();
        const canvasRect = getCanvasRect();
        let x = parentRect.left - canvasRect.left;
        let y = parentRect.top - canvasRect.top;
        const w = parentRect.width;
        const h = parentRect.height;
        switch(nodeEl.dataset.pos){
            case 'top': x += w/2; y += 0; break;
            case 'bottom': x += w/2; y += h; break;
            case 'left': x += 0; y += h/2; break;
            case 'right': x += w; y += h/2; break;
        }
        return {x,y};
    }

    function getZigZagPath(s, e, numPoints = 5) {
        const path = [`M ${s.x} ${s.y}`];
        for (let i = 1; i < numPoints; i++) {
            const t = i / numPoints;
            const px = s.x + t * (e.x - s.x);
            const py = s.y + t * (e.y - s.y);
            const perp = {
                x: (e.y - s.y) * 10,
                y: -(e.x - s.x) * 10
            };
            const offset = (i % 2 === 0) ? -1 : 1;
            path.push(`L ${px + offset * perp.x} ${py + offset * perp.y}`);
        }
        path.push(`L ${e.x} ${e.y}`);
        return path.join(' ');
    }

    function updateConnections(){
        for (let i = connections.length - 1; i >= 0; i--) {
            const c = connections[i];
            const startParent = document.getElementById(c.startId);
            const endParent = document.getElementById(c.endId);

            if (!startParent || !endParent) {
                if (c.lineElement && c.lineElement.parentNode === svg) svg.removeChild(c.lineElement);
                if (c.curveHandle && c.curveHandle.parentNode === canvasContainer) canvasContainer.removeChild(c.curveHandle);
                if (selectedLine && c.lineElement === selectedLine) selectedLine = null;
                connections.splice(i, 1);
                continue;
            }

            if (!c.startNode) c.startNode = startParent.querySelector(`.connection-node[data-pos="${c.startPos}"]`);
            if (!c.endNode) c.endNode = endParent.querySelector(`.connection-node[data-pos="${c.endPos}"]`);
            if (!c.startNode || !c.endNode) continue;

            const s = getNodeCenterByIds(startParent, c.startNode);
            const e = getNodeCenterByIds(endParent, c.endNode);

            if (!c.lineElement){
                const path = document.createElementNS('http://www.w3.org/2000/svg','path');
                path.setAttribute('class','connection-line');
                path.setAttribute('pointer-events','stroke');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#333');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                c.lineElement = path;
                svg.appendChild(path);
            }
            
            let d = '';
            let showHandle = false;
            switch(c.arrowType) {
                case 'linear':
                    d = `M ${s.x} ${s.y} L ${e.x} ${e.y}`;
                    break;
                case 'curved':
                    showHandle = true;
                    const midpoint = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
                    const cp = { x: midpoint.x + (c.curveOffset?.x || 0), y: midpoint.y + (c.curveOffset?.y || 0) };
                    d = `M ${s.x} ${s.y} Q ${cp.x} ${cp.y} ${e.x} ${e.y}`;
                    c.lineElement.dataset.curveHandlePos = `${cp.x},${cp.y}`;
                    c.lineElement.dataset.connIndex = i;
                    if (!c.curveHandle) {
                        c.curveHandle = document.createElement('div');
                        c.curveHandle.className = 'curve-handle';
                        canvasContainer.appendChild(c.curveHandle);
                    }
                    c.curveHandle.style.left = `${cp.x - 5}px`;
                    c.curveHandle.style.top = `${cp.y - 5}px`;
                    break;
                case 'zigzag':
                    d = getZigZagPath(s, e);
                    break;
            }

            c.lineElement.setAttribute('d', d);

            if (c.curveHandle) {
                c.curveHandle.style.display = showHandle ? 'block' : 'none';
                c.curveHandle.dataset.connIndex = i;
            }
        }
    }
    
    // New accordion logic
    categoryHeaders.forEach(header => {
        header.addEventListener('click', () => {
            const content = header.nextElementSibling;
            const wasActive = content.classList.contains('active');
            
            // Close all
            document.querySelectorAll('.category-content').forEach(c => c.classList.remove('active'));
            
            // Open clicked one if it was not active
            if (!wasActive) {
                content.classList.add('active');
            }
        });
    });

    // New tool button logic
    toolButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            toolButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentArrowType = btn.dataset.tool;
        });
    });

    bwToggle.addEventListener('change', () => {
        isGrayscaleEnabled = bwToggle.checked;
        if (isGrayscaleEnabled) {
            canvas.classList.add('grayscale');
        } else {
            canvas.classList.remove('grayscale');
        }
        saveState();
    });

    sidebarObjects.forEach(obj=>{
        obj.addEventListener('dragstart', e=>{
            e.dataTransfer.setData('text/plain', JSON.stringify({
                shape: e.target.dataset.shape,
                text: e.target.dataset.text
            }));
        });
    });

    canvas.addEventListener('dragover', e=>e.preventDefault());

    canvas.addEventListener('drop', e=>{
        e.preventDefault();
        try {
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            const shapeType = data.shape;
            const text = data.text;
            if (!shapeType) return;
            const rect = getCanvasRect();
            const coords = { x: (e.clientX - rect.left) / zoomLevel, y: (e.clientY - rect.top) / zoomLevel };
            // Usa la nuova funzione per ottenere il colore iniziale corretto
            const initialColor = getInitialColor(shapeType);
            const model = { id: uid('obj'), shape: shapeType, x: coords.x, y: coords.y, text: text, color: initialColor };
            createObjectElement(model);
            updateConnections();
            saveState();
        } catch (error) {
            console.error('Failed to parse dropped data:', error);
        }
    });
    
    canvas.addEventListener('mousedown', (e) => {
        const objectTarget = e.target.closest('.dropped-object');
        const lineTarget = e.target.closest('path.connection-line');
        const curveHandleTarget = e.target.closest('.curve-handle');
        const nodeTarget = e.target.closest('.connection-node');
        const resizerTarget = e.target.closest('.resizer');
        const rotatorTarget = e.target.closest('.rotator');
        
        if (!resizerTarget && !rotatorTarget && !curveHandleTarget && !nodeTarget) {
            deselectAll(); 
        }

        if (nodeTarget) {
            const parentId = nodeTarget.dataset.parent;
            const pos = nodeTarget.dataset.pos;
            const existingConnIndex = connections.findIndex(c => (c.startId === parentId && c.startPos === pos) || (c.endId === parentId && c.endPos === pos));

            if (existingConnIndex !== -1) {
                const existingConn = connections[existingConnIndex];
                if (existingConn.lineElement) {
                    existingConn.lineElement.remove();
                }
                if (existingConn.curveHandle) {
                    existingConn.curveHandle.remove();
                }
                connections.splice(existingConnIndex, 1);
            }

            isConnecting = true;
            startNode = nodeTarget;
            document.querySelectorAll('.dropped-object').forEach(o => o.classList.add('show-nodes'));
            const startParent = nodeTarget.parentElement;
            const startCenter = getNodeCenterByIds(startParent, startNode);
            currentLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            currentLine.setAttribute('class', 'connection-line');
            currentLine.setAttribute('fill', 'none');
            currentLine.setAttribute('stroke', '#333');
            currentLine.setAttribute('marker-end', 'url(#arrowhead)');
            currentLine.setAttribute('pointer-events', 'none');
            svg.appendChild(currentLine);
            return;
        }

        if (curveHandleTarget) {
            isDraggingCurve = true;
            const connIndex = parseInt(curveHandleTarget.dataset.connIndex);
            if (connections[connIndex]) {
                selectLine(connections[connIndex].lineElement);
            }
            return;
        }

        if (resizerTarget) {
            isResizing = true; 
            selectedObject = resizerTarget.parentElement; 
            startX = e.clientX; 
            startY = e.clientY; 
            startWidth = selectedObject.offsetWidth; 
            startHeight = selectedObject.offsetHeight;
            return;
        }

        if (rotatorTarget) {
            isRotating = true; 
            selectedObject = rotatorTarget.parentElement; 
            const rect = selectedObject.getBoundingClientRect(); 
            startX = rect.left + rect.width/2; 
            startY = rect.top + rect.height/2; 
            const dx = e.clientX - startX, dy = e.clientY - startY; 
            startAngle = Math.atan2(dy, dx) * 180 / Math.PI; 
            const currentTransform = new WebKitCSSMatrix(window.getComputedStyle(selectedObject).transform); 
            startAngle -= Math.atan2(currentTransform.c, currentTransform.a) * 180 / Math.PI;
            return;
        }
        
        if (objectTarget) {
            selectObject(objectTarget);
            const canvasRect = getCanvasRect();
            const currentLeft = parsePos(selectedObject.style.left);
            const currentTop = parsePos(selectedObject.style.top);
            const mouseX_unscaled = (e.clientX - canvasRect.left) / zoomLevel;
            const mouseY_unscaled = (e.clientY - canvasRect.top) / zoomLevel;
            dragOffsetX = mouseX_unscaled - currentLeft;
            dragOffsetY = mouseY_unscaled - currentTop;
            isDragging = true;
        } else if (lineTarget) {
            selectLine(lineTarget);
        }
    });

    canvas.addEventListener('mousemove', (e)=>{
        const rect = getCanvasRect();
        const mouseX = (e.clientX - rect.left) / zoomLevel;
        const mouseY = (e.clientY - rect.top) / zoomLevel;

        if (isConnecting && currentLine){
            const startParent = startNode.parentElement;
            const startCenter = getNodeCenterByIds(startParent, startNode);
            let d = '';
            if (currentArrowType === 'linear') {
                d = `M ${startCenter.x} ${startCenter.y} L ${mouseX} ${mouseY}`;
            } else if (currentArrowType === 'curved') {
                d = `M ${startCenter.x} ${startCenter.y} Q ${mouseX} ${mouseY} ${mouseX} ${mouseY}`;
            } else if (currentArrowType === 'zigzag') {
                d = getZigZagPath(startCenter, {x: mouseX, y: mouseY});
            }
            currentLine.setAttribute('d', d);
            return;
        }
        
        if (isDraggingCurve && selectedLine) {
            const connIndex = parseInt(selectedLine.dataset.connIndex);
            if (connections[connIndex]) {
                const conn = connections[connIndex];
                const s = getNodeCenterByIds(document.getElementById(conn.startId), conn.startNode);
                const e = getNodeCenterByIds(document.getElementById(conn.endId), conn.endNode);
                const midpoint = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
                conn.curveOffset = { x: mouseX - midpoint.x, y: mouseY - midpoint.y };
                updateConnections();
                return;
            }
        }

        if (isDragging && selectedObject){
            const newLeft = mouseX - dragOffsetX;
            const newTop = mouseY - dragOffsetY;
            selectedObject.style.left = newLeft + 'px';
            selectedObject.style.top = newTop + 'px';
            updateConnections();
            return;
        }

        if (isResizing && selectedObject){
            const newWidth = startWidth + (e.clientX - startX) / zoomLevel;
            const newHeight = startHeight + (e.clientY - startY) / zoomLevel;
            selectedObject.style.width = `${newWidth > 10 ? newWidth : 10}px`;
            selectedObject.style.height = `${newHeight > 10 ? newHeight : 10}px`;
            updateConnections();
            return;
        }

        if (isRotating && selectedObject){
            const dx = e.clientX - startX; const dy = e.clientY - startY;
            const newAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            const rotation = newAngle - startAngle;
            selectedObject.style.transform = `rotate(${rotation}deg)`;
            updateConnections();
            return;
        }
    });

    document.addEventListener('mouseup', (e)=>{
        if (isConnecting){
            const endNode = e.target.closest && e.target.closest('.connection-node');
            if (endNode && startNode && startNode.dataset.parent !== endNode.dataset.parent){
                const startParent = startNode.parentElement;
                const endParent = endNode.parentElement;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg','path');
                path.setAttribute('class','connection-line');
                path.setAttribute('pointer-events','stroke');
                path.setAttribute('d', currentLine.getAttribute('d'));
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#333');
                path.setAttribute('marker-end', 'url(#arrowhead)');

                let curveHandle = null;
                let curveOffset = null;
                if (currentArrowType === 'curved') {
                    curveHandle = document.createElement('div');
                    curveHandle.className = 'curve-handle';
                    canvasContainer.appendChild(curveHandle);
                    const rect = getCanvasRect();
                    const mouseX_unscaled = (e.clientX - rect.left) / zoomLevel;
                    const mouseY_unscaled = (e.clientY - rect.top) / zoomLevel;
                    const s = getNodeCenterByIds(startParent, startNode);
                    const end = getNodeCenterByIds(endParent, endNode);
                    const midpoint = { x: (s.x + end.x) / 2, y: (s.y + end.y) / 2 };
                    curveOffset = { x: mouseX_unscaled - midpoint.x, y: mouseY_unscaled - midpoint.y };
                }

                const conn = { 
                    startId: startParent.id, 
                    startPos: startNode.dataset.pos, 
                    endId: endParent.id, 
                    endPos: endNode.dataset.pos,
                    lineElement: path, 
                    startNode, 
                    endNode,
                    curveHandle,
                    curveOffset: curveOffset || defaultCurveOffset,
                    arrowType: currentArrowType
                };
                
                svg.appendChild(path);
                connections.push(conn);
                updateConnections();
                saveState();
            }

            if (currentLine && currentLine.parentNode === svg) svg.removeChild(currentLine);
            document.querySelectorAll('.dropped-object').forEach(o=>o.classList.remove('show-nodes'));
            isConnecting = false; 
            currentLine = null; 
            startNode = null;
        }

        if (isDragging || isDraggingCurve){ saveState(); }
        isDragging = isResizing = isRotating = isDraggingCurve = false;
    });
    
    document.addEventListener('keydown', (e) => {
        const activeElement = document.activeElement;
        const isInputActive = activeElement && (activeElement.classList.contains('object-text') || activeElement.id === 'drawing-title' || activeElement.id === 'drawing-category' || activeElement.id === 'drawing-typology' || activeElement.id === 'exercise-description');
        if (isInputActive) {
            return;
        }
        
        if (e.key === 'Delete'){
            if (selectedObject){
                for (let i = connections.length - 1; i >= 0; i--){
                    const c = connections[i];
                    if (c.startId === selectedObject.id || c.endId === selectedObject.id){
                        if (c.lineElement && c.lineElement.parentNode === svg) svg.removeChild(c.lineElement);
                        if (c.curveHandle && c.curveHandle.parentNode === canvasContainer) canvasContainer.removeChild(c.curveHandle);
                        if (selectedLine && selectedLine === c.lineElement) selectedLine = null;
                        connections.splice(i,1);
                    }
                }
                selectedObject.remove(); selectedObject = null; updateConnections(); saveState();
            } else if (selectedLine){
                const idx = connections.findIndex(c=>c.lineElement === selectedLine);
                if (idx !== -1){ 
                    const c = connections[idx]; 
                    if (c.lineElement && c.lineElement.parentNode === svg) svg.removeChild(c.lineElement); 
                    if (c.curveHandle && c.curveHandle.parentNode === canvasContainer) canvasContainer.removeChild(c.curveHandle);
                    connections.splice(idx,1); 
                    selectedLine = null; 
                    saveState(); 
                }
            }
        }
        if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')){ e.preventDefault(); doUndo(); }
        if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || e.key === 'Y')){ e.preventDefault(); doRedo(); }
    });
    
    function selectObject(el){ 
        if (!el) return; 
        el.classList.add('selected'); 
        selectedObject = el; 
        controls.classList.add('visible'); 
        const shapeType = Array.from(el.classList).find(c=>c.endsWith('-object')).replace('-object','');
        let currentColor; 
        if (shapeType === 'triangle'){ 
            currentColor = getComputedStyle(el).borderBottomColor; 
        } else if (shapeType === 'text-box' || shapeType === 'net') {
            currentColor = getComputedStyle(el).color;
        } else { 
            currentColor = getComputedStyle(el).backgroundColor; 
        } 
        colorPicker.value = rgbToHex(currentColor); 
        
        const textDiv = el.querySelector('.object-text'); 
        if (textDiv) textDiv.focus(); 
        
        canvasContainer.querySelectorAll('.curve-handle').forEach(el => el.style.display = 'none');
    }

    function selectLine(lineElement) {
        if (selectedObject) {
            selectedObject.classList.remove('selected');
        }
        if (selectedLine) {
            selectedLine.classList.remove('selected-line');
            const oldConn = connections.find(c => c.lineElement === selectedLine);
            if (oldConn) {
                if (oldConn.arrowType === 'curved' && oldConn.curveHandle) {
                    oldConn.curveHandle.style.display = 'none';
                }
            }
        }
        selectedLine = lineElement;
        selectedLine.classList.add('selected-line');
        const conn = connections.find(c => c.lineElement === selectedLine);
        if (conn && conn.arrowType === 'curved') {
            conn.curveHandle.style.display = 'block';
        }
    }

    function deselectAll(){ 
        const curObj = canvasContainer.querySelector('.dropped-object.selected'); 
        if (curObj) { 
            curObj.classList.remove('selected'); 
            const t = curObj.querySelector('.object-text'); 
            if (t) t.blur(); 
        } 
        selectedObject = null; 
        controls.classList.remove('visible'); 
        
        if (selectedLine){
            selectedLine.classList.remove('selected-line');
            const conn = connections.find(c => c.lineElement === selectedLine);
            if(conn && conn.curveHandle) {
                conn.curveHandle.style.display = 'none';
            }
            selectedLine = null;
        }
    }

    colorPicker.addEventListener('input', (e)=>{ 
        if (!selectedObject) return; 
        const s = Array.from(selectedObject.classList).find(c=>c.endsWith('-object')).replace('-object','');
        if (s === 'triangle'){ 
            selectedObject.style.borderBottomColor = e.target.value; 
        } else if (s === 'text-box' || s === 'net') {
             selectedObject.style.color = e.target.value;
        } else if (s === 'arrow'){
            selectedObject.style.backgroundColor = e.target.value;
            selectedObject.style.setProperty('--arrow-color', e.target.value);
            const sheet = document.styleSheets[0];
            const rule = Array.from(sheet.cssRules).find(r => r.selectorText === '.arrow-object::before');
            if(rule) rule.style.borderLeftColor = e.target.value;
        }
        else { 
            selectedObject.style.backgroundColor = e.target.value; 
        } 
        saveState(); 
    });

    canvas.addEventListener('click', (e)=>{ 
        const obj = e.target.closest('.dropped-object'); 
        const line = e.target.closest('path.connection-line');
        const node = e.target.closest('.connection-node');
        
        if (obj){ 
            if (obj !== selectedObject) {
                deselectAll(); 
                selectObject(obj); 
            }
        } else if (line){
            if (e.target !== selectedLine) {
                deselectAll();
                selectLine(e.target);
            }
        } else if (!node) {
            deselectAll();
        }
    });

    function rgbToHex(rgb){ 
        if (!rgb) return '#000000'; 
        if (rgb.includes('rgb')){ 
            const m = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/); 
            if (!m) return '#000000'; 
            const toHex = c => ('0' + parseInt(c).toString(16)).slice(-2); 
            return '#' + toHex(m[1]) + toHex(m[2]) + toHex(m[3]); 
        } 
        return rgb; 
    }

    function updateZoom() {
        canvasContainer.style.transform = `scale(${zoomLevel})`;
        svg.style.transform = `scale(${zoomLevel})`;
        backgroundSvg.style.transform = `scale(${zoomLevel})`;
        zoomLevelSpan.textContent = `${Math.round(zoomLevel * 100)}%`;
        updateConnections();
    }

    zoomInBtn.addEventListener('click', () => {
        zoomLevel = Math.min(2.0, zoomLevel + 0.1);
        updateZoom();
    });

    zoomOutBtn.addEventListener('click', () => {
        zoomLevel = Math.max(0.5, zoomLevel - 0.1);
        updateZoom();
    });

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        zoomLevel = Math.max(0.5, Math.min(2.0, zoomLevel + delta));
        updateZoom();
        updateConnections();
    });

    function updateBackground() {
        backgroundSvg.innerHTML = '';
        const canvasPadding = 100; // distanza dai bordi
        const selected = backgroundSelector.value;
        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;
        const strokeColor = '#666'; // Colore più scuro per le linee del campo
        
        // Ensure background is transparent, only drawing lines
        backgroundSvg.style.backgroundColor = 'transparent';

        function createPath(lines) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', lines.join(' '));
            path.setAttribute('stroke', strokeColor);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            backgroundSvg.appendChild(path);
        }

        if (selected === 'half-court') {
            const side = Math.min(width, height) - 2 * canvasPadding;
            const startX = (width - side) / 2;
            const startY = (height - side) / 2;
            const threeMeterY = startY + side / 3;

            const lines = [
                `M ${startX} ${startY} H ${startX + side} V ${startY + side} H ${startX} V ${startY}`,
                `M ${startX} ${threeMeterY} H ${startX + side}`
            ];

            createPath(lines);

        } else if (selected === 'full-court') {
            const sideWidth = width - 2 * canvasPadding;
            const sideHeight = height - 2 * canvasPadding;
            const startX = (width - sideWidth) / 2;
            const startY = (height - sideHeight) / 2;

            const verticalPositions = [
                sideWidth / 3,
                sideWidth / 2 + sideWidth / 6,
                sideWidth / 2
            ];

            const lines = [
                `M ${startX} ${startY} H ${startX + sideWidth} V ${startY + sideHeight} H ${startX} V ${startY}`,
                ...verticalPositions.map(x => `M ${startX + x} ${startY} V ${startY + sideHeight}`)
            ];

            createPath(lines);
        }else if (selected === '3d-court') {
            const lines = [
                `M 50 50 L 50 450 L 950 450 L 950 50 Z`,
                `M 50 250 L 950 250`,
                `M 500 50 L 500 450`,
                `M 275 50 L 275 450 M 725 50 L 725 450`
            ];
            const courtPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            courtPath.setAttribute('d', lines.join(' '));
            courtPath.setAttribute('stroke', strokeColor);
            courtPath.setAttribute('stroke-width', '2');
            courtPath.setAttribute('fill', 'none');
            backgroundSvg.appendChild(courtPath);
            
            const perspectiveLines = [
                `M 50 50 L ${width/2} 0 L 950 50`,
                `M 50 450 L ${width/2} ${height} L 950 450`,
                `M 50 250 L ${width/2} ${height/2} L 950 250`,
                `M 500 50 L ${width/2} 0 L 500 450 L ${width/2} ${height}`
            ];
            const perspectivePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            perspectivePath.setAttribute('d', perspectiveLines.join(' '));
            perspectivePath.setAttribute('stroke', strokeColor);
            perspectivePath.setAttribute('stroke-width', '2');
            perspectivePath.setAttribute('fill', 'none');
            backgroundSvg.appendChild(perspectivePath);

            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('x', width/2); text1.setAttribute('y', height/2 + 10);
            text1.setAttribute('text-anchor', 'middle'); text1.setAttribute('fill', strokeColor);
            text1.textContent = 'RETE';
            backgroundSvg.appendChild(text1);

        }
    }

    backgroundSelector.addEventListener('change', () => {
        updateBackground();
        saveState();
    });

    toggleGridBtn.addEventListener('click', () => {
        isGridEnabled = !isGridEnabled;
        if (isGridEnabled) {
            canvas.classList.add('canvas-grid');
            toggleGridBtn.textContent = 'Griglia ON';
        } else {
            canvas.classList.remove('canvas-grid');
            toggleGridBtn.textContent = 'Griglia OFF';
        }
        saveState();
    });

    saveBtn.addEventListener('click', () => {
        const state = serializeState();
        const jsonString = JSON.stringify(state, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const title = drawingTitleInput.value.replace(/[^a-z0-9]/gi, '_') || 'disegno';
        a.download = `${title}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const state = JSON.parse(event.target.result);
                restoreState(state);
                undoStack = [];
                redoStack = [];
                saveState();
                alert('Disegno caricato con successo!');
            } catch (error) {
                console.error('Errore nel caricamento del file:', error);
                alert('Errore nel caricamento del file. Assicurati che sia un file JSON valido.');
            }
        };
        reader.readAsText(file);
    });

    // Export functionality
    exportBtn.addEventListener('click', () => {
        exportDropdown.classList.toggle('active');
    });

    document.addEventListener('click', (e) => {
        if (!exportDropdown.contains(e.target)) {
            exportDropdown.classList.remove('active');
        }
    });

    async function exportCanvas(format) {
        // Temporarily hide UI elements that are not part of the drawing
        const elementsToHide = [
            document.querySelector('.top-controls'),
            document.querySelector('.file-controls'),
            document.querySelector('.controls'),
            document.querySelector('.sidebar')
        ];
        
        elementsToHide.forEach(el => { if (el) el.style.display = 'none'; });

        // Temporarily change background to white for better export
        const originalBodyBg = document.body.style.backgroundColor;
        document.body.style.backgroundColor = 'white';

        // Add a temporary background to the canvas container for export if it's transparent
        const originalCanvasBg = canvas.style.backgroundColor;
        canvas.style.backgroundColor = 'white';
        
        // Hide the grid for the export
        const wasGridEnabled = isGridEnabled;
        if (wasGridEnabled) {
            canvas.classList.remove('canvas-grid');
        }

        // Hide curve handles
        canvasContainer.querySelectorAll('.curve-handle').forEach(el => el.style.display = 'none');
        
        // Deselect any selected object
        deselectAll();

        try {
            const canvasElement = await html2canvas(canvasContainer, {
                scale: 2, // Improves resolution
                backgroundColor: null, // Allow canvas to be transparent
                allowTaint: true,
                useCORS: true
            });

            const drawingTitle = drawingTitleInput.value || 'disegno';

            if (format === 'png' || format === 'jpg') {
                const dataUrl = format === 'png' ? canvasElement.toDataURL('image/png') : canvasElement.toDataURL('image/jpeg', 0.9);
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `${drawingTitle}.${format}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } else if (format === 'pdf') {
                const imgData = canvasElement.toDataURL('image/jpeg', 1.0);
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const imgWidth = 210; 
                const pageHeight = 295; 
                const imgHeight = canvasElement.height * imgWidth / canvasElement.width;
                let heightLeft = imgHeight;
                let position = 0;

                pdf.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight);
                heightLeft -= pageHeight;

                while (heightLeft >= 0) {
                    position = heightLeft - imgHeight;
                    pdf.addPage();
                    pdf.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }
                pdf.save(`${drawingTitle}.pdf`);
            }
        } finally {
            // Restore UI elements and styles
            elementsToHide.forEach(el => { if (el) el.style.display = ''; });
            document.body.style.backgroundColor = originalBodyBg;
            canvas.style.backgroundColor = originalCanvasBg;
            if (wasGridEnabled) {
                canvas.classList.add('canvas-grid');
            }
            canvasContainer.querySelectorAll('.curve-handle').forEach(el => el.style.display = 'block');
        }
    }

    exportPngBtn.addEventListener('click', () => exportCanvas('png'));
    exportJpgBtn.addEventListener('click', () => exportCanvas('jpg'));
    exportPdfBtn.addEventListener('click', () => exportCanvas('pdf'));

    window.addEventListener('resize', updateBackground);

    function initialSetup(){ 
        document.querySelector('.object-category .category-header').click();
        saveState(); 
        updateBackground();
    }
    
    initialSetup();
});
</script>
</body>
</html>