<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Titolo SEO ottimizzato -->
    <title>Volleyball Coach Pro W4 - Editor e Workout per Allenatori di Pallavolo</title>
    <meta name="author" content="Filippo Morano">
    <!-- Meta descrizione SEO -->
    <meta name="description"
        content="Volleyball Coach Pro W4: il software professionale per allenatori di pallavolo. Crea schemi, programmi di workout e migliora le prestazioni della tua squadra.">

    <!-- Meta keyword (opzionale, poco usata oggi ma a volte utile) -->
    <meta name="keywords"
        content="Volleyball Coach, Volleyball Workout, Allenatori Pallavolo, Schemi Pallavolo, Software Allenamento">

    <!-- Open Graph per condivisione social -->
    <meta property="og:title" content="Volleyball Coach Pro W4 - Editor e Workout per Allenatori di Pallavolo">
    <meta property="og:description"
        content="Crea schemi, gestisci workout e migliora le prestazioni della tua squadra con Volleyball Coach Pro W4.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.filippomorano.com/">
    <meta property="og:image" content="https://www.filippomorano.com/immagine_preview.png">

    <!-- Favicon -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="./css/main.css">
</head>

<body>
    <div class="container" style="display: none;">
        <div class="sidebar" id="sidebar">
            <div class="component-category">
                <h3 class="accordion-header active">üë• Giocatori</h3>
                <div class="accordion-content active">
                    <div class="component-grid">
                        <div class="component-item" data-type="player" data-text='P1' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Alzatore 1</div>
                        </div>
                        <div class="component-item" data-type="player" data-text='L1' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Libero 1</div>
                        </div>
                        <div class="component-item" data-type="player" data-text='S1' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Banda 1</div>
                        </div>
                        <div class="component-item" data-type="player" data-text='O1' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Opp 1</div>
                        </div>
                        <div class="component-item" data-type="player" data-text='C1' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Centro 1</div>
                        </div>
                        <div class="component-item" data-type="player" data-text='All' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Allenatore</div>
                        </div>
                        <div class="component-item" data-type="player" data-text='Dir' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Dirigente</div>
                        </div>
                        <div class="component-item green" data-type="player" data-text='P2' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Alzatore 2</div>
                        </div>
                        <div class="component-item green" data-type="player" data-text='L2' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Libero 2</div>
                        </div>
                        <div class="component-item green" data-type="player" data-text='S2' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Banda 2</div>
                        </div>
                        <div class="component-item green" data-type="player" data-text='O2' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Opp 2</div>
                        </div>
                        <div class="component-item green" data-type="player" data-text='C2' data-color="">
                            <div class="component-icon">üèÉ</div>
                            <div>Centro 2</div>
                        </div>
                        <div class="component-item orange" data-type="player" data-text='A' data-color="">
                            <div class="component-icon">üèÉ‚Äç‚ôÇÔ∏è</div>
                            <div>A</div>
                        </div>
                        <div class="component-item orange" data-type="player" data-text='B' data-color="">
                            <div class="component-icon">üèÉ‚Äç‚ôÇÔ∏è</div>
                            <div>B</div>
                        </div>
                        <div class="component-item orange" data-type="player" data-text='C' data-color="">
                            <div class="component-icon">üèÉ‚Äç‚ôÇÔ∏è</div>
                            <div>C</div>
                        </div>
                        <div class="component-item orange" data-type="player" data-text='D' data-color="">
                            <div class="component-icon">üèÉ‚Äç‚ôÇÔ∏è</div>
                            <div>D</div>
                        </div>
                        <div class="component-item orange" data-type="player" data-text='E' data-color="">
                            <div class="component-icon">üèÉ‚Äç‚ôÇÔ∏è</div>
                            <div>E</div>
                        </div>
                        <div class="component-item orange" data-type="player" data-text='F' data-color="">
                            <div class="component-icon">üèÉ‚Äç‚ôÇÔ∏è</div>
                            <div>F</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="component-category">
                <h3 class="accordion-header">üèüÔ∏è Player</h3>
                <div class="accordion-content">
                    <div class="component-grid">
                        <div class="component-item" data-type="volleyball-player-bagher" data-text="">
                            <div class="component-icon">üèüÔ∏è</div>
                            <div>Bagher</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="component-category">
                <h3 class="accordion-header">üèüÔ∏è Campi</h3>
                <div class="accordion-content">
                    <div class="component-grid">
                        <div class="component-item" data-type="court" data-text="">
                            <div class="component-icon">üèüÔ∏è</div>
                            <div>Intero</div>
                        </div>
                        <div class="component-item" data-type="half-court" data-text="">
                            <div class="component-icon">üèüÔ∏è</div>
                            <div>Met√†</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="component-category">
                <h3 class="accordion-header">üèê Materiale</h3>
                <div class="accordion-content">
                    <div class="component-grid">
                        <div class="component-item" data-type="ball" data-text="">
                            <div class="component-icon">üèê</div>
                            <div>Pallone</div>
                        </div>
                        <div class="component-item" data-type="mat" data-text="">
                            <div class="component-icon">üü¶</div>
                            <div>Materassino</div>
                        </div>
                        <div class="component-item" data-type="net" data-text="">
                            <div class="component-icon">ü•Ö</div>
                            <div>Rete</div>
                        </div>
                        <div class="component-item" data-type="brick" data-text="">
                            <div class="component-icon">üß±</div>
                            <div>Mattone</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="component-category">
                <h3 class="accordion-header">üîß Strumenti</h3>
                <div class="accordion-content">
                    <div class="component-grid">
                        <div class="component-item" data-type="text" data-text="Testo">
                            <div class="component-icon">üìù</div>
                            <div>Testo</div>
                        </div>
                        <div class="component-item" id="arrowModeBtn">
                            <div class="component-icon">‚û°Ô∏è</div>
                            <div>Frecce</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="component-category">
                <h3 class="accordion-header">üé® Icone</h3>
                <div class="accordion-content">
                    <div class="component-grid">
                        <div class="component-item" data-type="icon" data-icon="fa-thin fa-volleyball" data-text="">
                            <div class="component-icon"><i class="fa-thin fa-volleyball"></i></div>
                            <div>Pallone</div>
                        </div>
                        <!-- Icone Sport -->
                        <div class="component-item" data-type="icon" data-icon="fas fa-trophy" data-text="">
                            <div class="component-icon"><i class="fas fa-trophy"></i></div>
                            <div>Trofeo</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-medal" data-text="">
                            <div class="component-icon"><i class="fas fa-medal"></i></div>
                            <div>Medaglia</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-stopwatch" data-text="">
                            <div class="component-icon"><i class="fas fa-stopwatch"></i></div>
                            <div>Timer</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-whistle" data-text="">
                            <div class="component-icon"><i class="fas fa-bullhorn"></i></div>
                            <div>Fischietto</div>
                        </div>
                        <!-- Frecce e Direzioni -->
                        <div class="component-item" data-type="icon" data-icon="fas fa-arrow-up" data-text="">
                            <div class="component-icon"><i class="fas fa-arrow-up"></i></div>
                            <div>Su</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-arrow-down" data-text="">
                            <div class="component-icon"><i class="fas fa-arrow-down"></i></div>
                            <div>Gi√π</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-arrow-left" data-text="">
                            <div class="component-icon"><i class="fas fa-arrow-left"></i></div>
                            <div>Sinistra</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-arrow-right" data-text="">
                            <div class="component-icon"><i class="fas fa-arrow-right"></i></div>
                            <div>Destra</div>
                        </div>
                        <!-- Simboli -->
                        <div class="component-item" data-type="icon" data-icon="fas fa-star" data-text="">
                            <div class="component-icon"><i class="fas fa-star"></i></div>
                            <div>Stella</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-heart" data-text="">
                            <div class="component-icon"><i class="fas fa-heart"></i></div>
                            <div>Cuore</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-check" data-text="">
                            <div class="component-icon"><i class="fas fa-check"></i></div>
                            <div>Check</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fa-solid fa-cart-shopping" data-text="">
                            <div class="component-icon"><i class="fa-solid fa-cart-shopping"></i></div>
                            <div>Cart</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fa-solid fa-hands-holding" data-text="">
                            <div class="component-icon"><i class="fa-solid fa-hands-holding"></i></div>
                            <div>palleggio</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fas fa-times" data-text="">
                            <div class="component-icon"><i class="fas fa-times"></i></div>
                            <div>X</div>
                        </div>
                        <div class="component-item" data-type="icon" data-icon="fa-solid fa-caret-up" data-text="">
                            <div class="component-icon"><i class="fa-solid fa-caret-up"></i></div>
                            <div>Cono</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="component-category">
                <h3 class="accordion-header">üñºÔ∏è Immagini SVG Locali</h3>
                <div class="accordion-content">
                    <div class="component-grid">
                        <div class="component-item" data-type="local-svg" data-src="data/images/volleyball_ball.svg">
                            <div class="component-icon">
                                <img src="data/images/volleyball_ball.svg" alt="Palla Sport"
                                    style="width: 20px; height: 20px;" />
                            </div>
                            <div>Palla Sport</div>
                        </div>

                        <div class="component-item" data-type="local-svg" data-src="data/images/player-bagher.png">
                            <div class="component-icon">
                                <img src="data/images/player-bagher.png" alt="Campo volleyball"
                                    style="width: 20px; height: 20px;" />
                            </div>
                            <div>Player bagher</div>
                        </div>
                        <div class="component-item" data-type="local-svg"
                            data-src="data/images/player-bagher-front.png">
                            <div class="component-icon">
                                <img src="data/images/player-bagher-front.png" alt="Campo volleyball"
                                    style="width: 20px; height: 20px;" />
                            </div>
                            <div>Player front</div>
                        </div>
                        <div class="component-item" data-type="local-svg" data-src="data/images/player-jump-spike.png">
                            <div class="component-icon">
                                <img src="data/images/player-jump-spike.png" alt="Campo volleyball"
                                    style="width: 20px; height: 20px;" />
                            </div>
                            <div>Player spike</div>
                        </div>
                        <div class="component-item" data-type="local-svg" data-src="data/images/player-upball.png">
                            <div class="component-icon">
                                <img src="data/images/player-upball.png" alt="Campo volleyball"
                                    style="width: 20px; height: 20px;" />
                            </div>
                            <div>Player up ball</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="component-category">
                <h3 class="accordion-header">üé¨ Sprite Pallavolo</h3>
                <div class="accordion-content">
                    <div class="component-grid">
                        <!-- Esempio: Giocatore che schiaccia -->
                        <div class="component-item" data-type="sprite"
                            data-sprite-sheet="data/images/sprites/volleyball-actions.png" data-sprite-cols="4"
                            data-sprite-rows="2" data-sprite-frame="0" data-sprite-width="64" data-sprite-height="64">

                            <div class="component-icon">
                                <div class="sprite-preview" style="
                background-image: url('data/images/sprites/volleyball-actions.png');
                background-position: 0px 0px;
                background-size: 256px 128px;
                width: 64px;
                height: 64px;
            ">
                                </div>
                            </div>

                            <div>Schiacciata</div>
                        </div>

                        <!-- Esempio: Giocatore in bagher -->
                        <div class="component-item" data-type="sprite"
                            data-sprite-sheet="data/images/sprites/volleyball-actions.png" data-sprite-cols="4"
                            data-sprite-rows="2" data-sprite-frame="1" data-sprite-width="64" data-sprite-height="64">
                            <div class="component-icon">
                                <div class="sprite-preview" style="background: url('data/images/sprites/volleyball-actions.png'); 
                                background-position: -64px 0; 
                                background-size: 256px 128px; 
                                width: 32px; 
                                height: 32px;"></div>
                            </div>
                            <div>Bagher</div>
                        </div>

                        <!-- Aggiungi altri frame qui -->
                    </div>
                </div>
            </div>
        </div>
        <div class="sidebar-handle" id="sidebarHandle">
            <button class="sidebar-switch" id="sidebarSwitch">‚óÄ</button>
        </div>

        <div class="main-content">
            <div class="toolbar">
                <fieldset class="toolbar-group">
                    <legend>Dimensione</legend>
                    <label>Dimensione:</label>
                    <select id="canvasSizeSelect">
                        <option value="custom">Personalizzato</option>
                        <option value="a5-portrait">A5 Verticale</option>
                        <option value="a5-landscape">A5 Orizzontale</option>
                        <option value="a4-portrait">A4 Verticale</option>
                        <option value="a4-landscape">A4 Orizzontale</option>
                        <option value="a3-portrait">A3 Verticale</option>
                        <option value="a3-landscape">A3 Orizzontale</option>
                        <option value="a2-portrait">A2 Verticale</option>
                        <option value="a2-landscape">A2 Orizzontale</option>
                        <option value="business-card">Biglietto da Visita</option>
                    </select>
                    <button id="toggleCanvasBorder">üñºÔ∏è Bordi</button>

                    <label>Background:</label>
                    <select id="backgroundSelect">
                        <option value="none">Nessuno</option>
                        <option value="half-field">Met√†</option>
                        <option value="full-field">Intero</option>
                        <option value="3d-field">Campo 3D</option>
                    </select>
                    <button id="zoomOut">‚ûñ</button>
                    <div class="zoom-display" id="zoomDisplay">100%</div>
                    <button id="zoomIn">‚ûï</button>
                    <button id="menu-notepad">Apri Blocco Note</button>

                </fieldset>
                <fieldset class="toolbar-group">
                    <legend>Squadra</legend>
                    <button id="manageTeamBtn">üë• Gestisci Squadra</button>
                    <button id="togglePlayerNames">üè∑Ô∏è Nomi Giocatori</button>
                </fieldset>
                <fieldset class="toolbar-group">
                    <legend>Ordina</legend>
                    <button id="bringToFront">‚¨ÜÔ∏è In primo piano</button>
                    <button id="sendToBack">‚¨áÔ∏è In background</button>
                </fieldset>
                <fieldset class="toolbar-group">
                    <legend>Visualizza</legend>
                    <button id="gridToggle">üìê Griglia</button>
                    <button id="snapToGridBtn">üß≤ Allinea alla Griglia</button>
                    <button id="bwToggle">‚ö´ B/N</button>
                    <button id="dashedToggle">‚ö° Tratteggio</button>
                    <button id="toggleLabels">üî¢ Etichette</button>
                    <button id="renumberObjects">üîÑ Rinumera</button>
                    <button id="exportPdfBtn" title="Esporta l'allenamento completo in un PDF strutturato.">üìÑ Esporta
                        PDF</button>
                    <button id="freehandModeBtn" title="Attiva modalit√† disegno a mano libera.">‚úèÔ∏è
                        Disegno</button>
                    <button id="exportFormationsBtn" title="Genera foglio formazioni per partite con 5 set">üìã Foglio
                        Formazioni</button>
                </fieldset>
                <fieldset class="toolbar-group">
                    <legend>Modifica</legend>
                    <button id="rotateLeft">‚Ü∫</button>
                    <button id="rotateRight">‚Üª</button>
                    <button id="groupRotateLeft">‚ü≤ Ruota Gruppo -15¬∞</button>
                    <button id="groupRotateRight">‚ü≥ Ruota Gruppo +15¬∞</button>
                    <button id="undoBtn">‚è™ Undo</button>
                    <button id="redoBtn">‚è© Redo</button>
                    <button id="historyBtn" title="Storico modifiche (Ctrl+H)">üìú Storico</button>
                </fieldset>

                <fieldset class="toolbar-group">
                    <legend>File</legend>
                    <input type="text" id="schemaTitle" placeholder="Titolo schema">
                    <button id="saveBtn">üíæ Salva</button>
                    <button id="saveWorkOutBtn">üíæ Salva Allenamento</button>
                    <button id="loadBtn">üìÅ Carica</button>
                    <button id="loadWorkOutBtn">üìÅ Carica Allenamento</button>
                    <input type="file" id="fileInput" accept=".json" style="display: none;">
                    <input type="file" id="workoutFileInput" accept=".json" style="display: none;">
                    <button id="exportBtn">üì§ Esporta</button>
                    <button id="exportWorkOutBtn">üì§ Genera la scheda di allenamento</button>
                    <button id="loadFromLibrary">üìÅ Libreria</button>
                </fieldset>
                <fieldset class="toolbar-group">
                    <legend>Utente</legend>
                    <div class="user-info" id="userInfo" style="display: none;">
                        <span>üë§ <span id="currentUsername"></span></span>
                        <button class="logout-button" id="logoutButton">Esci</button>
                    </div>
                </fieldset>
            </div>

            <div class="tabs-container">
                <div class="tab active" data-tab-id="1">
                    <input class='no-style tab-title' value='Schema 1' />
                    <span class="tab-close">√ó</span>
                </div>
                <button class="add-tab">+ Nuovo</button>
            </div>

            <div class="canvas-container">
                <div class="canvas" id="canvas"></div>
                <svg style="position: absolute; width: 0; height: 0;">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" />
                        </marker>
                    </defs>
                </svg>
            </div>

            <!-- Bottom Sidebar (Object Controls) -->
            <div class="bottom-sidebar-handle" id="bottomSidebarHandle">
                <button class="bottom-sidebar-switch" id="bottomSidebarSwitch">‚ñº</button>
            </div>

            <div class="bottom-sidebar" id="bottomSidebar">
                <div class="bottom-toolbar-group">
                    <fieldset id="objectControls" class="toolbar-group" style="display: none">
                        <legend>Oggetto</legend>
                        <div class="color-picker-container">
                            <label>Colore oggetto:</label>
                            <input type="color" class="color-picker" id="objectColor" value="#3498db">
                        </div>
                        <div>
                            <label>Opacit√†:</label>
                            <input type="range" id="objectOpacity" min="0" max="1" value="1" step="0.01">
                            <span id="objectOpacityValue">1.00</span>
                        </div>
                        <div>
                            <label>Testo:</label>
                            <input type="text" id="objectText" placeholder="Modifica testo">
                        </div>
                        <div>
                            <label>Numero etichetta:</label>
                            <input type="number" id="objectNumber" min="1" placeholder="Numero" style="width: 80px;">
                        </div>
                        <button id="dashedObjectToggle" class="toolbar-button" style="display: none;">Bordo
                            Tratteggiato</button>
                    </fieldset>

                    <fieldset id="arrowControls" class="toolbar-group" style="display: none">
                        <legend>Freccia</legend>
                        <div class="color-picker-container">
                            <label>Colore freccia:</label>
                            <input type="color" class="color-picker" id="arrowColor" value="#000000">
                        </div>
                        <div>
                            <label>Opacit√†:</label>
                            <input type="range" id="arrowOpacity" min="0" max="1" value="1" step="0.01">
                            <span id="arrowOpacityValue">1.00</span>
                        </div>
                        <div>
                            <label>Spessore:</label>
                            <input type="range" id="arrowThickness" min="1" max="10" value="3">
                            <span id="thicknessValue">3</span>
                        </div>
                        <div class="arrow-type-controls">
                            <label>Tipo:</label>
                            <button id="arrowTypeLinear" class="arrow-type-btn">Lineare</button>
                            <button id="arrowTypeCurved" class="arrow-type-btn">Curva</button>
                            <button id="arrowTypeZigzag" class="arrow-type-btn">Zigzag</button>
                        </div>
                        <button id="dashedArrowToggle" class="toolbar-button">Freccia Tratteggiata</button>
                    </fieldset>

                    <fieldset id="spriteControls" class="toolbar-group" style="display: none">
                        <legend>Sprite</legend>
                        <div>
                            <label>Frame corrente:</label>
                            <input type="number" id="spriteCurrentFrame" min="0" max="7" value="0" style="width: 60px;">
                            <span id="spriteFrameInfo">(0-7)</span>
                        </div>

                        <div class="sprite-animation-controls">
                            <label>Animazione:</label>
                            <input type="text" id="spriteAnimationFrames" placeholder="es: 0,1,2,3"
                                style="width: 120px;" title="Sequenza frame separati da virgola">
                            <label>FPS:</label>
                            <input type="number" id="spriteAnimationFPS" min="1" max="60" value="10"
                                style="width: 60px;">
                            <button id="spritePlayAnimation" class="toolbar-button">‚ñ∂ Play</button>
                            <button id="spriteStopAnimation" class="toolbar-button" style="display: none;">‚è∏
                                Stop</button>
                        </div>

                        <div>
                            <label>Dimensioni frame:</label>
                            <input type="number" id="spriteFrameWidth" min="8" max="512" value="64"
                                style="width: 60px;">
                            <span>√ó</span>
                            <input type="number" id="spriteFrameHeight" min="8" max="512" value="64"
                                style="width: 60px;">
                            <button id="spriteApplySize" class="toolbar-button">Applica</button>
                        </div>
                    </fieldset>

                    <fieldset class="toolbar-group">
                        <legend>Animazione</legend>
                        <button id="showAnimationControls">üé¨ Animazione</button>
                    </fieldset>
                    <fieldset id="freehandControls" class="toolbar-group" style="display: none">
                        <legend>Disegno a mano libera</legend>
                        <div class="color-picker-container">
                            <label>Colore traccia:</label>
                            <input type="color" class="color-picker" id="freehandColor" value="#000000">
                        </div>
                        <div>
                            <label>Spessore:</label>
                            <input type="range" id="freehandThickness" min="1" max="15" value="3">
                            <span id="freehandThicknessValue">3</span>
                        </div>
                        <div>
                            <label>Opacit√†:</label>
                            <input type="range" id="freehandOpacity" min="0" max="1" value="1" step="0.01">
                            <span id="freehandOpacityValue">1.00</span>
                        </div>
                    </fieldset>

                    <div class="arrow-marker-controls">
                        <label>Terminali:</label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="arrowMarkerStart"> Inizio
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="arrowMarkerEnd" checked> Fine
                        </label>
                    </div>

                    <div>
                        <button id="deleteBtn">üóëÔ∏è Elimina</button>
                    </div>

                    <div>
                        <span id="objectInfo">Nessun oggetto selezionato</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="right-sidebar-handle" id="rightSidebarHandle"><button class="right-sidebar-switch"
                id="rightSidebarSwitch">‚ñ∂</button>
        </div>
        <div class="right-sidebar" id="rightSidebar">
            <div class="exercise-steps">
                <h3>üìù Step Esercizio</h3>
                <div class="steps-controls">
                    <input type="text" id="newStepInput" placeholder="Inserisci nuovo step...">
                    <button id="addStepBtn">‚ûï Aggiungi</button>
                </div>
                <button id="generateAISteps"
                    style="width: 100%; margin: 10px 0; padding: 8px; background: #9b59b6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    ‚ú® Genera Step con AI
                </button>
                <div id="stepsList" class="steps-list">
                    <!-- Gli step verranno inseriti qui dinamicamente -->
                </div>
            </div>
            <div class="workout-details">
                <h3>üìã Dettagli Esercizio</h3>
                <div class="detail-row">
                    <div class="detail-field">
                        <label for="workoutDate">Data:</label>
                        <input type="text" id="workoutDate" placeholder="AAAA-MM-GG" pattern="\d{4}-\d{2}-\d{2}"
                            title="Inserisci la data nel formato AAAA-MM-GG (es: 2025-01-30)" required>
                    </div>
                    <div class="detail-field">
                        <label for="workoutPlace">Dove:</label>
                        <input type="text" id="workoutPlace">
                    </div>
                </div>
                <div class="detail-row">
                    <div class="detail-field">
                        <label for="workoutGroups">Gruppo:</label>
                        <select id="workoutGroups">
                            <option value="*">All</option>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="5">6</option>
                        </select>
                    </div>
                    <div class="detail-field">
                        <label for="workoutRuolo">Ruolo:</label>
                        <select id="workoutRuolo">
                            <option value="GEN">Generico</option>
                            <option value="L">Libero</option>
                            <option value="L1">Libero 1</option>
                            <option value="L2">Libero 2</option>
                            <option value="L+S">Libero + Schiacciatore</option>
                            <option value="L+A">Libero + Alzatore</option>
                            <option value="A">Alzatore</option>
                            <option value="S">Schiacciatore</option>
                            <option value="S1">Schiacciatore 1</option>
                            <option value="S2">Schiacciatore 2</option>
                            <option value="C">Centrale</option>
                            <option value="C1">Centrale 1</option>
                            <option value="C2">Centrale 2</option>
                            <option value="O">Opposto</option>
                        </select>
                    </div>
                </div>
                <div class="detail-row">
                    <div class="detail-field">
                        <label for="workoutNr">Ripetizioni:</label>
                        <input type="text" id="workoutNr">
                    </div>
                    <div class="detail-field">
                        <label for="workoutSeries">Serie:</label>
                        <input type="text" id="workoutSeries">
                    </div>
                </div>
                <div class="detail-row">
                    <div class="detail-field">
                        <label for="workoutTiming">Durata (sec):</label>
                        <input type="number" id="workoutTiming" min="0" max="600" value="1">
                    </div>
                    <div class="detail-field">
                        <label for="workoutRec">Recupero (sec):</label>
                        <input type="number" id="workoutRec" min="0" max="600" value="60">
                    </div>
                </div>
                <div class="detail-row">
                    <div class="detail-field">
                        <label for="workoutPeriodo">Periodo:</label>
                        <select id="workoutPeriodo">
                            <option value="GEN">Generico</option>
                            <option value="FIS">Preparazione fisica</option>
                            <option value="CAM">Campionato</option>
                            <option value="PRE">Pre-Campionato</option>
                            <option value="POS">Post-Campionato</option>
                        </select>
                    </div>



                    <div class="detail-field">
                        <label for="workoutTipologia">Tipologia:</label>
                        <select id="workoutTipologia">
                            <option value="GEN">Generico</option>
                            <option value="ANA">Analitico</option>
                            <option value="SIN">Sintetico</option>
                            <option value="GLO">Globale</option>
                        </select>
                    </div>
                </div>
                <div class="detail-row">

                    <!-- ‚úÖ NUOVI CAMPI AGGIUNTI -->
                    <div class="detail-field">
                        <label for="workoutGenere">Genere:</label>
                        <select id="workoutGenere">
                            <option value="GEN">Generico</option>
                            <option value="MIS">Misto</option>
                            <option value="M">Maschile</option>
                            <option value="F">Femminile</option>
                        </select>
                    </div>
                    <div class="detail-field">
                        <label for="workoutCategoria">Categoria:</label>
                        <select id="workoutCategoria">
                            <optgroup label="üéØ Generica">
                                <option value="GEN">Generico</option>
                            </optgroup>
                            <optgroup label="üë∂ Giovanili Maschili">
                                <option value="U12M">Under 12 M</option>
                                <option value="U13M">Under 13 M</option>
                                <option value="U14M">Under 14 M</option>
                                <option value="U15M">Under 15 M</option>
                                <option value="U16M">Under 16 M</option>
                                <option value="U17M">Under 17 M</option>
                                <option value="U18M">Under 18 M</option>
                                <option value="U19M">Under 19 M</option>
                            </optgroup>
                            <optgroup label="üëß Giovanili Femminili">
                                <option value="U12F">Under 12 F</option>
                                <option value="U13F">Under 13 F</option>
                                <option value="U14F">Under 14 F</option>
                                <option value="U16F">Under 16 F</option>
                                <option value="U18F">Under 18 F</option>
                            </optgroup>
                            <optgroup label="üèÜ Senior Maschili">
                                <option value="A1M">Superlega (A1) M</option>
                                <option value="A2M">Serie A2 M</option>
                                <option value="A3M">Serie A3 M</option>
                                <option value="BM">Serie B M</option>
                                <option value="CM">Serie C M</option>
                                <option value="DM">Serie D M</option>
                                <option value="1DM">Prima Divisione M</option>
                                <option value="2DM">Seconda Divisione M</option>
                                <option value="3DM">Terza Divisione M</option>
                            </optgroup>
                            <optgroup label="üèê Senior Femminili">
                                <option value="A1F">Serie A1 F</option>
                                <option value="A2F">Serie A2 F</option>
                                <option value="A3F">Serie A3 F</option>
                                <option value="B1F">Serie B1 F</option>
                                <option value="B2F">Serie B2 F</option>
                                <option value="CF">Serie C F</option>
                                <option value="DF">Serie D F</option>
                                <option value="1DF">Prima Divisione F</option>
                                <option value="2DF">Seconda Divisione F</option>
                                <option value="3DF">Terza Divisione F</option>
                            </optgroup>
                            <optgroup label="üåä Altri">
                                <option value="BEACH">Beach Volley</option>
                                <option value="SNOW">Snow Volley</option>
                                <option value="CSI">CSI/UISP</option>
                                <option value="SCO">Scolastico</option>
                            </optgroup>
                        </select>
                    </div>
                </div>
                <div class="detail-field">
                    <label for="workoutDescrizione">Note:</label>
                    <textarea id="workoutDescrizione" placeholder="Inserisci note sull'allenamento..."></textarea>
                </div>

                <div class="detail-field">
                    <label for="workoutAutore">Autore:</label>
                    <input type="text" id="workoutAutore" readonly
                        style="background: #95a5a6; cursor: not-allowed; border:none; width:100%;">
                </div>
            </div>
        </div>
    </div>

    <script>
        function setDefaultDate(fieldName) {
            const dateField = document.getElementById(fieldName);
            if (dateField) {
                const today = new Date();

                // 1. Ottiene l'anno (YYYY)
                const yyyy = today.getFullYear();

                // 2. Ottiene il mese (MM): Aggiunge 1 (i mesi vanno da 0 a 11) e usa padStart per avere sempre due cifre.
                const mm = String(today.getMonth() + 1).padStart(2, '0');

                // 3. Ottiene il giorno (DD): Usa padStart per avere sempre due cifre.
                const dd = String(today.getDate()).padStart(2, '0');

                // COSTRUZIONE DEL FORMATO YYYY-MM-DD
                const formattedDate = `${yyyy}-${mm}-${dd}`;

                // Imposta il valore (es: "2025-10-03")
                dateField.value = formattedDate;
            }
        }
        /**
         * Calcola il valore di Tonalit√† (Hue) da un colore Hex.
         * @param {string} hex - Il codice colore esadecimale (es. "#3498db" o "3498db").
         * @returns {number} Il valore di hue in gradi (0-360).
         */
        function getHue(hex) {
            // Rimuove l'hash e converte in RGB
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });

            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!result) return 0; // Ritorna 0 se non √® un colore valido

            let r = parseInt(result[1], 16) / 255;
            let g = parseInt(result[2], 16) / 255;
            let b = parseInt(result[3], 16) / 255;

            let max = Math.max(r, g, b),
                min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // Colore grigio (monocromatico)
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }

            // Converte in gradi (0-360)
            return h * 360;
        }
        class SchemaEditor {
            constructor() {
                this.tabs = new Map();
                this.activeTabId = 1;
                this.nextTabId = 2;
                this.nextObjectId = 1;
                this.isDragging = false;
                this.isResizing = false;
                this.isRotating = false;
                this.isConnecting = false;
                this.arrowMode = false;
                this.dashedMode = false; // New property for dashed mode for new objects/arrows
                this.selectedObject = null;
                this.selectedObjects = new Map();
                this.selectedArrow = null;
                this.dragOffset = { x: 0, y: 0 };
                this.connectionStart = null;
                this.connectionPreview = null;
                this.arrowType = 'linear'; // Default to linear as requested
                this.zoom = 1;
                this.isDraggingEndpoint = false;
                this.draggedEndpointType = null;
                this.clipboard = null;

                this.isSelecting = false;
                this.selectionStart = { x: 0, y: 0 };
                this.canvasRect = null;
                this.libraryWorkouts = []; // Array per i metadati degli allenamenti
                this.selectedLibraryFile = null; // Nome file selezionato
                this.librarySource = 'unknown';
                this.maxZIndex = 1;
                this.currentUser = null;
                this.users = [];
                this.freehandMode = false;
                this.isDrawing = false;
                this.currentFreehand = null;
                this.freehandPoints = [];
                this.selectedFreehand = null;
                this.draggedFrameIndex = null;
                this.draggedStepIndex = null;
                this.teamPlayers = this.loadTeamFromStorage();
                this.showPlayerNames = false;
                this.currentWorkoutObjective = '';
                this.currentWorkoutObservations = '';
                this.canvasSize = 'custom';
                this.showCanvasBorder = false;
                this.historyMetadata = new Map();
                this.floatingToolbarGroups = new Map(); // Traccia gruppi floating
                this.initToolbarDragDrop();
                this.initLibraryLoading();
                this.initializeTab(1, 'Schema 1');
                this.initCanvasResize();
                const mainContainer = document.querySelector('.container');
                if (mainContainer) {
                    mainContainer.style.display = 'none';
                }

                this.initLogin();
                //this.initializeEventListeners();
                this.initializeExistingTabs();
                this.updateUI();
            }

            // Aggiungi questo nuovo metodo dopo initializeEventListeners()
            initToolbarDragDrop() {
                const toolbar = document.querySelector('.toolbar');
                const bottomSidebar = document.getElementById('bottomSidebar');
                const bottomToolbarGroup = bottomSidebar.querySelector('.bottom-toolbar-group');
                const toolbarGroups = document.querySelectorAll('.toolbar-group');

                let draggedGroup = null;
                let placeholder = null;
                let isDraggingToolbar = false;
                let startX, startY;
                let offsetX, offsetY;
                let initialParent = null;
                let dragClone = null;

                toolbarGroups.forEach(group => {
                    group.setAttribute('draggable', 'true');

                    group.addEventListener('dragstart', (e) => {
                        draggedGroup = group;
                        isDraggingToolbar = true;
                        initialParent = group.parentElement;

                        const rect = group.getBoundingClientRect();
                        offsetX = e.clientX - rect.left;
                        offsetY = e.clientY - rect.top;
                        startX = e.clientX;
                        startY = e.clientY;

                        group.classList.add('dragging');

                        // ‚úÖ MODIFICA: Crea un clone visivo invece di nascondere l'originale
                        dragClone = group.cloneNode(true);
                        dragClone.style.position = 'fixed';
                        dragClone.style.pointerEvents = 'none';
                        dragClone.style.opacity = '0.8';
                        dragClone.style.zIndex = '10000';
                        dragClone.style.left = (e.clientX - offsetX) + 'px';
                        dragClone.style.top = (e.clientY - offsetY) + 'px';
                        document.body.appendChild(dragClone);

                        // Crea placeholder
                        placeholder = document.createElement('div');
                        placeholder.className = 'toolbar-group toolbar-placeholder';
                        placeholder.style.width = rect.width + 'px';
                        placeholder.style.height = rect.height + 'px';
                        placeholder.style.display = 'inline-flex';
                        placeholder.style.opacity = '0.5';
                        placeholder.style.border = '2px dashed #3498db';

                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/html', group.innerHTML);

                        // ‚úÖ RIMUOVI QUESTE RIGHE CHE CAUSANO IL PROBLEMA:
                        // const img = new Image();
                        // img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                        // e.dataTransfer.setDragImage(img, 0, 0);

                        // ‚úÖ AGGIUNGI INVECE:
                        // Nascondi l'elemento originale durante il drag
                        setTimeout(() => {
                            group.style.opacity = '0.3';
                        }, 0);
                    });

                    group.addEventListener('drag', (e) => {
                        if (!isDraggingToolbar || !draggedGroup) return;

                        // ‚úÖ MODIFICA: Aggiorna solo il clone, non l'elemento originale
                        if (dragClone && e.clientX !== 0 && e.clientY !== 0) {
                            dragClone.style.left = (e.clientX - offsetX) + 'px';
                            dragClone.style.top = (e.clientY - offsetY) + 'px';
                        }
                    });

                    group.addEventListener('dragend', (e) => {
                        if (!draggedGroup) return;

                        draggedGroup.classList.remove('dragging');
                        draggedGroup.style.opacity = '1'; // ‚úÖ AGGIUNGI: Ripristina opacit√†
                        toolbar.classList.remove('drag-over');
                        bottomToolbarGroup.classList.remove('drag-over');

                        // ‚úÖ NUOVO: Rimuovi il clone
                        if (dragClone) {
                            dragClone.remove();
                            dragClone = null;
                        }

                        const toolbarRect = toolbar.getBoundingClientRect();
                        const bottomRect = bottomToolbarGroup.getBoundingClientRect();

                        const isOverToolbar = (
                            e.clientX >= toolbarRect.left &&
                            e.clientX <= toolbarRect.right &&
                            e.clientY >= toolbarRect.top &&
                            e.clientY <= toolbarRect.bottom
                        );

                        const isOverBottom = (
                            e.clientX >= bottomRect.left &&
                            e.clientX <= bottomRect.right &&
                            e.clientY >= bottomRect.top &&
                            e.clientY <= bottomRect.bottom
                        );

                        if (!isOverToolbar && !isOverBottom &&
                            (initialParent === toolbar || initialParent === bottomToolbarGroup)) {
                            // Diventa floating
                            draggedGroup.classList.remove('docked');
                            draggedGroup.classList.add('floating');
                            draggedGroup.style.position = 'fixed';
                            draggedGroup.style.left = (e.clientX - offsetX) + 'px';
                            draggedGroup.style.top = (e.clientY - offsetY) + 'px';
                            draggedGroup.style.zIndex = '9999';

                            const floatingId = draggedGroup.id || `floating-${Date.now()}`;
                            if (!draggedGroup.id) draggedGroup.id = floatingId;

                            this.floatingToolbarGroups.set(floatingId, {
                                element: draggedGroup,
                                x: e.clientX - offsetX,
                                y: e.clientY - offsetY
                            });

                            if (draggedGroup.parentNode === toolbar || draggedGroup.parentNode === bottomToolbarGroup) {
                                draggedGroup.remove();
                                document.body.appendChild(draggedGroup);
                            }

                            this.addRedockButton(draggedGroup);

                        } else if (isOverToolbar && draggedGroup.classList.contains('floating')) {
                            this.redockGroup(draggedGroup, 'top');
                        } else if (isOverBottom && draggedGroup.classList.contains('floating')) {
                            this.redockGroup(draggedGroup, 'bottom');
                        } else {
                            draggedGroup.classList.remove('floating');
                            draggedGroup.classList.add('docked');
                            draggedGroup.style.position = '';
                            draggedGroup.style.left = '';
                            draggedGroup.style.top = '';
                            draggedGroup.style.zIndex = '';
                        }

                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.removeChild(placeholder);
                        }

                        draggedGroup = null;
                        placeholder = null;
                        isDraggingToolbar = false;
                        initialParent = null;
                    });

                    // Doppio click su floating group per re-dockare
                    group.addEventListener('dblclick', (e) => {
                        if (group.classList.contains('floating')) {
                            e.preventDefault();
                            this.showDockMenu(group, e.clientX, e.clientY);
                        }
                    });
                });

                // Dragover per toolbar superiore
                toolbar.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (!draggedGroup) return;

                    e.dataTransfer.dropEffect = 'move';
                    toolbar.classList.add('drag-over');

                    const afterElement = this.getDragAfterElement(toolbar, e.clientX);

                    if (placeholder && placeholder.parentNode) {
                        placeholder.remove();
                    }

                    if (afterElement == null) {
                        toolbar.appendChild(placeholder);
                    } else {
                        toolbar.insertBefore(placeholder, afterElement);
                    }
                });

                // Dragover per bottom toolbar
                bottomToolbarGroup.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (!draggedGroup) return;

                    e.dataTransfer.dropEffect = 'move';
                    bottomToolbarGroup.classList.add('drag-over');

                    const afterElement = this.getDragAfterElement(bottomToolbarGroup, e.clientX);

                    if (placeholder && placeholder.parentNode) {
                        placeholder.remove();
                    }

                    if (afterElement == null) {
                        bottomToolbarGroup.appendChild(placeholder);
                    } else {
                        bottomToolbarGroup.insertBefore(placeholder, afterElement);
                    }
                });

                toolbar.addEventListener('dragleave', (e) => {
                    if (e.target === toolbar) {
                        toolbar.classList.remove('drag-over');
                    }
                });

                bottomToolbarGroup.addEventListener('dragleave', (e) => {
                    if (e.target === bottomToolbarGroup) {
                        bottomToolbarGroup.classList.remove('drag-over');
                    }
                });

                toolbar.addEventListener('drop', (e) => {
                    e.preventDefault();
                    toolbar.classList.remove('drag-over');

                    if (!draggedGroup) return;

                    if (placeholder && placeholder.parentNode) {
                        toolbar.insertBefore(draggedGroup, placeholder);
                        placeholder.remove();
                    }
                });

                bottomToolbarGroup.addEventListener('drop', (e) => {
                    e.preventDefault();
                    bottomToolbarGroup.classList.remove('drag-over');

                    if (!draggedGroup) return;

                    if (placeholder && placeholder.parentNode) {
                        bottomToolbarGroup.insertBefore(draggedGroup, placeholder);
                        placeholder.remove();
                    }
                });
            }

            // Modifica il metodo showDockMenu per permettere la scelta
            showDockMenu(group, x, y) {
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.id = 'dockMenu';
                menu.style.position = 'fixed';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.style.zIndex = '10001';

                menu.innerHTML = `
        <div class="context-menu-item" data-dock="top">üîù Ancora in alto</div>
        <div class="context-menu-item" data-dock="bottom">üîΩ Ancora in basso</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-dock="cancel">‚ùå Annulla</div>
    `;

                document.body.appendChild(menu);

                menu.addEventListener('click', (e) => {
                    const item = e.target.closest('.context-menu-item');
                    if (!item) return;

                    const dockPosition = item.dataset.dock;

                    if (dockPosition === 'top') {
                        this.redockGroup(group, 'top');
                    } else if (dockPosition === 'bottom') {
                        this.redockGroup(group, 'bottom');
                    }

                    menu.remove();
                });

                // Chiudi menu al click fuori
                setTimeout(() => {
                    document.addEventListener('click', () => menu.remove(), { once: true });
                }, 0);
            }

            addRedockButton(group) {
                // Rimuovi eventuali pulsanti esistenti
                const existingBtn = group.querySelector('.redock-btn');
                if (existingBtn) return;

                const redockBtn = document.createElement('button');
                redockBtn.className = 'redock-btn';
                redockBtn.innerHTML = 'üìå';
                redockBtn.title = 'Ancora toolbar (doppio click per scegliere posizione)';
                redockBtn.style.cssText = `
        position: absolute;
        top: -10px;
        right: -10px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #27ae60;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        z-index: 10001;
    `;

                redockBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.showDockMenu(group, e.clientX, e.clientY);
                });

                group.appendChild(redockBtn);
            }

            redockGroup(group, position = 'top') {
                let targetContainer;

                if (position === 'bottom') {
                    const bottomSidebar = document.getElementById('bottomSidebar');
                    targetContainer = bottomSidebar.querySelector('.bottom-toolbar-group');
                } else {
                    targetContainer = document.querySelector('.toolbar');
                }

                // Rimuovi stili floating
                group.classList.remove('floating');
                group.classList.add('docked');
                group.style.position = '';
                group.style.left = '';
                group.style.top = '';
                group.style.zIndex = '';

                // Rimuovi pulsante redock
                const redockBtn = group.querySelector('.redock-btn');
                if (redockBtn) redockBtn.remove();

                // Rimuovi dal body se necessario
                if (group.parentElement === document.body) {
                    group.remove();
                }

                // Aggiungi al container target
                if (position === 'bottom') {
                    targetContainer.appendChild(group);
                } else {
                    const addButton = targetContainer.querySelector('.add-tab');
                    if (addButton) {
                        targetContainer.insertBefore(group, addButton.parentElement);
                    } else {
                        targetContainer.appendChild(group);
                    }
                }

                // Rimuovi dal tracking dei floating
                if (group.id && this.floatingToolbarGroups.has(group.id)) {
                    this.floatingToolbarGroups.delete(group.id);
                }
            }

            getDragAfterElement(container, x) {
                const draggableElements = [...container.querySelectorAll('.toolbar-group:not(.dragging):not(.toolbar-placeholder)')];

                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - box.left - box.width / 2;

                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            initFloatingGroupsDocking() {
                document.addEventListener('dragover', (e) => {
                    this.floatingToolbarGroups.forEach((data, id) => {
                        const group = data.element;
                        if (!group.classList.contains('dragging')) return;

                        const toolbar = document.querySelector('.toolbar');
                        const toolbarRect = toolbar.getBoundingClientRect();

                        const isNearToolbar = (
                            Math.abs(e.clientY - toolbarRect.top) < 50 ||
                            Math.abs(e.clientY - toolbarRect.bottom) < 50
                        );

                        if (isNearToolbar) {
                            toolbar.style.background = '#d1e7fd'; // Evidenzia
                        } else {
                            toolbar.style.background = '';
                        }
                    });
                });
            }

            // Metodi per la gestione squadra
            loadTeamFromStorage() {
                try {
                    const saved = localStorage.getItem('volleyTeam');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.error('Errore nel caricamento della squadra:', error);
                    return [];
                }
            }
            saveTabState() {
                const tab = this.getCurrentTab();
                if (!tab) return;

                tab.background = document.getElementById('backgroundSelect').value;
                tab.gridVisible = document.getElementById('gridToggle').classList.contains('active');
                tab.bwMode = document.getElementById('bwToggle').classList.contains('active');
                tab.zoom = this.zoom;

                // SALVA DIMENSIONE E BORDI
                tab.canvasSize = this.canvasSize;
                tab.showBorder = this.showCanvasBorder;

                // ‚úÖ NUOVO: Salva dimensioni custom
                if (tab.canvasSize === 'custom') {
                    const canvas = document.getElementById('canvas');
                    tab.customWidth = canvas.offsetWidth;
                    tab.customHeight = canvas.offsetHeight;
                }

                tab.maxZIndex = this.maxZIndex;
                tab.floatingToolbars = [];
                this.floatingToolbarGroups.forEach((data, id) => {
                    tab.floatingToolbars.push({
                        id: id,
                        html: data.element.innerHTML,
                        x: data.x,
                        y: data.y
                    });
                });

                // In loadTabState() - aggiungi:
                if (tab.floatingToolbars) {
                    tab.floatingToolbars.forEach(data => {
                        const group = document.createElement('div');
                        group.innerHTML = data.html;
                        const element = group.firstElementChild;
                        element.classList.add('floating', 'toolbar-group');
                        element.style.position = 'fixed';
                        element.style.left = data.x + 'px';
                        element.style.top = data.y + 'px';
                        element.style.zIndex = '9999';
                        document.body.appendChild(element);

                        this.floatingToolbarGroups.set(data.id, {
                            element: element,
                            x: data.x,
                            y: data.y
                        });

                        this.addRedockButton(element);
                    });
                }
            }
            saveTeamToStorage() {
                try {
                    localStorage.setItem('volleyTeam', JSON.stringify(this.teamPlayers));
                } catch (error) {
                    console.error('Errore nel salvataggio della squadra:', error);
                }
            }

            showTeamDialog() {
                const dialog = document.getElementById('teamDialog');
                dialog.classList.add('active');
                this.renderTeamPlayersList();
            }

            hideTeamDialog() {
                document.getElementById('teamDialog').classList.remove('active');
            }

            addTeamPlayer() {
                const role = document.getElementById('newPlayerRole').value;
                const number = parseInt(document.getElementById('newPlayerNumber').value);
                const name = document.getElementById('newPlayerName').value.trim();

                if (!name || !number) {
                    alert('Inserisci numero e nome del giocatore');
                    return;
                }

                // Verifica duplicati
                const exists = this.teamPlayers.find(p =>
                    p.role === role || p.number === number
                );

                if (exists) {
                    if (!confirm('Ruolo o numero gi√† assegnato. Sostituire?')) return;
                    this.teamPlayers = this.teamPlayers.filter(p =>
                        p.role !== role && p.number !== number
                    );
                }

                this.teamPlayers.push({ role, number, name });
                this.teamPlayers.sort((a, b) => a.number - b.number);

                this.saveTeamToStorage();
                this.renderTeamPlayersList();

                // Reset form
                document.getElementById('newPlayerNumber').value = '';
                document.getElementById('newPlayerName').value = '';
            }

            renderTeamPlayersList() {
                const container = document.getElementById('teamPlayersList');
                container.innerHTML = '';

                if (this.teamPlayers.length === 0) {
                    container.innerHTML = '<p style="text-align: center; padding: 20px; color: #999;">Nessun giocatore inserito</p>';
                    return;
                }

                this.teamPlayers.forEach((player, index) => {
                    const item = document.createElement('div');
                    item.className = 'team-player-item';

                    const roleDiv = document.createElement('div');
                    roleDiv.className = 'team-player-role';
                    roleDiv.textContent = player.role;

                    const numberDiv = document.createElement('div');
                    numberDiv.className = 'team-player-number';
                    numberDiv.textContent = `#${player.number}`;

                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'team-player-name';
                    nameDiv.textContent = player.name;

                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'team-player-actions';

                    const editBtn = document.createElement('button');
                    editBtn.className = 'btn-edit';
                    editBtn.innerHTML = '‚úèÔ∏è';
                    editBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.editTeamPlayer(index);
                    });

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'btn-delete';
                    deleteBtn.innerHTML = 'üóëÔ∏è';
                    deleteBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.deleteTeamPlayer(index);
                    });

                    actionsDiv.appendChild(editBtn);
                    actionsDiv.appendChild(deleteBtn);

                    item.appendChild(roleDiv);
                    item.appendChild(numberDiv);
                    item.appendChild(nameDiv);
                    item.appendChild(actionsDiv);

                    container.appendChild(item);
                });
            }

            editTeamPlayer(index) {
                const player = this.teamPlayers[index];
                document.getElementById('newPlayerRole').value = player.role;
                document.getElementById('newPlayerNumber').value = player.number;
                document.getElementById('newPlayerName').value = player.name;
                this.deleteTeamPlayer(index);
            }

            deleteTeamPlayer(index) {
                if (!confirm('Eliminare questo giocatore?')) return;
                this.teamPlayers.splice(index, 1);
                this.saveTeamToStorage();
                this.renderTeamPlayersList();
            }

            exportTeam() {
                const data = {
                    version: '1.0',
                    date: new Date().toISOString(),
                    team: this.teamPlayers
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `squadra_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            importTeam(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.team && Array.isArray(data.team)) {
                            this.teamPlayers = data.team;
                            this.saveTeamToStorage();
                            this.renderTeamPlayersList();
                            alert('Squadra importata con successo!');
                        } else {
                            alert('File non valido');
                        }
                    } catch (error) {
                        alert('Errore nel caricamento del file');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            clearTeam() {
                if (!confirm('Eliminare tutti i giocatori della squadra?')) return;
                this.teamPlayers = [];
                this.saveTeamToStorage();
                this.renderTeamPlayersList();
            }

            togglePlayerNames() {
                this.showPlayerNames = !this.showPlayerNames;
                document.body.classList.toggle('show-all-player-names', this.showPlayerNames);
                document.getElementById('togglePlayerNames').classList.toggle('active', this.showPlayerNames);
            }

            getPlayerByRole(role) {
                return this.teamPlayers.find(p => p.role === role);
            }

            renumberAllObjects() {
                if (!confirm('Rinumerare tutti gli oggetti in sequenza (da sinistra a destra, dall\'alto in basso)?')) {
                    return;
                }

                const tab = this.getCurrentTab();

                // Ordina gli oggetti per posizione (prima per Y, poi per X)
                const sortedObjects = Array.from(tab.objects.values()).sort((a, b) => {
                    if (Math.abs(a.y - b.y) < 30) { // Stessa "riga" (tolleranza 30px)
                        return a.x - b.x;
                    }
                    return a.y - b.y;
                });

                // Riassegna i numeri in sequenza
                sortedObjects.forEach((obj, index) => {
                    obj.objectNumber = index + 1;
                    this.renderObject(obj);
                });

                this.saveState(`Rinumerati ${sortedObjects.length} oggetti`);
                alert(`‚úÖ ${sortedObjects.length} oggetti rinumerati`);
            }
            changeSelectedObjectsNumber(newNumber) {
                if (this.selectedObjects.size === 0 || isNaN(newNumber) || newNumber < 1) return;

                const tab = this.getCurrentTab();
                // Applica il nuovo numero agli oggetti selezionati
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (!objectData) return;

                    objectData.objectNumber = newNumber;
                    this.renderObject(objectData);
                });

                this.saveState(`Modificato numero di ${this.selectedObjects.size} oggetti`);
                this.updateCurrentFrame();
            }
            addObjectLabel(element, object) {
                // Rimuovi etichetta esistente se presente
                const existingLabel = element.querySelector('.object-label');
                if (existingLabel) {
                    existingLabel.remove();
                }

                // Crea nuova etichetta
                const label = document.createElement('div');
                label.className = 'object-label';
                label.textContent = object.objectNumber || '?';
                label.style.cursor = 'pointer';
                label.title = 'Doppio click per modificare';

                label.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    this.editObjectNumberInline(element, object);
                });

                element.appendChild(label);

                // Mostra se la modalit√† √® attiva
                const canvas = document.getElementById('canvas');
                if (canvas.classList.contains('show-all-labels')) {
                    element.classList.add('show-labels');
                }
            }

            editObjectNumberInline(element, object) {
                const label = element.querySelector('.object-label');
                if (!label) return;

                const currentNumber = object.objectNumber;
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '1';
                input.value = currentNumber;
                input.style.width = '30px';
                input.style.height = '20px';
                input.style.fontSize = '10px';
                input.style.textAlign = 'center';
                input.style.border = '1px solid #3498db';
                input.style.borderRadius = '50%';
                input.style.padding = '0';

                label.replaceWith(input);
                input.focus();
                input.select();

                const finishEdit = () => {
                    const newNumber = parseInt(input.value);

                    if (!isNaN(newNumber) && newNumber > 0) {
                        object.objectNumber = newNumber;
                    }

                    this.renderObject(object);
                    this.saveState(`Modificato numero oggetto ${object.id}`);

                    if (this.selectedObjects.has(object.id)) {
                        document.getElementById('objectNumber').value = object.objectNumber;
                    }
                };

                input.addEventListener('blur', finishEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        finishEdit();
                    } else if (e.key === 'Escape') {
                        object.objectNumber = currentNumber;
                        this.renderObject(object);
                    }
                });
            }

            toggleObjectLabels() {
                const canvas = document.getElementById('canvas');
                const isVisible = canvas.classList.toggle('show-all-labels');

                document.getElementById('toggleLabels').classList.toggle('active', isVisible);

                // Forza aggiornamento visibilit√†
                document.querySelectorAll('.canvas-object').forEach(obj => {
                    if (isVisible) {
                        obj.classList.add('show-labels');
                    } else {
                        obj.classList.remove('show-labels');
                    }
                });
            }
            generateBasicSteps() {
                const tab = this.getCurrentTab();
                const steps = [];

                tab.objects.forEach((obj, id) => {
                    if (obj.text) {
                        steps.push(`${obj.objectNumber}. ${obj.text} (${obj.type})`);
                    }
                });

                tab.arrows.forEach((arrow, id) => {
                    const fromObj = arrow.from.objectId ? tab.objects.get(arrow.from.objectId) : null;
                    const toObj = arrow.to.objectId ? tab.objects.get(arrow.to.objectId) : null;

                    if (fromObj && toObj) {
                        steps.push(`Movimento da ${fromObj.objectNumber} a ${toObj.objectNumber}`);
                    }
                });

                tab.exerciseSteps = steps;
                this.renderStepsList();
            }
            async generateAISteps() {
                const tab = this.getCurrentTab();

                if (tab.objects.size === 0) {
                    alert('Nessun oggetto presente nello schema');
                    return;
                }

                // Costruisci prompt per AI
                const objectsList = [];
                tab.objects.forEach((obj, id) => {
                    objectsList.push({
                        numero: obj.objectNumber,
                        tipo: obj.type,
                        testo: obj.text || '',
                        posizione: { x: Math.round(obj.x), y: Math.round(obj.y) }
                    });
                });

                const arrowsList = [];
                tab.arrows.forEach((arrow, id) => {
                    const fromObj = arrow.from.objectId ? tab.objects.get(arrow.from.objectId) : null;
                    const toObj = arrow.to.objectId ? tab.objects.get(arrow.to.objectId) : null;

                    arrowsList.push({
                        da: fromObj ? fromObj.objectNumber : 'punto libero',
                        a: toObj ? toObj.objectNumber : 'punto libero',
                        tipo: arrow.type
                    });
                });

                const prompt = `Analizza questo schema di allenamento di pallavolo e genera una sequenza di step/istruzioni chiare per l'esecuzione dell'esercizio.

OGGETTI PRESENTI:
${JSON.stringify(objectsList, null, 2)}

FRECCE/MOVIMENTI:
${JSON.stringify(arrowsList, null, 2)}

DESCRIZIONE ALLENAMENTO:
${tab.descrizione || 'Nessuna descrizione'}

RUOLO TARGET: ${tab.ruolo || 'Generico'}
TIPOLOGIA: ${tab.tipologia || 'Generico'}

Genera una lista di step numerati (massimo 8-10 step) che descrivano l'esecuzione dell'esercizio. Usa i numeri degli oggetti (es: "Giocatore 1 passa a Giocatore 2") per rendere le istruzioni chiare. 
Rispondi SOLO con gli step in formato JSON array di stringhe, esempio:
["Step 1: ...", "Step 2: ...", ...]`;

                try {
                    const button = document.getElementById('generateAISteps');
                    button.disabled = true;
                    button.textContent = '‚è≥ Generazione in corso...';

                    // Chiamata API Claude (usa la tua implementazione)
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': 'YOUR_API_KEY_HERE', // ‚ö†Ô∏è INSERISCI LA TUA API KEY
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({
                            model: 'claude-3-5-sonnet-20241022',
                            max_tokens: 1024,
                            messages: [{
                                role: 'user',
                                content: prompt
                            }]
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Errore nella chiamata API: ' + response.statusText);
                    }

                    const data = await response.json();
                    const aiResponse = data.content[0].text;

                    // Estrai JSON dalla risposta
                    const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
                    if (!jsonMatch) {
                        throw new Error('Formato risposta non valido');
                    }

                    const steps = JSON.parse(jsonMatch[0]);

                    // Sostituisci gli step esistenti
                    tab.exerciseSteps = steps;
                    this.renderStepsList();
                    this.saveState('Generati step con AI');

                    alert('‚úÖ Step generati con successo!');

                } catch (error) {
                    console.error('Errore generazione AI:', error);
                    alert('‚ùå Errore nella generazione degli step: ' + error.message);
                } finally {
                    const button = document.getElementById('generateAISteps');
                    button.disabled = false;
                    button.textContent = '‚ú® Genera Step con AI';
                }
            }

            initExerciseSteps() {
                const tab = this.getCurrentTab();
                if (!tab.exerciseSteps) {
                    tab.exerciseSteps = [];
                }
            }

            renderStepsList() {
                const tab = this.getCurrentTab();
                const container = document.getElementById('stepsList');

                if (!container) return;

                container.innerHTML = '';

                if (tab.exerciseSteps.length === 0) {
                    container.innerHTML = '<p style="text-align: center; padding: 20px; color: #999;">Nessuno step inserito</p>';
                    return;
                }

                tab.exerciseSteps.forEach((step, index) => {
                    const stepItem = document.createElement('div');
                    stepItem.className = 'step-item';
                    stepItem.draggable = true;
                    stepItem.dataset.index = index;

                    const stepNumber = document.createElement('div');
                    stepNumber.className = 'step-number';
                    stepNumber.textContent = index + 1;

                    const stepText = document.createElement('div');
                    stepText.className = 'step-text';
                    stepText.textContent = step;

                    const stepActions = document.createElement('div');
                    stepActions.className = 'step-actions';

                    // Bottone su
                    const btnUp = document.createElement('button');
                    btnUp.className = 'step-btn step-btn-up';
                    btnUp.innerHTML = '‚Üë';
                    btnUp.title = 'Sposta su';
                    btnUp.disabled = index === 0;
                    btnUp.addEventListener('click', () => this.moveStep(index, -1));

                    // Bottone gi√π
                    const btnDown = document.createElement('button');
                    btnDown.className = 'step-btn step-btn-down';
                    btnDown.innerHTML = '‚Üì';
                    btnDown.title = 'Sposta gi√π';
                    btnDown.disabled = index === tab.exerciseSteps.length - 1;
                    btnDown.addEventListener('click', () => this.moveStep(index, 1));

                    // Bottone modifica
                    const btnEdit = document.createElement('button');
                    btnEdit.className = 'step-btn step-btn-edit';
                    btnEdit.innerHTML = '‚úèÔ∏è';
                    btnEdit.title = 'Modifica';
                    btnEdit.addEventListener('click', () => this.editStep(index));

                    // Bottone elimina
                    const btnDelete = document.createElement('button');
                    btnDelete.className = 'step-btn step-btn-delete';
                    btnDelete.innerHTML = 'üóëÔ∏è';
                    btnDelete.title = 'Elimina';
                    btnDelete.addEventListener('click', () => this.deleteStep(index));

                    stepActions.appendChild(btnUp);
                    stepActions.appendChild(btnDown);
                    stepActions.appendChild(btnEdit);
                    stepActions.appendChild(btnDelete);

                    stepItem.appendChild(stepNumber);
                    stepItem.appendChild(stepText);
                    stepItem.appendChild(stepActions);

                    // Drag & Drop events
                    stepItem.addEventListener('dragstart', (e) => {
                        this.draggedStepIndex = index;
                        stepItem.classList.add('dragging');
                    });

                    stepItem.addEventListener('dragend', (e) => {
                        stepItem.classList.remove('dragging');
                        this.draggedStepIndex = null;
                    });

                    stepItem.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (this.draggedStepIndex !== null && this.draggedStepIndex !== index) {
                            stepItem.style.borderTop = '2px solid #3498db';
                        }
                    });

                    stepItem.addEventListener('dragleave', (e) => {
                        stepItem.style.borderTop = '';
                    });

                    stepItem.addEventListener('drop', (e) => {
                        e.preventDefault();
                        stepItem.style.borderTop = '';

                        if (this.draggedStepIndex !== null && this.draggedStepIndex !== index) {
                            this.reorderSteps(this.draggedStepIndex, index);
                        }
                    });

                    container.appendChild(stepItem);
                });
            }

            addStep() {
                const input = document.getElementById('newStepInput');
                const stepText = input.value.trim();

                if (!stepText) {
                    alert('Inserisci il testo dello step');
                    return;
                }

                const tab = this.getCurrentTab();
                tab.exerciseSteps.push(stepText);
                input.value = '';

                this.renderStepsList();
                this.saveState(`Aggiunto step: ${stepText}`);
            }

            moveStep(index, direction) {
                const tab = this.getCurrentTab();
                const newIndex = index + direction;

                if (newIndex < 0 || newIndex >= tab.exerciseSteps.length) return;

                const temp = tab.exerciseSteps[index];
                tab.exerciseSteps[index] = tab.exerciseSteps[newIndex];
                tab.exerciseSteps[newIndex] = temp;

                this.renderStepsList();
                this.saveState(`Spostato step da ${index} a ${newIndex}`);
            }

            reorderSteps(fromIndex, toIndex) {
                const tab = this.getCurrentTab();
                const [movedStep] = tab.exerciseSteps.splice(fromIndex, 1);
                tab.exerciseSteps.splice(toIndex, 0, movedStep);

                this.renderStepsList();
                this.saveState(`Riorganizzato step da ${fromIndex} a ${toIndex}`);
            }

            editStep(index) {
                const tab = this.getCurrentTab();
                const currentText = tab.exerciseSteps[index];
                const newText = prompt('Modifica step:', currentText);

                if (newText !== null && newText.trim() !== '') {
                    tab.exerciseSteps[index] = newText.trim();
                    this.renderStepsList();
                    this.saveState(`Modificato step ${index}: ${newText.trim()}`);
                }
            }

            deleteStep(index) {
                if (!confirm('Eliminare questo step?')) return;

                const tab = this.getCurrentTab();
                tab.exerciseSteps.splice(index, 1);

                this.renderStepsList();
                this.saveState(`Eliminato step ${index}`);
            }

            addArrowEndpointControl(svg, arrow, type, position) {
                const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                point.setAttribute('cx', position.x);
                point.setAttribute('cy', position.y);
                point.setAttribute('r', '8');
                point.setAttribute('fill', type === 'start' ? '#3498db' : '#e74c3c');
                point.setAttribute('stroke', '#fff');
                point.setAttribute('stroke-width', '2');
                point.style.cursor = 'move';
                point.classList.add('endpoint-control');
                point.dataset.endpointType = type;

                // Nascondi di default, mostra solo quando la freccia √® selezionata
                point.style.opacity = '0';
                point.style.transition = 'opacity 0.2s';

                point.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.isDraggingEndpoint = true;
                    this.draggedEndpointType = type;
                    this.selectedArrow = arrow.id;
                    this.selectArrow(arrow.id);

                    // Aggiungi classe al body per mostrare tutti i connection points
                    document.body.classList.add('dragging-endpoint');
                });

                return point;
            }
            // Aggiungi questo metodo nella classe SchemaEditor
            initAnimationDialog() {
                const dialog = document.getElementById('animationDialog');
                const header = document.getElementById('animationDialogHeader');
                const closeBtn = document.getElementById('closeAnimationDialog');

                let isDragging = false;
                let currentX = 0;
                let currentY = 0;
                let initialX = 0;
                let initialY = 0;

                header.addEventListener('mousedown', (e) => {
                    // Calcola offset iniziale
                    const rect = dialog.getBoundingClientRect();
                    initialX = e.clientX - rect.left;
                    initialY = e.clientY - rect.top;

                    isDragging = true;
                    header.style.cursor = 'grabbing';

                    // Rimuovi il transform per usare coordinate assolute
                    dialog.style.transform = 'none';
                    dialog.style.left = rect.left + 'px';
                    dialog.style.top = rect.top + 'px';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    e.preventDefault();

                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    dialog.style.left = currentX + 'px';
                    dialog.style.top = currentY + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        header.style.cursor = 'move';
                    }
                });

                closeBtn.addEventListener('click', () => {
                    dialog.classList.remove('active');
                    dialog.style.display = '';
                });
            }

            showAnimationControls() {
                const dialog = document.getElementById('animationDialog');

                if (dialog.classList.contains('active')) {
                    dialog.classList.remove('active');
                } else {
                    dialog.classList.add('active');

                    // Centra solo al primo caricamento
                    if (!dialog.style.left) {
                        this.centerAnimationDialog();
                    }

                    this.initAnimationSystem();
                    this.renderFramesList();
                }

                // Nascondi gli altri pannelli
                document.getElementById('objectControls').style.display = 'none';
                document.getElementById('arrowControls').style.display = 'none';
                document.getElementById('spriteControls').style.display = 'none';
                document.getElementById('freehandControls').style.display = 'none';
            }

            createKeyframe(objectId, frameNumber, properties) {
                return {
                    frame: frameNumber,
                    objectId: objectId,
                    properties: {
                        x: properties.x,
                        y: properties.y,
                        rotation: properties.rotation,
                        color: properties.color,
                        opacity: properties.opacity,
                        width: properties.width,
                        height: properties.height,
                        dashed: properties.dashed,
                        text: properties.text
                    },
                    easing: properties.easing || 'linear' // linear, ease-in, ease-out, ease-in-out
                };
            }
            // ==================== SISTEMA ANIMAZIONE ====================

            initAnimationSystem() {
                const tab = this.getCurrentTab();
                if (!tab.frames) {
                    tab.frames = [];
                    tab.currentFrameIndex = 0;
                }
            }

            addFrame() {
                if (this.selectedObjects.size === 0) {
                    alert('Seleziona almeno un oggetto per creare un frame');
                    return;
                }

                const tab = this.getCurrentTab();

                // Calcola il timestamp di default: ultimo frame + 1 secondo
                let defaultTimestamp = 0;
                if (tab.frames.length > 0) {
                    const maxTime = Math.max(...tab.frames.map(f => f.timestamp));
                    defaultTimestamp = maxTime + 1000;
                }

                const frameData = {
                    id: `frame-${Date.now()}`,
                    timestamp: defaultTimestamp,
                    objects: new Map()
                };

                // Salva lo stato corrente di tutti gli oggetti selezionati
                this.selectedObjects.forEach((pos, objId) => {
                    const obj = tab.objects.get(objId);
                    if (!obj) return;

                    frameData.objects.set(objId, {
                        x: obj.x,
                        y: obj.y,
                        width: obj.width,
                        height: obj.height,
                        rotation: obj.rotation,
                        color: obj.color,
                        opacity: obj.opacity,
                        dashed: obj.dashed,
                        text: obj.text
                    });
                });

                tab.frames.push(frameData);

                // Ordina i frame per timestamp
                tab.frames.sort((a, b) => a.timestamp - b.timestamp);

                // Trova l'indice del frame appena inserito
                tab.currentFrameIndex = tab.frames.findIndex(f => f.id === frameData.id);

                this.renderFramesList();
                this.selectFrame(tab.currentFrameIndex);
                this.saveState(`Creato frame ${frameData.id} con ${frameData.objects.size} oggetti`);

                console.log(`Frame ${frameNumber} creato con ${frameData.objects.size} oggetti`);
            }

            selectFrame(frameIndex) {
                const tab = this.getCurrentTab();
                if (frameIndex < 0 || frameIndex >= tab.frames.length) return;

                tab.currentFrameIndex = frameIndex;
                const frame = tab.frames[frameIndex];

                // Aggiorna la UI
                document.querySelectorAll('.frame-item').forEach((item, idx) => {
                    item.classList.toggle('active', idx === frameIndex);
                });

                document.getElementById('currentFrameDisplay').textContent = `Frame: ${frameIndex}`;

                // Mostra propriet√† del frame
                this.showFrameProperties(frame);
            }

            showFrameProperties(frame) {
                const propertiesDiv = document.getElementById('frameProperties');
                propertiesDiv.style.display = 'block';

                const tab = this.getCurrentTab();
                document.getElementById('frameNumber').textContent = `${tab.frames.indexOf(frame)}`;
                document.getElementById('frameTimestamp').value = frame.timestamp;

                // Prendi il primo oggetto per mostrare le propriet√† (se ce ne sono pi√π di uno, mostreremo quelle del primo)
                if (frame.objects.size > 0) {
                    const firstObjData = frame.objects.values().next().value;

                    document.getElementById('frameX').value = Math.round(firstObjData.x);
                    document.getElementById('frameY').value = Math.round(firstObjData.y);
                    document.getElementById('frameWidth').value = Math.round(firstObjData.width);
                    document.getElementById('frameHeight').value = Math.round(firstObjData.height);
                    document.getElementById('frameRotation').value = firstObjData.rotation;
                    document.getElementById('frameOpacity').value = firstObjData.opacity;
                    document.getElementById('frameColor').value = firstObjData.color;
                    document.getElementById('frameDashed').checked = firstObjData.dashed;
                }
            }

            updateFrame() {
                const tab = this.getCurrentTab();
                if (tab.currentFrameIndex < 0) return;

                const frame = tab.frames[tab.currentFrameIndex];
                if (!frame) return;
                // Aggiorna il timestamp
                const newTimestamp = parseInt(document.getElementById('frameTimestamp').value);
                if (!isNaN(newTimestamp) && newTimestamp >= 0) {
                    frame.timestamp = newTimestamp;
                }
                // Aggiorna le propriet√† dal form
                const updates = {
                    x: parseFloat(document.getElementById('frameX').value),
                    y: parseFloat(document.getElementById('frameY').value),
                    width: parseFloat(document.getElementById('frameWidth').value),
                    height: parseFloat(document.getElementById('frameHeight').value),
                    rotation: parseFloat(document.getElementById('frameRotation').value),
                    opacity: parseFloat(document.getElementById('frameOpacity').value),
                    color: document.getElementById('frameColor').value,
                    dashed: document.getElementById('frameDashed').checked
                };

                // Applica le modifiche a tutti gli oggetti del frame
                frame.objects.forEach((objData, objId) => {
                    Object.assign(objData, updates);

                    // Aggiorna anche l'oggetto reale
                    const obj = tab.objects.get(objId);
                    if (obj) {
                        Object.assign(obj, updates);
                        this.renderObject(obj);
                        this.updateArrowsForObject(objId);
                    }
                });
                // Riordina i frame dopo la modifica del timestamp
                tab.frames.sort((a, b) => a.timestamp - b.timestamp);
                tab.currentFrameIndex = tab.frames.findIndex(f => f.id === frame.id);
                this.saveState(`Aggiornato frame ${frame.number}`);
                alert(`Frame ${frame.number} aggiornato`);
            }

            deleteFrame() {
                const tab = this.getCurrentTab();
                if (tab.currentFrameIndex < 0) return;

                const frame = tab.frames[tab.currentFrameIndex];
                if (!confirm(`Eliminare il frame al timestamp ${frame.timestamp}ms?`)) return;

                tab.frames.splice(tab.currentFrameIndex, 1);

                tab.currentFrameIndex = Math.max(0, tab.currentFrameIndex - 1);

                this.renderFramesList();

                if (tab.frames.length > 0) {
                    this.selectFrame(tab.currentFrameIndex);
                } else {
                    document.getElementById('frameProperties').style.display = 'none';
                }

                this.saveState(`Eliminato frame ${frame.number}`);
            }

            renderFramesList() {
                const tab = this.getCurrentTab();
                const container = document.getElementById('framesList');
                container.innerHTML = '';

                if (tab.frames.length === 0) {
                    container.innerHTML = '<p style="color: #999; margin: auto;">Nessun frame. Clicca "+ Nuovo Frame" per iniziare.</p>';
                    return;
                }

                tab.frames.forEach((frame, index) => {
                    const frameItem = document.createElement('div');
                    frameItem.className = 'frame-item';
                    frameItem.draggable = true;
                    frameItem.dataset.frameIndex = index;

                    if (index === tab.currentFrameIndex) {
                        frameItem.classList.add('active');
                    }

                    // Crea thumbnail
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'frame-thumbnail';
                    thumbnail.textContent = 'üì∏';

                    const label = document.createElement('div');
                    label.style.fontSize = '11px';
                    label.style.fontWeight = 'bold';
                    label.textContent = `Frame ${index}`;

                    const timeLabel = document.createElement('div');
                    timeLabel.style.fontSize = '9px';
                    timeLabel.style.color = '#3498db';
                    timeLabel.textContent = `${(frame.timestamp / 1000).toFixed(1)}s`;

                    const objectCount = document.createElement('div');
                    objectCount.style.fontSize = '10px';
                    objectCount.style.opacity = '0.7';
                    objectCount.textContent = `${frame.objects.size} obj`;

                    frameItem.appendChild(thumbnail);
                    frameItem.appendChild(label);
                    frameItem.appendChild(timeLabel);
                    frameItem.appendChild(objectCount);

                    // Click per selezionare
                    frameItem.addEventListener('click', () => {
                        this.selectFrame(index);
                        this.applyFrame(index);
                    });

                    frameItem.addEventListener('dragstart', (e) => {
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', index.toString());
                        frameItem.classList.add('dragging');
                        this.draggedFrameIndex = index;
                    });

                    frameItem.addEventListener('dragend', (e) => {
                        frameItem.classList.remove('dragging');
                        this.draggedFrameIndex = null;
                    });

                    frameItem.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';

                        // Indicatore visivo
                        if (this.draggedFrameIndex !== null && this.draggedFrameIndex !== index) {
                            frameItem.style.borderLeft = '3px solid #3498db';
                        }
                    });

                    frameItem.addEventListener('dragleave', (e) => {
                        frameItem.style.borderLeft = '';
                    });

                    frameItem.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        frameItem.style.borderLeft = '';

                        const fromIndex = this.draggedFrameIndex;
                        const toIndex = index;

                        if (fromIndex !== null && fromIndex !== toIndex) {
                            this.reorderFrames(fromIndex, toIndex);
                        }
                    });

                    container.appendChild(frameItem);
                });
            }
            updateCurrentFrame() {
                const tab = this.getCurrentTab();
                if (!tab.frames || tab.frames.length === 0) return;
                if (tab.currentFrameIndex < 0 || tab.currentFrameIndex >= tab.frames.length) return;

                const frame = tab.frames[tab.currentFrameIndex];

                // Aggiorna solo gli oggetti che sono gi√† nel frame
                frame.objects.forEach((objData, objId) => {
                    const obj = tab.objects.get(objId);
                    if (obj) {
                        objData.x = obj.x;
                        objData.y = obj.y;
                        objData.width = obj.width;
                        objData.height = obj.height;
                        objData.rotation = obj.rotation;
                        objData.color = obj.color;
                        objData.opacity = obj.opacity;
                        objData.dashed = obj.dashed;
                        objData.text = obj.text;
                    }
                });

                // Aggiorna anche la UI delle propriet√† se il pannello √® visibile
                if (document.getElementById('frameProperties').style.display !== 'none') {
                    this.showFrameProperties(frame);
                }
            }

            reorderFrames(fromIndex, toIndex) {
                const tab = this.getCurrentTab();
                const [movedFrame] = tab.frames.splice(fromIndex, 1);
                tab.frames.splice(toIndex, 0, movedFrame);

                // Rinumera
                tab.frames.forEach((frame, idx) => {
                    frame.number = idx;
                });

                // Aggiorna currentFrameIndex se necessario
                if (tab.currentFrameIndex === fromIndex) {
                    tab.currentFrameIndex = toIndex;
                } else if (fromIndex < tab.currentFrameIndex && toIndex >= tab.currentFrameIndex) {
                    tab.currentFrameIndex--;
                } else if (fromIndex > tab.currentFrameIndex && toIndex <= tab.currentFrameIndex) {
                    tab.currentFrameIndex++;
                }

                this.renderFramesList();
                this.saveState(`Riorganizzato frame da ${fromIndex} a ${toIndex}`);
            }

            applyFrame(frameIndex) {
                const tab = this.getCurrentTab();
                const frame = tab.frames[frameIndex];
                if (!frame) {
                    console.warn(`Frame ${frameIndex} non trovato`);
                    return;
                }

                console.log(`Applicando frame ${frameIndex} con ${frame.objects.size} oggetti al timestamp ${frame.timestamp}ms`);

                // Applica le propriet√† del frame agli oggetti
                frame.objects.forEach((objData, objId) => {
                    const obj = tab.objects.get(objId);
                    if (obj) {
                        // Copia tutte le propriet√†
                        obj.x = objData.x;
                        obj.y = objData.y;
                        obj.width = objData.width;
                        obj.height = objData.height;
                        obj.rotation = objData.rotation;
                        obj.color = objData.color;
                        obj.opacity = objData.opacity;
                        obj.dashed = objData.dashed;
                        obj.text = objData.text;

                        // Aggiorna la visualizzazione
                        this.renderObject(obj);
                        this.updateArrowsForObject(objId);
                    } else {
                        console.warn(`Oggetto ${objId} non trovato nel tab`);
                    }
                });
            }

            playAnimation() {
                const tab = this.getCurrentTab();
                if (tab.frames.length === 0) {
                    alert('Nessun frame da animare');
                    return;
                }

                if (tab.isPlaying) return;

                tab.isPlaying = true;
                tab.currentFrameIndex = 0;
                tab.animationStartTime = Date.now();

                document.getElementById('animationPlay').style.display = 'none';
                document.getElementById('animationPause').style.display = 'inline-block';

                const animate = () => {
                    if (!tab.isPlaying) return;

                    const elapsed = Date.now() - tab.animationStartTime;

                    // Applica TUTTI i frame che hanno timestamp <= elapsed
                    for (let i = 0; i < tab.frames.length; i++) {
                        const frame = tab.frames[i];

                        // Se il frame ha un timestamp <= tempo trascorso e non √® ancora stato applicato in questo ciclo
                        if (elapsed >= frame.timestamp) {
                            // Verifica se questo frame √® "nuovo" rispetto all'ultimo frame applicato
                            if (i > tab.currentFrameIndex ||
                                (tab.currentFrameIndex === tab.frames.length - 1 && i === 0)) {

                                this.applyFrame(i);
                                this.selectFrame(i);
                                tab.currentFrameIndex = i;

                                console.log(`Applicato frame ${i} al tempo ${elapsed}ms (timestamp: ${frame.timestamp}ms)`);
                            }
                        }
                    }

                    // Calcola la durata totale dell'animazione
                    const totalDuration = tab.frames[tab.frames.length - 1].timestamp + 1000;

                    // Se siamo arrivati alla fine, ricomincia
                    if (elapsed >= totalDuration) {
                        tab.animationStartTime = Date.now();
                        tab.currentFrameIndex = -1; // Reset per permettere di riapplicare il primo frame
                        console.log('Loop animazione - ricomincia');
                    }

                    requestAnimationFrame(animate);
                };

                animate();
            }

            pauseAnimation() {
                const tab = this.getCurrentTab();
                tab.isPlaying = false;
                document.getElementById('animationPlay').style.display = 'inline-block';
                document.getElementById('animationPause').style.display = 'none';
            }

            stopAnimation() {
                this.pauseAnimation();
                const tab = this.getCurrentTab();
                tab.currentFrameIndex = 0;
                if (tab.frames.length > 0) {
                    this.applyFrame(0);
                    this.selectFrame(0);
                }
            }

            previousFrame() {
                const tab = this.getCurrentTab();
                if (tab.frames.length === 0) return;

                tab.currentFrameIndex = Math.max(0, tab.currentFrameIndex - 1);
                this.applyFrame(tab.currentFrameIndex);
                this.selectFrame(tab.currentFrameIndex);
            }

            nextFrame() {
                const tab = this.getCurrentTab();
                if (tab.frames.length === 0) return;

                tab.currentFrameIndex = Math.min(tab.frames.length - 1, tab.currentFrameIndex + 1);
                this.applyFrame(tab.currentFrameIndex);
                this.selectFrame(tab.currentFrameIndex);
            }

            showAnimationControls() {
                document.getElementById('animationDialog').style.display = 'block';
                document.getElementById('objectControls').style.display = 'none';
                document.getElementById('arrowControls').style.display = 'none';
                document.getElementById('spriteControls').style.display = 'none';
                document.getElementById('freehandControls').style.display = 'none';

                this.initAnimationSystem();
                this.renderFramesList();
            }

            initializeTab(id, name) {
                this.tabs.set(id, {
                    name: name,
                    objects: new Map(),
                    arrows: new Map(),
                    nextObjectId: 1,
                    nextArrowId: 1,
                    history: [],
                    historyIndex: -1,
                    background: 'none',
                    gridVisible: true,
                    bwMode: false,
                    zoom: 1,
                    periodo: 'GEN',
                    ruolo: 'GEN',
                    tipologia: 'GEN',
                    genere: 'GEN',
                    categoria: 'GEN',
                    descrizione: '',
                    autore: this.currentUser || 'unknown',
                    place: "",
                    groups: 1,
                    nr: 1,
                    date: new Date(),
                    series: 1,
                    timing: 10,
                    rec: 60,
                    freehands: new Map(),
                    nextFreehandId: 1,
                    animations: new Map(),
                    nextAnimationId: 1,
                    isPlaying: false,
                    currentFrame: 0,
                    animationSpeed: 1000,
                    frames: [],
                    currentFrameIndex: 0,
                    exerciseSteps: [],
                    connectionPointCounters: new Map(),
                    canvasSize: 'custom',
                    showBorder: false,
                    maxZIndex: 1000
                });
            }
            setCanvasSize(size) {
                const tab = this.getCurrentTab();
                tab.canvasSize = size;
                this.canvasSize = size;

                const canvas = document.getElementById('canvas');

                // Rimuovi tutte le classi di dimensione
                canvas.classList.remove(
                    'size-a4-portrait',
                    'size-a4-landscape',
                    'size-a3-portrait',
                    'size-a3-landscape',
                    'size-a2-portrait',
                    'size-a2-landscape',
                    'size-a5-portrait',
                    'size-a5-landscape',
                    'size-business-card'
                );

                if (size === 'custom') {
                    // Ripristina dimensioni custom se salvate
                    if (tab.customWidth && tab.customHeight) {
                        canvas.style.width = tab.customWidth + 'px';
                        canvas.style.height = tab.customHeight + 'px';
                    } else {
                        canvas.style.width = '';
                        canvas.style.height = '';
                    }
                } else {
                    // Applica la classe preset
                    canvas.classList.add(`size-${size}`);
                    // Resetta gli stili inline per permettere al CSS di applicarsi
                    canvas.style.width = '';
                    canvas.style.height = '';
                }

                this.saveState(`Impostata dimensione canvas: ${size}`);
            }
            initCanvasResize() {
                const canvas = document.getElementById('canvas');
                const container = canvas.parentElement;

                // Crea UN SOLO handle nell'angolo in basso a destra
                let handle = document.getElementById('canvasResizeHandle');
                if (!handle) {
                    handle = document.createElement('div');
                    handle.id = 'canvasResizeHandle';
                    handle.className = 'canvas-resize-handle-single';
                    handle.innerHTML = '‚á≤';
                    container.appendChild(handle);
                }

                let isResizing = false;
                let startX, startY, startWidth, startHeight;

                // Funzione per posizionare l'handle
                const updateHandlePosition = () => {
                    const rect = canvas.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    handle.style.left = (rect.right - containerRect.left - 10) + 'px';
                    handle.style.top = (rect.bottom - containerRect.top - 10) + 'px';
                };

                // Posiziona inizialmente
                updateHandlePosition();

                // MouseDown sull'handle
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // Passa a modalit√† custom quando inizi il resize
                    const currentSize = document.getElementById('canvasSizeSelect').value;
                    if (currentSize !== 'custom') {
                        document.getElementById('canvasSizeSelect').value = 'custom';
                        this.setCanvasSize('custom');
                    }

                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = canvas.offsetWidth;
                    startHeight = canvas.offsetHeight;

                    document.body.style.cursor = 'nwse-resize';
                    document.body.classList.add('resizing-canvas');
                });

                // MouseMove
                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    let newWidth = Math.max(400, startWidth + deltaX);
                    let newHeight = Math.max(300, startHeight + deltaY);

                    canvas.style.width = newWidth + 'px';
                    canvas.style.height = newHeight + 'px';

                    updateHandlePosition();
                });

                // MouseUp
                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                        document.body.classList.remove('resizing-canvas');

                        // Salva dimensioni custom
                        const tab = this.getCurrentTab();
                        tab.customWidth = canvas.offsetWidth;
                        tab.customHeight = canvas.offsetHeight;

                        this.saveState(`Ridimensionato canvas a ${canvas.offsetWidth}x${canvas.offsetHeight}px`);
                    }
                });

                // Aggiorna handle quando il canvas cambia dimensione
                const resizeObserver = new ResizeObserver(() => {
                    updateHandlePosition();
                });
                resizeObserver.observe(canvas);

                // Aggiorna anche sullo scroll del container
                container.addEventListener('scroll', updateHandlePosition);
            }

            updateAllResizeHandles() {
                const canvas = document.getElementById('canvas');
                const canvasContainer = canvas.parentElement;

                // ‚úÖ FORZA il browser a ricalcolare le dimensioni del canvas
                canvas.offsetHeight;

                // ‚úÖ USA getBoundingClientRect per coordinate ACCURATE
                const canvasRect = canvas.getBoundingClientRect();
                const containerRect = canvasContainer.getBoundingClientRect();

                const positions = {
                    'n': {
                        left: canvasRect.left + canvasRect.width / 2 - containerRect.left - 10,
                        top: canvasRect.top - containerRect.top - 10
                    },
                    'ne': {
                        left: canvasRect.right - containerRect.left - 10,
                        top: canvasRect.top - containerRect.top - 10
                    },
                    'e': {
                        left: canvasRect.right - containerRect.left - 10,
                        top: canvasRect.top + canvasRect.height / 2 - containerRect.top - 10
                    },
                    'se': {
                        left: canvasRect.right - containerRect.left - 10,
                        top: canvasRect.bottom - containerRect.top - 10
                    },
                    's': {
                        left: canvasRect.left + canvasRect.width / 2 - containerRect.left - 10,
                        top: canvasRect.bottom - containerRect.top - 10
                    },
                    'sw': {
                        left: canvasRect.left - containerRect.left - 10,
                        top: canvasRect.bottom - containerRect.top - 10
                    },
                    'w': {
                        left: canvasRect.left - containerRect.left - 10,
                        top: canvasRect.top + canvasRect.height / 2 - containerRect.top - 10
                    },
                    'nw': {
                        left: canvasRect.left - containerRect.left - 10,
                        top: canvasRect.top - containerRect.top - 10
                    }
                };

                Object.entries(positions).forEach(([direction, pos]) => {
                    const handle = document.getElementById(`canvasResizeHandle-${direction}`);
                    if (handle) {
                        handle.style.left = pos.left + 'px';
                        handle.style.top = pos.top + 'px';
                    }
                });
            }

            // 3. AGGIUNGI METODO per aggiornare la posizione dell'handle
            updateResizeHandlePosition() {
                const canvas = document.getElementById('canvas');
                const handle = document.getElementById('canvasResizeHandle');

                if (handle && canvas) {
                    const rect = canvas.getBoundingClientRect();
                    const containerRect = canvas.parentElement.getBoundingClientRect();

                    handle.style.left = (rect.right - containerRect.left - 10) + 'px';
                    handle.style.top = (rect.bottom - containerRect.top - 10) + 'px';
                }
            }
            // NUOVO METODO - Toggle bordi canvas
            toggleCanvasBorder() {
                const tab = this.getCurrentTab();
                tab.showBorder = !tab.showBorder;
                this.showCanvasBorder = tab.showBorder;

                const canvas = document.getElementById('canvas');
                canvas.classList.toggle('show-border', tab.showBorder);

                document.getElementById('toggleCanvasBorder').classList.toggle('active', tab.showBorder);
            }

            changeSpriteFrame(frameNumber) {
                if (!this.selectedObject) return;

                const objectData = this.getCurrentTab().objects.get(this.selectedObject.id);
                if (!objectData || objectData.type !== 'sprite') return;

                const maxFrame = (objectData.spriteData.cols * objectData.spriteData.rows) - 1;
                frameNumber = Math.max(0, Math.min(maxFrame, frameNumber));

                objectData.spriteData.frame = frameNumber;
                this.renderObject(objectData);
                this.saveState(`Modificato frame sprite a ${frameNumber}`);

                // Aggiorna l'info
                document.getElementById('objectInfo').textContent = `Sprite selezionato (Frame ${frameNumber}/${maxFrame})`;
            }

            playSpriteAnimation() {
                if (!this.selectedObject) return;

                const objectData = this.getCurrentTab().objects.get(this.selectedObject.id);
                if (!objectData || objectData.type !== 'sprite') return;

                // Ferma animazione esistente
                if (objectData.animationInterval) {
                    clearInterval(objectData.animationInterval);
                }

                // Leggi parametri
                const framesInput = document.getElementById('spriteAnimationFrames').value;
                const fps = parseInt(document.getElementById('spriteAnimationFPS').value) || 10;

                // Parse della sequenza frame
                let frames;
                try {
                    frames = framesInput.split(',').map(f => parseInt(f.trim())).filter(f => !isNaN(f));
                    if (frames.length === 0) throw new Error('Nessun frame valido');
                } catch (e) {
                    alert('Sequenza frame non valida. Usa numeri separati da virgola (es: 0,1,2,3)');
                    return;
                }

                // Avvia animazione
                const delay = 1000 / fps;
                let currentIndex = 0;

                objectData.animationInterval = setInterval(() => {
                    objectData.spriteData.frame = frames[currentIndex];
                    this.renderObject(objectData);
                    document.getElementById('spriteCurrentFrame').value = frames[currentIndex];
                    currentIndex = (currentIndex + 1) % frames.length;
                }, delay);

                // Aggiorna UI
                document.getElementById('spritePlayAnimation').style.display = 'none';
                document.getElementById('spriteStopAnimation').style.display = 'inline-block';
                document.getElementById('objectInfo').textContent = `Sprite animato (${frames.length} frame @ ${fps}fps)`;
            }

            stopSpriteAnimation() {
                if (!this.selectedObject) return;

                const objectData = this.getCurrentTab().objects.get(this.selectedObject.id);
                if (!objectData || objectData.type !== 'sprite') return;

                if (objectData.animationInterval) {
                    clearInterval(objectData.animationInterval);
                    delete objectData.animationInterval;
                }

                // Aggiorna UI
                document.getElementById('spritePlayAnimation').style.display = 'inline-block';
                document.getElementById('spriteStopAnimation').style.display = 'none';

                const maxFrame = (objectData.spriteData.cols * objectData.spriteData.rows) - 1;
                document.getElementById('objectInfo').textContent = `Sprite selezionato (Frame ${objectData.spriteData.frame}/${maxFrame})`;
            }

            applySpriteFrameSize() {
                if (!this.selectedObject) return;

                const objectData = this.getCurrentTab().objects.get(this.selectedObject.id);
                if (!objectData || objectData.type !== 'sprite') return;

                const newWidth = parseInt(document.getElementById('spriteFrameWidth').value);
                const newHeight = parseInt(document.getElementById('spriteFrameHeight').value);

                if (newWidth > 0 && newHeight > 0) {
                    objectData.spriteData.frameWidth = newWidth;
                    objectData.spriteData.frameHeight = newHeight;
                    this.renderObject(objectData);
                    this.saveState(`Modificate dimensioni frame sprite a ${newWidth}x${newHeight}`);

                    alert('Dimensioni frame aggiornate. Nota: verifica che corrispondano alla tua sprite sheet!');
                }
            }
            snapObjectsToGrid(gridSize = 20) {
                // Seleziona il contenitore del canvas
                const canvas = document.getElementById('canvas');
                if (!canvas) return;

                // Seleziona tutti gli oggetti mobili sul canvas
                // (Assumendo che .canvas-object sia la classe per gli elementi trascinabili)
                const objects = canvas.querySelectorAll('.canvas-object');

                let snappedCount = 0;

                objects.forEach(object => {
                    // Ignora gli oggetti che non hanno posizioni valide (es. elementi SVG/Freccia, se non hanno left/top diretti)
                    if (!object.style.left || !object.style.top) {
                        return;
                    }

                    // 1. Ottieni la posizione corrente (rimuovi 'px' e converti in numero)
                    const currentLeft = parseFloat(object.style.left);
                    const currentTop = parseFloat(object.style.top);

                    // 2. Calcola la nuova posizione arrotondata al multiplo pi√π vicino di gridSize
                    const snappedLeft = Math.round(currentLeft / gridSize) * gridSize;
                    const snappedTop = Math.round(currentTop / gridSize) * gridSize;

                    // 3. Applica la nuova posizione
                    object.style.left = `${snappedLeft}px`;
                    object.style.top = `${snappedTop}px`;

                    snappedCount++;

                    // ‚ö†Ô∏è Nota: Se la tua classe SchemaEditor gestisce un modello di dati interno
                    // (ad esempio, un array di oggetti con propriet√† `x` e `y`),
                    // dovrai anche aggiornare quel modello di dati qui.

                    // Se hai un sistema di cronologia (Undo/Redo), potresti chiamare una funzione
                    // per registrare il cambio di posizione, ad esempio:
                    // if (this.updateObjectPosition) {
                    //     this.updateObjectPosition(object, snappedLeft, snappedTop);
                    // }
                });

                // console.log(`Allineati ${snappedCount} oggetti alla griglia di ${gridSize}px.`);

                // Registra lo stato dopo l'allineamento per l'Undo/Redo (se SchemaEditor ha questo metodo)
                if (this.saveState) {
                    this.saveState(`Allineati ${snappedCount} oggetti alla griglia di ${gridSize}px`);
                }
            };


            showContextMenu(e, objectId, type) {
                // Rimuovi menu esistente
                this.hideContextMenu();

                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.id = 'contextMenu';

                let menuItems = [];

                if (type === 'object') {
                    const obj = this.getCurrentTab().objects.get(objectId);
                    menuItems = [
                        { label: '‚úÇÔ∏è Taglia', action: () => this.cutSelected(), shortcut: 'Ctrl+X' },
                        { label: 'üìã Copia', action: () => this.copySelected(), shortcut: 'Ctrl+C' },
                        { separator: true },
                        { label: '‚¨ÜÔ∏è In primo piano', action: () => this.bringToFront(), shortcut: 'Ctrl+]' },
                        { label: '‚¨áÔ∏è In background', action: () => this.sendToBack(), shortcut: 'Ctrl+[' },
                        { separator: true },
                        { label: '‚Ü∫ Ruota -15¬∞', action: () => this.rotateSelected(-15) },
                        { label: '‚Üª Ruota +15¬∞', action: () => this.rotateSelected(15) },
                        { separator: true },
                        { label: obj?.dashed ? '‚îÅ Linea continua' : '‚ïå Linea tratteggiata', action: () => this.toggleDashedObject() },
                        { separator: true },
                        { label: 'üóëÔ∏è Elimina', action: () => this.deleteSelected(), shortcut: 'Canc' }
                    ];
                } else if (type === 'arrow') {
                    const arrow = this.getCurrentTab().arrows.get(objectId);
                    menuItems = [
                        { label: '‚îÅ Lineare', action: () => this.changeArrowType('linear') },
                        { label: '‚å¢ Curva', action: () => this.changeArrowType('curved') },
                        { label: '‚ö° Zigzag', action: () => this.changeArrowType('zigzag') },
                        { separator: true },
                        { label: arrow?.dashed ? '‚îÅ Linea continua' : '‚ïå Linea tratteggiata', action: () => this.toggleDashedArrow() },
                        { separator: true },
                        { label: 'üóëÔ∏è Elimina', action: () => this.deleteSelected(), shortcut: 'Canc' }
                    ];
                } else if (type === 'freehand') {
                    menuItems = [
                        { label: 'üóëÔ∏è Elimina', action: () => this.deleteSelected(), shortcut: 'Canc' }
                    ];
                }

                menuItems.forEach(item => {
                    if (item.separator) {
                        const separator = document.createElement('div');
                        separator.className = 'context-menu-separator';
                        menu.appendChild(separator);
                    } else {
                        const menuItem = document.createElement('div');
                        menuItem.className = 'context-menu-item';
                        menuItem.innerHTML = `
                <span>${item.label}</span>
                ${item.shortcut ? `<span style="margin-left: auto; opacity: 0.6; font-size: 11px;">${item.shortcut}</span>` : ''}
            `;
                        menuItem.addEventListener('click', () => {
                            item.action();
                            this.hideContextMenu();
                        });
                        menu.appendChild(menuItem);
                    }
                });

                document.body.appendChild(menu);

                // Posiziona il menu
                const menuRect = menu.getBoundingClientRect();
                let left = e.clientX;
                let top = e.clientY;

                // Assicurati che il menu non esca dallo schermo
                if (left + menuRect.width > window.innerWidth) {
                    left = window.innerWidth - menuRect.width - 5;
                }
                if (top + menuRect.height > window.innerHeight) {
                    top = window.innerHeight - menuRect.height - 5;
                }

                menu.style.left = left + 'px';
                menu.style.top = top + 'px';

                // Chiudi il menu al click fuori
                setTimeout(() => {
                    document.addEventListener('click', this.hideContextMenu.bind(this), { once: true });
                    document.addEventListener('contextmenu', this.hideContextMenu.bind(this), { once: true });
                }, 0);
            }

            hideContextMenu() {
                const menu = document.getElementById('contextMenu');
                if (menu) {
                    menu.remove();
                }
            }
            startFreehand(e) {
                this.isDrawing = true;
                this.freehandPoints = [];
                const rect = document.getElementById('canvas').getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.getCurrentTab().zoom;
                const y = (e.clientY - rect.top) / this.getCurrentTab().zoom;
                this.freehandPoints.push({ x, y });
            }

            continueFreehand(e) {
                if (!this.isDrawing) return;
                const rect = document.getElementById('canvas').getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.getCurrentTab().zoom;
                const y = (e.clientY - rect.top) / this.getCurrentTab().zoom;

                // Aggiungi punto solo se sufficientemente distante dall'ultimo
                const lastPoint = this.freehandPoints[this.freehandPoints.length - 1];
                const distance = Math.sqrt(Math.pow(x - lastPoint.x, 2) + Math.pow(y - lastPoint.y, 2));
                if (distance > 2) {
                    this.freehandPoints.push({ x, y });
                    this.renderTempFreehand();
                }
            }

            finishFreehand() {
                if (!this.isDrawing || this.freehandPoints.length < 2) {
                    this.isDrawing = false;
                    this.removeTempFreehand();
                    return;
                }

                this.isDrawing = false;
                this.createFreehand(
                    this.freehandPoints,
                    document.getElementById('freehandColor').value,
                    parseInt(document.getElementById('freehandThickness').value)
                );
                this.freehandPoints = [];
                this.removeTempFreehand();
            }

            createFreehand(points, color, thickness) {
                const tab = this.getCurrentTab();
                const id = 'freehand-' + tab.nextFreehandId++;

                const freehand = {
                    id: id,
                    type: 'freehand',
                    points: [...points],
                    color: color,
                    thickness: thickness,
                    opacity: 1,
                    zIndex: this.maxZIndex++
                };

                tab.freehands.set(id, freehand);
                this.renderFreehand(freehand);
                this.saveState(`Creato disegno a mano libera ${id}`);
                return freehand;
            }

            renderTempFreehand() {
                this.removeTempFreehand();
                if (this.freehandPoints.length < 2) return;

                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.id = 'temp-freehand';
                svg.classList.add('freehand-svg');
                svg.style.position = 'absolute';
                svg.style.left = '0';
                svg.style.top = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', this.pointsToPath(this.freehandPoints));
                path.setAttribute('stroke', document.getElementById('freehandColor').value);
                path.setAttribute('stroke-width', document.getElementById('freehandThickness').value);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');

                svg.appendChild(path);
                document.getElementById('canvas').appendChild(svg);
            }

            removeTempFreehand() {
                const temp = document.getElementById('temp-freehand');
                if (temp) temp.remove();
            }

            pointsToPath(points) {
                if (points.length < 2) return '';
                let path = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    path += ` L ${points[i].x} ${points[i].y}`;
                }
                return path;
            }

            renderFreehand(freehand) {
                let svg = document.getElementById(freehand.id);
                if (!svg) {
                    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.classList.add('freehand-svg');
                    svg.id = freehand.id;
                    document.getElementById('canvas').appendChild(svg);
                } else {
                    svg.innerHTML = '';
                }

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.classList.add('freehand-path');
                path.setAttribute('d', this.pointsToPath(freehand.points));
                path.setAttribute('stroke', freehand.color);
                path.setAttribute('stroke-width', freehand.thickness);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.style.opacity = freehand.opacity || 1;
                path.style.zIndex = freehand.zIndex || 1;

                path.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.selectFreehand(freehand.id);
                });

                path.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (this.selectedFreehand !== freehand.id) {
                        this.selectFreehand(freehand.id);
                    }
                    this.showContextMenu(e, freehand.id, 'freehand');
                });

                svg.appendChild(path);

                // Calcola bounding box
                const xs = freehand.points.map(p => p.x);
                const ys = freehand.points.map(p => p.y);
                const minX = Math.min(...xs) - freehand.thickness;
                const minY = Math.min(...ys) - freehand.thickness;
                const maxX = Math.max(...xs) + freehand.thickness;
                const maxY = Math.max(...ys) + freehand.thickness;

                svg.style.left = minX + 'px';
                svg.style.top = minY + 'px';
                svg.style.width = (maxX - minX) + 'px';
                svg.style.height = (maxY - minY) + 'px';
                svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
            }
            changeFreehandOpacity(opacity) {
                if (!this.selectedFreehand) return;
                const freehand = this.getCurrentTab().freehands.get(this.selectedFreehand);
                if (freehand) {
                    freehand.opacity = parseFloat(opacity);
                    const svg = document.getElementById(this.selectedFreehand);
                    if (svg) {
                        const path = svg.querySelector('.freehand-path');
                        if (path) path.style.opacity = opacity;
                    }
                    this.saveState(`Modificata opacit√† disegno a mano libera ${freehand.id} a ${opacity}`);
                }
            }

            changeSelectedObjectsOpacity(opacity) {
                if (this.selectedObjects.size === 0) return;

                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (!objectData) return;
                    objectData.opacity = parseFloat(opacity);

                    const element = document.getElementById(id);
                    if (element) {
                        element.style.opacity = opacity;
                    }
                });

                this.saveState(`Modificata opacit√† oggetti selezionati a ${opacity}`);
            }

            selectFreehand(freehandId) {
                this.deselectAll();
                this.selectedFreehand = freehandId;

                const svg = document.getElementById(freehandId);
                if (svg) {
                    const path = svg.querySelector('.freehand-path');
                    if (path) path.classList.add('selected');
                }

                this.updateFreehandControls();
            }

            updateFreehandControls() {
                if (this.selectedFreehand) {
                    const freehand = this.getCurrentTab().freehands.get(this.selectedFreehand);
                    document.getElementById('freehandColor').value = freehand.color;
                    document.getElementById('freehandThickness').value = freehand.thickness;
                    document.getElementById('freehandThicknessValue').textContent = freehand.thickness;
                    document.getElementById('freehandOpacity').value = freehand.opacity || 1;
                    document.getElementById('freehandOpacityValue').textContent = (freehand.opacity || 1).toFixed(2);

                    document.getElementById('objectInfo').textContent = 'Disegno selezionato';
                    document.getElementById('objectControls').style.display = 'none';
                    document.getElementById('arrowControls').style.display = 'none';
                    document.getElementById('freehandControls').style.display = 'flex';
                }
            }

            changeFreehandColor(color) {
                if (!this.selectedFreehand) return;
                const freehand = this.getCurrentTab().freehands.get(this.selectedFreehand);
                if (freehand) {
                    freehand.color = color;
                    // ‚úÖ Ri-renderizza completamente il disegno
                    this.renderFreehand(freehand);
                    this.saveState(`Modificato colore disegno a mano libera ${freehand.id} a ${color}`);
                }
            }

            changeFreehandThickness(thickness) {
                if (!this.selectedFreehand) return;
                const freehand = this.getCurrentTab().freehands.get(this.selectedFreehand);
                if (freehand) {
                    freehand.thickness = parseInt(thickness);
                    this.renderFreehand(freehand);
                    this.saveState(`Modificato spessore disegno a mano libera ${freehand.id} a ${thickness}`);
                }
            }
            filterCategoriesByGenere(genere) {
                const categoriaSelect = document.getElementById('workoutCategoria');
                const allOptions = categoriaSelect.querySelectorAll('option');
                const allOptgroups = categoriaSelect.querySelectorAll('optgroup');

                // Mostra tutto per default
                allOptions.forEach(opt => opt.style.display = '');
                allOptgroups.forEach(grp => grp.style.display = '');

                if (genere === 'M') {
                    // Mostra solo maschili
                    allOptions.forEach(opt => {
                        if (opt.value.includes('F') && !opt.value.includes('M') && opt.value !== 'GEN') {
                            opt.style.display = 'none';
                        }
                    });
                    allOptgroups.forEach(grp => {
                        if (grp.label.includes('Femminili')) {
                            grp.style.display = 'none';
                        }
                    });
                } else if (genere === 'F') {
                    // Mostra solo femminili
                    allOptions.forEach(opt => {
                        if (opt.value.includes('M') && !opt.value.includes('F') && opt.value !== 'GEN' && opt.value !== 'MIS') {
                            opt.style.display = 'none';
                        }
                    });
                    allOptgroups.forEach(grp => {
                        if (grp.label.includes('Maschili')) {
                            grp.style.display = 'none';
                        }
                    });
                }
                // Per 'MIS' mostra tutto
            }
            async initLogin() {
                try {
                    // Carica gli utenti dal JSON
                    const response = await fetch('data/users.json');
                    if (!response.ok) {
                        // Fallback con utenti di default se il file non esiste
                        console.warn('File users.json non trovato, uso utenti di default');
                        this.users = [
                            { username: 'admin', password: '1234' },
                            { username: 'coach', password: '1234' }
                        ];
                    } else {
                        const data = await response.json();
                        this.users = data.users;
                    }
                } catch (error) {
                    console.error('Errore nel caricamento utenti:', error);
                    // Fallback con utenti di default
                    this.users = [
                        { username: 'admin', password: '1234' },
                        { username: 'coach', password: '1234' }
                    ];
                }

                // Controlla se c'√® una sessione salvata
                const savedUser = sessionStorage.getItem('currentUser');
                if (savedUser) {
                    this.currentUser = savedUser;
                    this.showMainApp();
                } else {
                    this.showLoginModal();
                }

                // Event listeners per il login
                document.getElementById('loginForm').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleLogin();
                });

                document.getElementById('logoutButton').addEventListener('click', () => {
                    this.handleLogout();
                });
            }

            showLoginModal() {
                document.getElementById('loginModal').style.display = 'flex';
                document.querySelector('.container').style.display = 'none';
                document.getElementById('username').focus();
            }

            hideLoginModal() {
                document.getElementById('loginModal').style.display = 'none';
                document.querySelector('.container').style.display = 'flex';
            }

            handleLogin() {
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                const errorDiv = document.getElementById('loginError');

                // Verifica credenziali
                const user = this.users.find(u => u.username === username && u.password === password);

                if (user) {
                    this.currentUser = username;
                    sessionStorage.setItem('currentUser', username);
                    errorDiv.style.display = 'none';
                    this.showMainApp();

                    // Reset form
                    document.getElementById('loginForm').reset();
                } else {
                    errorDiv.style.display = 'block';
                    document.getElementById('password').value = '';
                    document.getElementById('password').focus();
                }
            }
            handleLogout() {
                if (confirm('Sei sicuro di voler uscire?')) {
                    this.currentUser = null;
                    sessionStorage.removeItem('currentUser');

                    // Nascondi container principale
                    const mainContainer = document.querySelector('.container');
                    if (mainContainer) {
                        mainContainer.style.display = 'none';
                    }

                    // Nascondi info utente
                    document.getElementById('userInfo').style.display = 'none';

                    this.showLoginModal();
                }
            }


            showSaveWorkoutDialog() {
                // Genera un nome predefinito con data e ora
                const now = new Date();
                const defaultName = `Allenamento_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
                document.getElementById('workOutListName').innerHTML = '';
                this.tabs.forEach((tab, tabId) => {
                    const tabName = tab.name || `Tab_${tabId + 1}`;
                    const tabDiv = document.createElement('div');
                    tabDiv.classList.add('tab');
                    tabDiv.textContent = tabName;
                    document.getElementById('workOutListName').appendChild(tabDiv);
                });
                document.getElementById('workoutFileName').value = defaultName;
                document.getElementById('saveWorkoutModal').style.display = 'block';

                // Focus sull'input e seleziona il testo
                setTimeout(() => {
                    const input = document.getElementById('workoutFileName');
                    input.focus();
                    input.select();
                }, 100);
            }

            confirmSaveWorkout() {
                const fileName = document.getElementById('workoutFileName').value.trim();

                if (!fileName) {
                    alert('Inserisci un nome per il file');
                    return;
                }

                // Chiudi il modal
                document.getElementById('saveWorkoutModal').style.display = 'none';

                // Salva l'allenamento
                this.saveWorkout(fileName);
            }

            showSaveWorkoutDialog() {
                // Genera un nome predefinito con data e ora
                const now = new Date();
                const defaultName = `Allenamento_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;

                document.getElementById('workOutListName').innerHTML = '';
                this.tabs.forEach((tab, tabId) => {
                    const tabName = tab.name || `Tab_${tabId + 1}`;
                    const tabDiv = document.createElement('div');
                    tabDiv.classList.add('tab');
                    tabDiv.textContent = tabName;
                    document.getElementById('workOutListName').appendChild(tabDiv);
                });

                document.getElementById('workoutFileName').value = defaultName;

                // ‚úÖ Ripristina i valori salvati in precedenza (se esistono)
                document.getElementById('workoutGlobalObjective').value = this.currentWorkoutObjective || '';
                document.getElementById('workoutGlobalObservations').value = this.currentWorkoutObservations || '';

                document.getElementById('saveWorkoutModal').style.display = 'block';

                // Focus sull'input e seleziona il testo
                setTimeout(() => {
                    const input = document.getElementById('workoutFileName');
                    input.focus();
                    input.select();
                }, 100);
            }

            saveWorkout(fileName) {
                // Salva lo stato corrente del tab attivo
                this.saveTabState();

                // ‚úÖ Leggi i campi globali dal modal
                const globalObjective = document.getElementById('workoutGlobalObjective').value.trim();
                const globalObservations = document.getElementById('workoutGlobalObservations').value.trim();

                // Crea un array con tutti i tab
                const allTabs = [];

                this.tabs.forEach((tab, tabId) => {
                    const tabData = {
                        id: tabId,
                        name: tab.name,
                        objects: Array.from(tab.objects.entries()),
                        arrows: Array.from(tab.arrows.entries()),
                        background: tab.background,
                        gridVisible: tab.gridVisible,
                        bwMode: tab.bwMode,
                        zoom: tab.zoom,
                        periodo: tab.periodo || 'GEN',
                        ruolo: tab.ruolo || 'GEN',
                        tipologia: tab.tipologia || 'GEN',
                        genere: tab.genere || 'GEN',
                        categoria: tab.categoria || 'GEN',
                        descrizione: tab.descrizione || '',
                        autore: tab.autore || this.currentUser,
                        place: tab.place || "",
                        groups: tab.groups || 1,
                        nr: tab.nr || 1,
                        date: tab.date || new Date(),
                        series: tab.series || 1,
                        timing: tab.timing || 10,
                        rec: tab.rec || 60,
                        freehands: Array.from(tab.freehands?.entries() || []),
                        frames: tab.frames?.map(frame => ({
                            id: frame.id,
                            timestamp: frame.timestamp,
                            objects: Array.from(frame.objects.entries())
                        })) || [],
                        exerciseSteps: tab.exerciseSteps || []
                    };
                    allTabs.push(tabData);
                });

                // ‚úÖ Crea il JSON completo con i nuovi campi
                const workoutData = {
                    version: '1.1',
                    savedDate: new Date().toISOString(),
                    author: this.currentUser,
                    objective: globalObjective,        // ‚úÖ NUOVO
                    observations: globalObservations,  // ‚úÖ NUOVO
                    tabs: allTabs
                };

                // Salva il file
                const blob = new Blob([JSON.stringify(workoutData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${fileName}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log(`Allenamento salvato: ${allTabs.length} schemi`);

                // ‚úÖ Chiudi il modal dopo il salvataggio
                document.getElementById('saveWorkoutModal').style.display = 'none';
            }

            loadWorkout(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const workoutData = JSON.parse(e.target.result);

                        // Verifica che sia un file workout valido
                        if (!workoutData.tabs || !Array.isArray(workoutData.tabs)) {
                            alert('File non valido: formato allenamento non riconosciuto');
                            return;
                        }

                        // ‚úÖ Mostra obiettivo e osservazioni se presenti
                        let confirmMessage = `Questo caricamento sostituir√† tutti gli schemi attuali con ${workoutData.tabs.length} schemi dal file.`;

                        if (workoutData.objective) {
                            confirmMessage += `\n\nüìã Obiettivo: ${workoutData.objective}`;
                        }

                        if (workoutData.observations) {
                            confirmMessage += `\n\nüìù Osservazioni: ${workoutData.observations}`;
                        }

                        confirmMessage += `\n\nContinuare?`;

                        if (!confirm(confirmMessage)) {
                            return;
                        }

                        // ‚úÖ Salva i dati globali per uso futuro (opzionale)
                        this.currentWorkoutObjective = workoutData.objective || '';
                        this.currentWorkoutObservations = workoutData.observations || '';

                        // Pulisci tutti i tab esistenti
                        this.tabs.clear();
                        document.querySelectorAll('.tab').forEach(tab => tab.remove());

                        // Ricrea i tab dal file
                        let firstTabId = null;
                        workoutData.tabs.forEach((tabData, index) => {
                            const tabId = tabData.id || (this.nextTabId++);

                            if (index === 0) firstTabId = tabId;

                            // Inizializza il tab
                            this.initializeTab(tabId, tabData.name);

                            // Carica i dati del tab
                            const tab = this.tabs.get(tabId);
                            tabData.objects.forEach(([id, obj]) => tab.objects.set(id, obj));
                            tabData.arrows.forEach(([id, arrow]) => tab.arrows.set(id, arrow));

                            // ‚úÖ Gestisci freehands se presenti
                            if (tabData.freehands) {
                                tabData.freehands.forEach(([id, freehand]) => tab.freehands.set(id, freehand));
                            }

                            tab.background = tabData.background || 'none';
                            tab.gridVisible = tabData.gridVisible || false;
                            tab.bwMode = tabData.bwMode || false;
                            tab.zoom = tabData.zoom || 1;
                            tab.periodo = tabData.periodo || 'GEN';
                            tab.ruolo = tabData.ruolo || 'GEN';
                            tab.tipologia = tabData.tipologia || 'GEN';
                            tab.genere = tabData.genere || 'GEN';
                            tab.categoria = tabData.categoria || 'GEN';
                            tab.descrizione = tabData.descrizione || '';
                            tab.autore = tabData.autore || 'unknown';
                            tab.series = tabData.series || 1;
                            tab.nr = tabData.nr || 1;
                            tab.groups = tabData.groups || 1;
                            tab.place = tabData.place || "";
                            tab.date = tabData.date || new Date();
                            tab.timing = tabData.timing || 10;
                            tab.rec = tabData.rec || 60;
                            tab.exerciseSteps = tabData.exerciseSteps || [];

                            // ‚úÖ Carica frames se presenti
                            if (tabData.frames) {
                                tab.frames = tabData.frames.map(frameData => ({
                                    id: frameData.id,
                                    timestamp: frameData.timestamp,
                                    objects: new Map(frameData.objects)
                                }));
                                tab.currentFrameIndex = 0;
                            }

                            // Aggiorna nextObjectId e nextArrowId
                            tab.nextObjectId = Math.max(...Array.from(tab.objects.keys()).map(id => parseInt(id.split('-')[1]) || 0)) + 1;
                            tab.nextArrowId = Math.max(...Array.from(tab.arrows.keys()).map(id => parseInt(id.split('-')[1]) || 0)) + 1;

                            // Crea l'elemento tab nella UI
                            this.createTabElement(tabId, tabData.name);
                        });

                        // Aggiorna nextTabId
                        this.nextTabId = Math.max(...Array.from(this.tabs.keys())) + 1;

                        // Passa al primo tab
                        if (firstTabId) {
                            this.switchToTab(firstTabId);
                        }

                        console.log(`‚úÖ Allenamento caricato: ${workoutData.tabs.length} schemi`);
                        console.log(`üìã Obiettivo: ${workoutData.objective || 'Non specificato'}`);
                        console.log(`üìù Osservazioni: ${workoutData.observations || 'Nessuna'}`);

                    } catch (error) {
                        alert('Errore nel caricamento del file: ' + error.message);
                        console.error('Errore caricamento workout:', error);
                    }
                };

                reader.readAsText(file);

                // Reset dell'input per permettere di caricare lo stesso file di nuovo
                event.target.value = '';
            }
            showMainApp() {
                this.hideLoginModal();

                // Mostra container principale
                const mainContainer = document.querySelector('.container');
                if (mainContainer) {
                    mainContainer.style.display = 'flex';
                }

                // Mostra info utente
                document.getElementById('currentUsername').textContent = this.currentUser;
                document.getElementById('userInfo').style.display = 'flex';

                // ‚úÖ MODIFICA: Inizializza l'app solo al primo login
                if (!this.initialized) {
                    this.initLibraryLoading();
                    this.initializeTab(1, 'Schema 1');
                    this.initCanvasResize();
                    this.initializeEventListeners();
                    this.initializeExistingTabs();
                    this.updateUI();
                    this.initialized = true;
                }
            }
            getCurrentTab() {
                return this.tabs.get(this.activeTabId);
            }

            // Metodo di utilit√† per la scomposizione del nome file
            parseFilename(filename) {
                // Esempio: PRE.ANA.A.alzate_miste.json
                const parts = filename.replace('.json', '').split('.');
                if (parts.length < 4) return null;

                const [periodo, tipologia, ruolo, ...rest] = parts;
                const titolo = rest.join('.'); // Ricompone il titolo se contiene altri punti

                return {
                    filename: filename,
                    periodo: periodo,
                    tipologia: tipologia,
                    ruolo: ruolo,
                    titolo: titolo.replace(/_/g, ' ') // Sostituisce gli underscore con spazi per la visualizzazione
                };
            }

            initLibraryLoading() {
                const loadButton = document.getElementById('loadFromLibrary');
                const dialog = document.getElementById('libraryDialog');
                const closeButton = document.getElementById('closeLibraryDialog');
                const loadSelectedBtn = document.getElementById('loadSelectedWorkout');
                const filterPeriodo = document.getElementById('filterPeriodo');
                const filterTipologia = document.getElementById('filterTipologia');
                const filterRuolo = document.getElementById('filterRuolo');

                loadButton.addEventListener('click', () => {
                    dialog.style.display = 'block';
                    this.fetchLibraryWorkouts(); // Chiama il backend per la lista
                });

                closeButton.addEventListener('click', () => {
                    dialog.style.display = 'none';
                });

                window.addEventListener('click', (event) => {
                    if (event.target === dialog) {
                        dialog.style.display = 'none';
                    }
                });

                filterPeriodo.addEventListener('change', () => this.filterWorkouts());
                filterTipologia.addEventListener('change', () => this.filterWorkouts());
                filterRuolo.addEventListener('change', () => this.filterWorkouts());

                loadSelectedBtn.addEventListener('click', () => {
                    if (this.selectedLibraryFile) {
                        const fileWorkOut = this.loadWorkoutFromBackend(this.selectedLibraryFile);
                        this.loadSchema(fileWorkOut)
                    }
                });
            }

            // Carica la lista dei file dal backend PHP con FALLBACK
            async fetchLibraryWorkouts() {
                let filenames = [];
                const endpoint = 'api/api_libreria.php';

                try {
                    // 1. Tenta la connessione al server
                    const response = await fetch(endpoint);

                    if (!response.ok) {
                        // Lancia un errore se la risposta HTTP non √® 200 (es. 404, 500)
                        throw new Error(`Errore nel server PHP (Status: ${response.status}).`);
                    }

                    filenames = await response.json();

                    if (!Array.isArray(filenames)) {
                        throw new Error('La risposta del server non √® un array valido di nomi file.');
                    }

                    // *** STATO DI SUCCESSO ***
                    this.librarySource = 'server';

                    const listElement = document.getElementById('workoutList');
                    if (listElement) listElement.innerHTML = '';

                } catch (error) {
                    // 2. LOGICA DI FALLBACK: Se la fetch fallisce o lancia un errore
                    console.warn(`Tentativo fallito di caricare la libreria da ${endpoint}. Carico esempi di default.`);
                    console.error(error);

                    // *** STATO DI FALLBACK ***
                    this.librarySource = 'fallback';

                    // Array di nomi file di default
                    filenames = [
                        'PRE.ANA.A.esempio1.json'
                    ];

                    // 3. Avvisa l'utente sulla UI
                    const listElement = document.getElementById('workoutList');
                    if (listElement) {
                        listElement.innerHTML = '<li style="color: orange; padding: 10px; cursor: default;">‚ö†Ô∏è **FALLBACK:** Server non raggiunto. Caricati esempi locali.</li>';
                    }
                }

                // 4. Continua l'elaborazione
                this.libraryWorkouts = filenames
                    .map(f => this.parseFilename(f))
                    .filter(w => w !== null);

                this.populateFilters(this.libraryWorkouts);
                this.filterWorkouts();
            }

            // Popola i menu a tendina (select) dei filtri
            populateFilters(workouts) {
                const filters = {
                    periodo: new Set(),
                    tipologia: new Set(),
                    ruolo: new Set()
                };

                workouts.forEach(w => {
                    filters.periodo.add(w.periodo);
                    filters.tipologia.add(w.tipologia);
                    filters.ruolo.add(w.ruolo);
                });

                ['periodo', 'tipologia', 'ruolo'].forEach(key => {
                    const select = document.getElementById(`filter${key.charAt(0).toUpperCase() + key.slice(1)}`);
                    select.innerHTML = `<option value="">Tutti</option>`;
                    Array.from(filters[key]).sort().forEach(value => {
                        const option = document.createElement('option');
                        option.value = value;
                        option.textContent = value;
                        select.appendChild(option);
                    });
                });
            }

            // Filtra la lista in base ai valori selezionati
            filterWorkouts() {
                this.selectedLibraryFile = null; // Deseleziona l'elemento corrente
                document.getElementById('loadSelectedWorkout').disabled = true;

                const periodo = document.getElementById('filterPeriodo').value;
                const tipologia = document.getElementById('filterTipologia').value;
                const ruolo = document.getElementById('filterRuolo').value;
                const workoutList = document.getElementById('workoutList');
                workoutList.innerHTML = '';

                const filtered = this.libraryWorkouts.filter(w =>
                    (periodo === "" || w.periodo === periodo) &&
                    (tipologia === "" || w.tipologia === tipologia) &&
                    (ruolo === "" || w.ruolo === ruolo)
                );

                filtered.forEach(w => {
                    const li = document.createElement('li');
                    li.textContent = `${w.titolo} (${w.periodo} | ${w.tipologia} | ${w.ruolo})`;
                    li.dataset.filename = w.filename; // Memorizza il nome del file completo

                    li.addEventListener('click', () => {
                        // Gestisce la selezione
                        document.querySelectorAll('#workoutList li').forEach(item => item.classList.remove('selected'));
                        li.classList.add('selected');
                        this.selectedLibraryFile = w.filename;
                        document.getElementById('loadSelectedWorkout').disabled = false;
                    });
                    workoutList.appendChild(li);
                });
            }

            // Carica il contenuto dell'allenamento selezionato chiamando il backend PHP
            async loadWorkoutFromBackend(filename) {
                let workoutData = null;

                // 1. GESTIONE DEL FALLBACK (Caricamento locale)
                if (this.librarySource === 'fallback') {
                    const response = await fetch(`volleyball_exercise_library/${filename}`);

                    if (!response.ok) {
                        throw new Error(`Errore nel server (${response.status}). Il file non pu√≤ essere letto.`);
                    }

                    // Se la risposta √® OK, restituisci i dati dal server
                    workoutData = await response.json();
                    return workoutData;
                }

                // 2. GESTIONE DEL SERVER (Caricamento reale)
                try {
                    const response = await fetch(`./api/api_allenamento.php?filename=${encodeURIComponent(filename)}`);

                    if (!response.ok) {
                        throw new Error(`Errore nel server (${response.status}). Il file non pu√≤ essere letto.`);
                    }

                    // Se la risposta √® OK, restituisci i dati dal server
                    workoutData = await response.json();
                    return workoutData;

                } catch (error) {
                    console.error("Errore nel caricamento del contenuto dell'allenamento dal server:", error);
                    alert(`Impossibile caricare il contenuto per ${filename}. Errore di connessione o file non trovato.`);
                    return null; // Ritorna null in caso di fallimento grave del server
                }
            }
            initializeExistingTabs() {
                document.querySelectorAll('.tab').forEach(tabElement => {
                    const tabId = parseInt(tabElement.dataset.tabId);
                    const tabInput = tabElement.querySelector('.tab-title');

                    if (tabInput && !tabInput.hasEventListener) {
                        tabInput.addEventListener('input', (e) => {
                            this.updateTabName(tabId, e.target.value);
                        });

                        tabInput.addEventListener('click', (e) => {
                            e.stopPropagation();
                        });

                        tabInput.hasEventListener = true;
                    }
                });
            }
            initializeEventListeners() {
                console.log("Accordion listener attaccati:", document.querySelectorAll('.accordion-header').length);

                const componentItems = document.querySelectorAll('.component-item');
                componentItems.forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        const type = item.dataset.type;
                        if (type === 'arrow') {
                            e.preventDefault();
                        } else {
                            const dragData = {
                                type: item.dataset.type,
                                color: item.dataset.color || '',
                                text: item.dataset.text || '',
                                icon: item.dataset.icon || null,
                                src: item.dataset.src || null,
                                spriteSheet: item.dataset.spriteSheet || null,
                                spriteCols: parseInt(item.dataset.spriteCols) || 1,
                                spriteRows: parseInt(item.dataset.spriteRows) || 1,
                                spriteFrame: parseInt(item.dataset.spriteFrame) || 0,
                                spriteWidth: parseInt(item.dataset.spriteWidth) || 64,
                                spriteHeight: parseInt(item.dataset.spriteHeight) || 64
                            };
                            e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
                        }
                    });
                    item.draggable = true;
                });

                document.getElementById('arrowModeBtn').addEventListener('click', (e) => {
                    this.arrowMode = !this.arrowMode;
                    e.currentTarget.classList.toggle('active', this.arrowMode);
                    document.getElementById('canvas').style.cursor = this.arrowMode ? 'crosshair' : 'default';
                    this.deselectAll();
                });

                // Chiudi context menu quando si clicca sul canvas
                const canvas = document.getElementById('canvas');
                canvas.addEventListener('click', () => this.hideContextMenu());
                canvas.addEventListener('dragover', (e) => e.preventDefault());
                canvas.addEventListener('drop', (e) => this.handleCanvasDrop(e));
                canvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.handleCanvasMouseUp(e));

                document.querySelector('.tabs-container').addEventListener('click', (e) => {
                    const tabElement = e.target.closest('.tab');
                    if (tabElement) {
                        const tabId = parseInt(tabElement.dataset.tabId);
                        if (e.target.closest('.tab-close')) {
                            this.closeTab(tabId);
                        } else if (!e.target.classList.contains('tab-title')) {
                            this.switchToTab(tabId);
                        }
                    }
                });

                document.querySelector('.add-tab').addEventListener('click', () => this.addNewTab());
                document.getElementById('backgroundSelect').addEventListener('change', (e) => {
                    this.getCurrentTab().background = e.target.value;
                    this.updateBackground();
                });
                document.getElementById('gridToggle').addEventListener('click', () => {
                    this.getCurrentTab().gridVisible = !this.getCurrentTab().gridVisible;
                    this.updateGrid();
                });
                document.getElementById('bwToggle').addEventListener('click', () => {
                    this.getCurrentTab().bwMode = !this.getCurrentTab().bwMode;
                    this.updateBWMode();
                });

                document.getElementById('dashedToggle').addEventListener('click', () => {
                    this.dashedMode = !this.dashedMode;
                    document.getElementById('dashedToggle').classList.toggle('active', this.dashedMode);
                });

                document.getElementById('zoomIn').addEventListener('click', () => this.changeZoom(0.1));
                document.getElementById('zoomOut').addEventListener('click', () => this.changeZoom(-0.1));
                document.getElementById('rotateLeft').addEventListener('click', () => this.rotateSelected(-15));
                document.getElementById('rotateRight').addEventListener('click', () => this.rotateSelected(15));
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveSchema());
                document.getElementById('loadBtn').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });
                document.getElementById('fileInput').addEventListener('change', (e) => this.loadSchema(e));
                document.getElementById('exportBtn').addEventListener('click', () => this.exportSchema());
                document.getElementById('objectColor').addEventListener('change', (e) => {
                    this.changeSelectedObjectsColor(e.target.value);
                });
                document.getElementById('objectText').addEventListener('input', (e) => {
                    this.changeSelectedObjectsText(e.target.value);
                });
                document.getElementById('arrowColor').addEventListener('change', (e) => {
                    if (this.selectedArrow) {
                        this.changeArrowColor(e.target.value);
                    }
                });

                const thicknessInput = document.getElementById('arrowThickness');
                thicknessInput.addEventListener('input', (e) => {
                    document.getElementById('thicknessValue').textContent = e.target.value;
                    if (this.selectedArrow) {
                        this.changeArrowThickness(e.target.value);
                    }
                });

                document.getElementById('arrowOpacity').addEventListener('input', (e) => {
                    document.getElementById('arrowOpacityValue').textContent = parseFloat(e.target.value).toFixed(2);
                    if (this.selectedArrow) {
                        this.changeArrowOpacity(e.target.value);
                    }
                });

                document.getElementById('dashedArrowToggle').addEventListener('click', () => {
                    this.toggleDashedArrow();
                });

                document.getElementById('deleteBtn').addEventListener('click', () => this.deleteSelected());
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
                document.querySelectorAll('.arrow-type-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.changeArrowType(e.target.id.replace('arrowType', '').toLowerCase()));
                });

                // Event listeners per i terminali delle frecce
                document.getElementById('arrowMarkerStart').addEventListener('change', (e) => {
                    if (this.selectedArrow) {
                        const arrowData = this.getCurrentTab().arrows.get(this.selectedArrow);
                        if (arrowData) {
                            arrowData.markerStart = e.target.checked;
                            const svgElement = document.getElementById(this.selectedArrow);
                            if (svgElement) {
                                const path = svgElement.querySelector('.arrow-path');
                                const markerId = `arrowhead-${this.selectedArrow}`;
                                if (path) {
                                    if (e.target.checked) {
                                        path.setAttribute('marker-start', `url(#${markerId}-start)`);
                                    } else {
                                        path.removeAttribute('marker-start');
                                    }
                                }
                            }
                            this.saveState(`Modificato marker start freccia ${this.selectedArrow} a ${e.target.checked}`);
                        }
                    }
                });

                document.getElementById('arrowMarkerEnd').addEventListener('change', (e) => {
                    if (this.selectedArrow) {
                        const arrowData = this.getCurrentTab().arrows.get(this.selectedArrow);
                        if (arrowData) {
                            arrowData.markerEnd = e.target.checked;
                            const svgElement = document.getElementById(this.selectedArrow);
                            if (svgElement) {
                                const path = svgElement.querySelector('.arrow-path');
                                const markerId = `arrowhead-${this.selectedArrow}`;
                                if (path) {
                                    if (e.target.checked) {
                                        path.setAttribute('marker-end', `url(#${markerId}-end)`);
                                    } else {
                                        path.removeAttribute('marker-end');
                                    }
                                }
                            }
                            this.saveState(`Modificato marker end freccia ${this.selectedArrow} a ${e.target.checked}`);
                        }
                    }
                });




                document.getElementById('dashedObjectToggle').addEventListener('click', () => this.toggleDashedObject());

                document.getElementById('bringToFront').addEventListener('click', () => this.bringToFront());
                document.getElementById('sendToBack').addEventListener('click', () => this.sendToBack());

                // Added accordion functionality
                document.querySelectorAll('.accordion-header').forEach(header => {
                    header.addEventListener('click', () => {
                        const content = header.nextElementSibling;
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                });

                document.getElementById('groupRotateLeft').addEventListener('click', () => this.rotateGroup(-15));
                document.getElementById('groupRotateRight').addEventListener('click', () => this.rotateGroup(15));


                //Salvataggio Allenamenti
                document.getElementById('saveWorkOutBtn').addEventListener('click', () => this.showSaveWorkoutDialog());
                document.getElementById('loadWorkOutBtn').addEventListener('click', () => {
                    document.getElementById('workoutFileInput').click();
                });

                // ========== RIGHT SIDEBAR ==========
                const rightSidebar = document.getElementById('rightSidebar');
                const rightSidebarHandle = document.getElementById('rightSidebarHandle');
                const rightSidebarSwitch = document.getElementById('rightSidebarSwitch');

                // Toggle
                rightSidebarSwitch.onclick = function (e) {
                    e.stopPropagation();
                    e.preventDefault();

                    const isHidden = rightSidebar.classList.contains('hidden');

                    if (isHidden) {
                        // Mostra sidebar
                        rightSidebar.classList.remove('hidden');
                        this.textContent = '‚ñ∂';
                    } else {
                        // Nascondi sidebar
                        rightSidebar.classList.add('hidden');
                        this.textContent = '‚óÄ';
                    }

                    return false;
                };

                // Resize
                let isResizingRightSidebar = false;
                let rightSidebarOriginalWidth = null;

                rightSidebarHandle.onmousedown = function (e) {
                    if (e.target === rightSidebarSwitch) return;

                    e.preventDefault();

                    // Salva la larghezza corrente prima del resize
                    if (!rightSidebar.classList.contains('hidden')) {
                        rightSidebarOriginalWidth = rightSidebar.offsetWidth;
                    }

                    isResizingRightSidebar = true;
                    document.body.classList.add('resizing-sidebar');

                    const startX = e.clientX;
                    const startWidth = rightSidebar.offsetWidth;

                    function onMouseMove(e) {
                        if (!isResizingRightSidebar) return;
                        const newWidth = startWidth - (e.clientX - startX);
                        const minWidth = 200;
                        const maxWidth = window.innerWidth / 2;
                        if (newWidth >= minWidth && newWidth <= maxWidth) {
                            rightSidebar.style.width = newWidth + 'px';
                            rightSidebarOriginalWidth = newWidth;
                        }
                    }

                    function onMouseUp() {
                        isResizingRightSidebar = false;
                        document.body.classList.remove('resizing-sidebar');
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    }

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };

                // Workout details event listeners
                document.getElementById('workoutPeriodo').addEventListener('change', (e) => {
                    this.getCurrentTab().periodo = e.target.value;
                });
                document.getElementById('workoutRuolo').addEventListener('change', (e) => {
                    this.getCurrentTab().ruolo = e.target.value;
                });
                document.getElementById('workoutTipologia').addEventListener('change', (e) => {
                    this.getCurrentTab().tipologia = e.target.value;
                });
                document.getElementById('workoutDescrizione').addEventListener('input', (e) => {
                    this.getCurrentTab().descrizione = e.target.value;
                });
                document.getElementById('workoutGenere').addEventListener('change', (e) => {
                    this.getCurrentTab().genere = e.target.value;
                    this.filterCategoriesByGenere(e.target.value); // Filtra le categorie
                });
                document.getElementById('workoutCategoria').addEventListener('change', (e) => {
                    this.getCurrentTab().categoria = e.target.value;
                });
                document.getElementById('workoutDescrizione').addEventListener('input', (e) => {
                    this.getCurrentTab().descrizione = e.target.value;
                });
                // ========== LEFT SIDEBAR ==========
                const sidebar = document.getElementById('sidebar');
                const sidebarHandle = document.getElementById('sidebarHandle');
                const sidebarSwitch = document.getElementById('sidebarSwitch');

                // Toggle
                sidebarSwitch.onclick = function (e) {
                    e.stopPropagation();
                    e.preventDefault();

                    const isHidden = sidebar.classList.contains('hidden');

                    if (isHidden) {
                        // Mostra sidebar
                        sidebar.classList.remove('hidden');
                        this.textContent = '‚óÄ';
                    } else {
                        // Nascondi sidebar
                        sidebar.classList.add('hidden');
                        this.textContent = '‚ñ∂';
                    }

                    return false;
                };

                // Resize
                let isResizingSidebar = false;
                let sidebarOriginalWidth = null;

                sidebarHandle.onmousedown = function (e) {
                    if (e.target === sidebarSwitch) return;

                    e.preventDefault();

                    // Salva la larghezza corrente prima del resize
                    if (!sidebar.classList.contains('hidden')) {
                        sidebarOriginalWidth = sidebar.offsetWidth;
                    }

                    isResizingSidebar = true;
                    document.body.classList.add('resizing-sidebar');

                    const startX = e.clientX;
                    const startWidth = sidebar.offsetWidth;

                    function onMouseMove(e) {
                        if (!isResizingSidebar) return;
                        const newWidth = startWidth + (e.clientX - startX);
                        const minWidth = 150;
                        const maxWidth = window.innerWidth / 2;
                        if (newWidth >= minWidth && newWidth <= maxWidth) {
                            sidebar.style.width = newWidth + 'px';
                            sidebarOriginalWidth = newWidth;
                        }
                    }

                    function onMouseUp() {
                        isResizingSidebar = false;
                        document.body.classList.remove('resizing-sidebar');
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    }

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };



                // ========== BOTTOM SIDEBAR (Object Controls) ==========
                const bottomSidebar = document.getElementById('bottomSidebar');
                const bottomSidebarHandle = document.getElementById('bottomSidebarHandle');
                const bottomSidebarSwitch = document.getElementById('bottomSidebarSwitch');

                // Toggle
                bottomSidebarSwitch.onclick = function (e) {
                    e.stopPropagation();
                    e.preventDefault();

                    const isHidden = bottomSidebar.classList.contains('hidden');

                    if (isHidden) {
                        bottomSidebar.classList.remove('hidden');
                        this.textContent = '‚ñº';
                    } else {
                        bottomSidebar.classList.add('hidden');
                        this.textContent = '‚ñ≤';
                    }

                    return false;
                };

                // Resize
                let isResizingBottomSidebar = false;
                let bottomSidebarOriginalHeight = null;

                bottomSidebarHandle.onmousedown = function (e) {
                    if (e.target === bottomSidebarSwitch) return;

                    e.preventDefault();

                    if (!bottomSidebar.classList.contains('hidden')) {
                        bottomSidebarOriginalHeight = bottomSidebar.offsetHeight;
                    }

                    isResizingBottomSidebar = true;
                    document.body.classList.add('resizing-bottom-sidebar');

                    const startY = e.clientY;
                    const startHeight = bottomSidebar.offsetHeight;

                    function onMouseMove(e) {
                        if (!isResizingBottomSidebar) return;
                        const newHeight = startHeight - (e.clientY - startY);
                        const minHeight = 100;
                        const maxHeight = window.innerHeight / 2;
                        if (newHeight >= minHeight && newHeight <= maxHeight) {
                            bottomSidebar.style.height = newHeight + 'px';
                            bottomSidebarOriginalHeight = newHeight;
                        }
                    }

                    function onMouseUp() {
                        isResizingBottomSidebar = false;
                        document.body.classList.remove('resizing-bottom-sidebar');
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    }

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };




                // Event listeners per il popup di salvataggio workout
                document.getElementById('closeSaveWorkout').addEventListener('click', () => {
                    document.getElementById('saveWorkoutModal').style.display = 'none';
                });

                document.getElementById('cancelSaveWorkout').addEventListener('click', () => {
                    document.getElementById('saveWorkoutModal').style.display = 'none';
                });

                document.getElementById('confirmSaveWorkout').addEventListener('click', () => {
                    this.confirmSaveWorkout();
                });

                // Chiudi il modal cliccando fuori
                window.addEventListener('click', (event) => {
                    const modal = document.getElementById('saveWorkoutModal');
                    if (event.target === modal) {
                        modal.style.display = 'none';
                    }
                });

                // Permetti di salvare premendo Enter
                document.getElementById('workoutFileName').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.confirmSaveWorkout();
                    }
                });

                // Event listener per il caricamento workout
                document.getElementById('workoutFileInput').addEventListener('change', (e) => this.loadWorkout(e));

                document.getElementById('freehandModeBtn').addEventListener('click', (e) => {
                    this.freehandMode = !this.freehandMode;
                    e.currentTarget.classList.toggle('active', this.freehandMode);
                    document.getElementById('canvas').style.cursor = this.freehandMode ? 'crosshair' : 'default';
                    this.deselectAll();
                });

                document.getElementById('freehandColor').addEventListener('change', (e) => {
                    this.changeFreehandColor(e.target.value);
                });

                const freehandThicknessInput = document.getElementById('freehandThickness');
                freehandThicknessInput.addEventListener('input', (e) => {
                    document.getElementById('freehandThicknessValue').textContent = e.target.value;
                    if (this.selectedFreehand) {
                        this.changeFreehandThickness(e.target.value);
                    }
                });

                // Opacit√† per oggetti
                const objectOpacityInput = document.getElementById('objectOpacity');
                objectOpacityInput.addEventListener('input', (e) => {
                    document.getElementById('objectOpacityValue').textContent = parseFloat(e.target.value).toFixed(2);
                    this.changeSelectedObjectsOpacity(e.target.value);
                });

                // Opacit√† per disegni a mano libera
                const freehandOpacityInput = document.getElementById('freehandOpacity');
                freehandOpacityInput.addEventListener('input', (e) => {
                    document.getElementById('freehandOpacityValue').textContent = parseFloat(e.target.value).toFixed(2);
                    if (this.selectedFreehand) {
                        this.changeFreehandOpacity(e.target.value);
                    }
                });

                const snapButton = document.getElementById('snapToGridBtn');
                if (snapButton) {
                    snapButton.addEventListener('click', () => {
                        // Chiama la funzione di allineamento sulla griglia
                        if (window.editor && window.editor.snapObjectsToGrid) {
                            window.editor.snapObjectsToGrid();
                        }
                    });
                }
                // Nel canvas, aggiungi context menu per azioni globali
                canvas.addEventListener('contextmenu', (e) => {
                    // Se click su canvas vuoto (non su oggetti)
                    if (e.target === canvas || e.target.classList.contains('canvas')) {
                        e.preventDefault();
                        this.showCanvasContextMenu(e);
                    }
                });

                document.getElementById('spriteCurrentFrame').addEventListener('change', (e) => {
                    this.changeSpriteFrame(parseInt(e.target.value));
                });

                document.getElementById('spritePlayAnimation').addEventListener('click', () => {
                    this.playSpriteAnimation();
                });

                document.getElementById('spriteStopAnimation').addEventListener('click', () => {
                    this.stopSpriteAnimation();
                });

                document.getElementById('spriteApplySize').addEventListener('click', () => {
                    this.applySpriteFrameSize();
                });

                document.getElementById('spriteAnimationFPS').addEventListener('input', (e) => {
                    // Se l'animazione √® gi√† in corso, riavviala con il nuovo FPS
                    if (this.selectedObject && this.getCurrentTab().objects.get(this.selectedObject.id)?.animationInterval) {
                        this.playSpriteAnimation();
                    }
                });

                document.getElementById('addFrameBtn').addEventListener('click', () => this.addFrame());
                document.getElementById('updateFrameBtn').addEventListener('click', () => this.updateFrame());
                document.getElementById('deleteFrameBtn').addEventListener('click', () => this.deleteFrame());

                document.getElementById('animationPlay').addEventListener('click', () => this.playAnimation());
                document.getElementById('animationPause').addEventListener('click', () => this.pauseAnimation());
                document.getElementById('animationStop').addEventListener('click', () => this.stopAnimation());
                document.getElementById('animationPrevFrame').addEventListener('click', () => this.previousFrame());
                document.getElementById('animationNextFrame').addEventListener('click', () => this.nextFrame());

                // document.getElementById('showAnimationControls').addEventListener('click', () => {
                //     const animControls = document.getElementById('animationControls');
                //     const isVisible = animControls.style.display === 'block';
                //     if (isVisible) {
                //         animControls.style.display = 'none';
                //     } else {
                //         this.showAnimationControls();
                //     }
                // });
                this.initAnimationDialog();

                document.getElementById('showAnimationControls').addEventListener('click', () => {
                    this.showAnimationControls();
                });

                document.getElementById('addStepBtn').addEventListener('click', () => this.addStep());

                document.getElementById('newStepInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.addStep();
                    }
                });

                document.getElementById('toggleLabels').addEventListener('click', () => {
                    this.toggleObjectLabels();
                });

                document.getElementById('generateAISteps').addEventListener('click', () => {
                    //this.generateAISteps();
                    this.generateBasicSteps();
                });

                document.getElementById('objectNumber').addEventListener('input', (e) => {
                    this.changeSelectedObjectsNumber(parseInt(e.target.value));
                });
                document.getElementById('renumberObjects').addEventListener('click', () => {
                    this.renumberAllObjects();
                });

                document.getElementById('workoutTiming').addEventListener('input', (e) => {
                    this.getCurrentTab().timing = parseInt(e.target.value) || 10;
                });
                document.getElementById('workoutRec').addEventListener('input', (e) => {
                    this.getCurrentTab().rec = parseInt(e.target.value) || 60;
                });


                document.getElementById('workoutSeries').addEventListener('input', (e) => {
                    this.getCurrentTab().series = parseInt(e.target.value) || 1;
                });
                document.getElementById('workoutNr').addEventListener('input', (e) => {
                    this.getCurrentTab().nr = parseInt(e.target.value) || 1;
                });
                document.getElementById('exportFormationsBtn').addEventListener('click', () => {
                    this.exportFormationSheet();
                });

                // Gestione squadra
                document.getElementById('manageTeamBtn').addEventListener('click', () => {
                    this.showTeamDialog();
                });

                document.getElementById('closeTeamDialog').addEventListener('click', () => {
                    this.hideTeamDialog();
                });

                document.getElementById('addPlayerBtn').addEventListener('click', () => {
                    this.addTeamPlayer();
                });

                document.getElementById('exportTeamBtn').addEventListener('click', () => {
                    this.exportTeam();
                });

                document.getElementById('importTeamBtn').addEventListener('click', () => {
                    document.getElementById('importTeamFile').click();
                });

                document.getElementById('importTeamFile').addEventListener('change', (e) => {
                    this.importTeam(e);
                });

                document.getElementById('clearTeamBtn').addEventListener('click', () => {
                    this.clearTeam();
                });

                document.getElementById('togglePlayerNames').addEventListener('click', () => {
                    this.togglePlayerNames();
                });

                document.getElementById('canvasSizeSelect').addEventListener('change', (e) => {
                    this.setCanvasSize(e.target.value);
                });

                document.getElementById('toggleCanvasBorder').addEventListener('click', () => {
                    this.toggleCanvasBorder();
                });

                // AGGIUNGI QUESTO BLOCCO
                this.initHistoryDialog();

                // Aggiungi listener per aprire lo storico (puoi usare Ctrl+H o un pulsante)
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'h') {
                        e.preventDefault();
                        this.showHistoryDialog();
                    }
                });

                // Rendi draggable il team dialog
                this.initTeamDialogDrag();

                this.initTabDragDrop();
                // E aggiungi il listener
                document.getElementById('historyBtn').addEventListener('click', () => {
                    this.showHistoryDialog();
                });

                // ‚úÖ NUOVO: Doppio click per toggle sidebar
                rightSidebarHandle.addEventListener('dblclick', () => {
                    rightSidebarSwitch.click();
                });

                // ‚úÖ NUOVO: Doppio click per toggle sidebar sinistra
                sidebarHandle.addEventListener('dblclick', () => {
                    sidebarSwitch.click();
                });

                // ‚úÖ NUOVO: Doppio click per toggle bottom sidebar
                bottomSidebarHandle.addEventListener('dblclick', () => {
                    bottomSidebarSwitch.click();
                });

            }

            initTeamDialogDrag() {
                const dialog = document.getElementById('teamDialog');
                const header = document.getElementById('teamDialogHeader');

                let isDragging = false;
                let currentX = 0;
                let currentY = 0;
                let initialX = 0;
                let initialY = 0;

                header.addEventListener('mousedown', (e) => {
                    const rect = dialog.getBoundingClientRect();
                    initialX = e.clientX - rect.left;
                    initialY = e.clientY - rect.top;
                    isDragging = true;
                    header.style.cursor = 'grabbing';
                    dialog.style.transform = 'none';
                    dialog.style.left = rect.left + 'px';
                    dialog.style.top = rect.top + 'px';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    dialog.style.left = currentX + 'px';
                    dialog.style.top = currentY + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        header.style.cursor = 'move';
                    }
                });
            }

            showCanvasContextMenu(e) {
                this.hideContextMenu();

                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.id = 'contextMenu';

                const menuItems = [
                    { label: 'üìã Incolla', action: () => this.paste(), shortcut: 'Ctrl+V', disabled: !this.clipboard },
                    { separator: true },
                    { label: 'üîÑ Seleziona tutto', action: () => this.selectAll(), shortcut: 'Ctrl+A' },
                    { separator: true },
                    { label: '‚Ü∂ Annulla', action: () => this.undo(), shortcut: 'Ctrl+Z' },
                    { label: '‚Ü∑ Ripeti', action: () => this.redo(), shortcut: 'Ctrl+Y' }
                ];

                menuItems.forEach(item => {
                    if (item.separator) {
                        const separator = document.createElement('div');
                        separator.className = 'context-menu-separator';
                        menu.appendChild(separator);
                    } else {
                        const menuItem = document.createElement('div');
                        menuItem.className = 'context-menu-item' + (item.disabled ? ' disabled' : '');
                        menuItem.innerHTML = `
                <span>${item.label}</span>
                ${item.shortcut ? `<span style="margin-left: auto; opacity: 0.6; font-size: 11px;">${item.shortcut}</span>` : ''}
            `;
                        if (!item.disabled) {
                            menuItem.addEventListener('click', () => {
                                item.action();
                                this.hideContextMenu();
                            });
                        }
                        menu.appendChild(menuItem);
                    }
                });

                document.body.appendChild(menu);

                // Posizionamento
                const menuRect = menu.getBoundingClientRect();
                let left = e.clientX;
                let top = e.clientY;

                if (left + menuRect.width > window.innerWidth) {
                    left = window.innerWidth - menuRect.width - 5;
                }
                if (top + menuRect.height > window.innerHeight) {
                    top = window.innerHeight - menuRect.height - 5;
                }

                menu.style.left = left + 'px';
                menu.style.top = top + 'px';

                setTimeout(() => {
                    document.addEventListener('click', this.hideContextMenu.bind(this), { once: true });
                    document.addEventListener('contextmenu', this.hideContextMenu.bind(this), { once: true });
                }, 0);
            }

            handleCanvasDrop(e) {
                e.preventDefault();

                let data;
                try {
                    const rawData = e.dataTransfer.getData('text/plain');
                    if (!rawData) {
                        console.error('Nessun dato nel drag');
                        return;
                    }
                    data = JSON.parse(rawData);
                } catch (error) {
                    console.error('Errore nel parsing dei dati drag:', error);
                    return;
                }

                const rect = e.currentTarget.getBoundingClientRect();
                let x = (e.clientX - rect.left) / this.getCurrentTab().zoom;
                let y = (e.clientY - rect.top) / this.getCurrentTab().zoom;

                // Se il drag ha un offset salvato (es. mouse preso al centro dell'oggetto)
                if (data.offsetX !== undefined && data.offsetY !== undefined) {
                    x -= data.offsetX / this.getCurrentTab().zoom;
                    y -= data.offsetY / this.getCurrentTab().zoom;
                }

                if (data.type === 'sprite') {
                    const spriteData = {
                        sheet: data.spriteSheet,
                        cols: data.spriteCols,
                        rows: data.spriteRows,
                        frame: data.spriteFrame,
                        frameWidth: data.spriteWidth,
                        frameHeight: data.spriteHeight
                    };
                    this.addObject(data.type, x, y, data.color, data.text, 0, this.dashedMode, null, null, spriteData);
                } else if (data.type === 'icon') {
                    this.addObject(data.type, x, y, data.color, data.text, 0, this.dashedMode, data.icon);
                } else if (data.type === 'local-svg') {
                    this.addObject(data.type, x, y, data.color, data.text, 0, this.dashedMode, null, data.src);
                } else {
                    this.addObject(data.type, x, y, data.color, data.text);
                }
            }

            rotateGroup(degrees) {
                if (this.selectedObjects.size <= 1) return;

                const bounds = this.getGroupBounds();
                const centerX = bounds.centerX;
                const centerY = bounds.centerY;
                const radians = degrees * (Math.PI / 180);

                const tab = this.getCurrentTab();

                this.selectedObjects.forEach((pos, id) => {
                    const obj = tab.objects.get(id);
                    if (obj) {
                        const dx = obj.x - centerX;
                        const dy = obj.y - centerY;

                        const rotatedX = dx * Math.cos(radians) - dy * Math.sin(radians);
                        const rotatedY = dx * Math.sin(radians) + dy * Math.cos(radians);

                        obj.x = centerX + rotatedX;
                        obj.y = centerY + rotatedY;
                        obj.rotation = (obj.rotation + degrees) % 360;

                        const element = document.getElementById(id);
                        element.style.left = obj.x + 'px';
                        element.style.top = obj.y + 'px';
                        element.style.transform = `rotate(${obj.rotation}deg)`;

                        this.updateArrowsForObject(id);
                    }
                });

                this.showGroupRotationCenter(); // Riposiziona il centro di rotazione
                this.saveState(`Ruotati ${this.selectedObjects.size} oggetti di ${degrees}¬∞`);
            }

            addObject(type, x, y, color = '#3498db', text = '', rotation = 0, dashed = this.dashedMode, icon = null, src = null, spriteData = null) {
                const tab = this.getCurrentTab();
                const id = 'obj-' + tab.nextObjectId++;

                const objectNumber = tab.objects.size + 1;

                const object = {
                    id: id,
                    type: type,
                    x: x,
                    y: y,
                    width: this.getDefaultSize(type).width,
                    height: this.getDefaultSize(type).height,
                    color: color,
                    rotation: rotation,
                    text: text,
                    dashed: dashed,
                    opacity: 1,
                    zIndex: this.maxZIndex++, // USA maxZIndex globale
                    icon: icon,
                    src: src,
                    spriteData: spriteData,
                    animations: [],
                    currentAnimationFrame: 0,
                    objectNumber: objectNumber
                };

                tab.objects.set(id, object);

                // AGGIORNA maxZIndex del tab
                tab.maxZIndex = this.maxZIndex;

                this.renderObject(object);
                this.saveState(`Aggiunto oggetto ${object.type} con ID ${object.id}`);

                return object;
            }

            getDefaultSize(type) {
                const sizes = {
                    'player': { width: 40, height: 40 },
                    'ball': { width: 20, height: 20 },
                    'cone': { width: 20, height: 20 },
                    'goal': { width: 60, height: 40 },
                    'net': { width: 300, height: 40 },
                    'text': { width: 100, height: 30 },
                    'court': { width: 250, height: 500 },
                    'half-court': { width: 250, height: 250 },
                    'icon': { width: 40, height: 40 },
                    'mat': { width: 120, height: 40 },
                    'local-svg': { width: 60, height: 60 },
                    'sprite': { width: 64, height: 64 },
                    'brick': { width: 250, height: 10 },
                };
                return sizes[type] || { width: 40, height: 40 };
            }

            renderObject(object) {
                let element = document.getElementById(object.id);
                if (!element) {
                    element = document.createElement('div');
                    element.className = 'canvas-object';
                    element.id = object.id;

                    element.setAttribute('draggable', false);
                    element.addEventListener('dragstart', (e) => e.preventDefault());

                    document.getElementById('canvas').appendChild(element);
                }

                // Clona l'elemento per rimuovere tutti gli event listener
                const newElement = element.cloneNode(false);
                element.parentNode.replaceChild(newElement, element);
                element = newElement;

                element.style.left = object.x + 'px';
                element.style.top = object.y + 'px';
                element.style.width = object.width + 'px';
                element.style.height = object.height + 'px';
                element.style.transform = `rotate(${object.rotation}deg)`;
                element.style.zIndex = object.zIndex || 1;
                element.style.opacity = object.opacity || 1;
                element.classList.toggle('dashed', object.dashed);

                element.innerHTML = '';
                const content = this.createObjectContent(object);
                element.appendChild(content);

                this.resizeContent(element, object.width, object.height, object.type);
                this.addControlHandles(element);
                this.addConnectionPoints(element);
                this.addObjectLabel(element, object);
                element.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!this.selectedObjects.has(object.id)) {
                        this.selectObject(element);
                    }
                    this.showContextMenu(e, object.id, 'object');
                });

                element.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    this.startInlineEdit(object.id);
                });

                element.setAttribute('draggable', false);
                element.addEventListener('dragstart', (e) => e.preventDefault());
            }


            bringToFront() {
                if (this.selectedObjects.size === 0) return;

                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (objectData) {
                        objectData.zIndex = ++this.maxZIndex;
                        document.getElementById(id).style.zIndex = objectData.zIndex;
                    }
                });
                this.saveState(`Portati in primo piano ${this.selectedObjects.size} oggetti`);
            }

            sendToBack() {
                if (this.selectedObjects.size === 0) return;

                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (objectData) {
                        objectData.zIndex = 0;
                        document.getElementById(id).style.zIndex = objectData.zIndex;
                    }
                });
                this.saveState(`Portati in secondo piano ${this.selectedObjects.size} oggetti`);
            }


            createObjectContent(object) {
                const content = document.createElement('div');
                content.className = object.type + '-object';
                if (object.type === 'player' && object.text) {
                    const player = this.getPlayerByRole(object.text);
                    if (player) {
                        const badge = document.createElement('div');
                        badge.className = 'player-name-badge';
                        badge.textContent = `${player.name} (#${player.number})`;
                        content.appendChild(badge);
                    }
                }
                if (object.type === 'sprite' && object.spriteData) {
                    const sprite = object.spriteData;
                    const frameX = (sprite.frame % sprite.cols) * sprite.frameWidth;
                    const frameY = Math.floor(sprite.frame / sprite.cols) * sprite.frameHeight;

                    content.style.background = `url('${sprite.sheet}')`;
                    content.style.backgroundPosition = `-${frameX}px -${frameY}px`;
                    content.style.backgroundSize = `${sprite.cols * sprite.frameWidth}px ${sprite.rows * sprite.frameHeight}px`;
                    content.style.width = '100%';
                    content.style.height = '100%';
                    content.style.backgroundRepeat = 'no-repeat';

                    return content;
                }
                // Gestione speciale per le icone
                if (object.type === 'icon') {
                    content.innerHTML = `<i class="${object.icon}"></i>`;
                    content.style.color = object.color;
                    content.classList.toggle('dashed', object.dashed);

                    // Imposta la dimensione iniziale dell'icona
                    const icon = content.querySelector('i');
                    if (icon) {
                        const minDimension = Math.min(object.width, object.height);
                        const fontSize = Math.max(12, minDimension * 0.6);
                        icon.style.fontSize = `${fontSize}px`;
                    }

                    return content;
                }

                if (object.type === 'local-svg') {
                    content.innerHTML = `<img src="${object.src}" alt="${object.alt || ''}" />`;
                    content.style.color = object.color;
                    content.classList.toggle('dashed', object.dashed);

                    // Imposta la dimensione iniziale dell'SVG
                    const img = content.querySelector('img');
                    if (img) {
                        const minDimension = Math.min(object.width, object.height);
                        const size = Math.max(12, minDimension * 0.6);
                        img.style.width = `${size}px`;
                        img.style.height = `${size}px`;
                    }

                    return content;
                }

                if (object.type !== 'ball' && object.type !== 'net' && object.type !== 'goal') {
                    const editableDiv = document.createElement('div');
                    editableDiv.classList.add('editable-text');
                    editableDiv.textContent = object.text;
                    editableDiv.contentEditable = 'false';
                    editableDiv.style.color = 'black';
                    content.appendChild(editableDiv);

                    editableDiv.addEventListener('input', () => {
                        object.text = editableDiv.textContent;
                    });
                }

                switch (object.type) {
                    case 'player':
                        content.style.backgroundColor = object.color;
                        content.classList.toggle('dashed', object.dashed);
                        break;
                    case 'cone':
                        content.style.backgroundColor = object.color;
                        content.classList.toggle('dashed', object.dashed);
                        break;
                    case 'goal':
                        content.style.borderColor = object.color;
                        content.classList.toggle('dashed', object.dashed);
                        break;
                    case 'net':
                        content.classList.toggle('dashed', object.dashed);
                        break;
                }

                return content;
            }

            startInlineEdit(objectId) {
                const objectElement = document.getElementById(objectId);
                if (!objectElement) return;

                const editableText = objectElement.querySelector('.editable-text');
                if (editableText) {
                    editableText.contentEditable = 'true';
                    editableText.focus();
                    this.deselectAll();

                    editableText.addEventListener('blur', () => {
                        editableText.contentEditable = 'false';
                        this.saveState(`Modificato testo oggetto ${objectId} a "${editableText.textContent}"`);
                        this.selectObject(objectElement);
                    }, { once: true });
                }
            }

            resizeContent(element, width, height, type) {
                const content = element.querySelector(`.${type}-object`);
                if (!content) return;
                if (type === 'sprite') {
                    // Gli sprite mantengono le proporzioni tramite background-size
                    // Non serve ridimensionare manualmente, il CSS lo gestisce
                    return;
                }
                if (type === 'icon') {
                    const icon = content.querySelector('i');
                    if (icon) {
                        const minDimension = Math.min(width, height);
                        let fontSize = minDimension * 0.6;
                        fontSize = Math.max(8, fontSize);
                        fontSize = Math.min(100, fontSize);
                        icon.style.fontSize = `${fontSize}px`;
                    }
                } else if (type === 'local-svg') {
                    const img = content.querySelector('img');
                    if (img) {
                        const minDimension = Math.min(width, height);
                        let size = minDimension * 0.8;
                        size = Math.max(12, size);
                        size = Math.min(150, size);
                        img.style.width = `${size}px`;
                        img.style.height = `${size}px`;
                        img.style.objectFit = 'contain';
                    }
                } else {
                    const editableText = content.querySelector('.editable-text');
                    if (editableText) {
                        const initialWidth = this.getDefaultSize(type).width;
                        const initialHeight = this.getDefaultSize(type).height;
                        const scaleFactor = Math.min(width / initialWidth, height / initialHeight);
                        const newFontSize = 14 * scaleFactor;
                        editableText.style.fontSize = `${newFontSize}px`;
                    }
                }
            }

            addControlHandles(element) {
                let resizeHandle = element.querySelector('.resize-handle');
                if (!resizeHandle) {
                    resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    element.appendChild(resizeHandle);
                }
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.startResize(element, e);
                });

                let rotateHandle = element.querySelector('.rotate-handle');
                if (!rotateHandle) {
                    rotateHandle = document.createElement('div');
                    rotateHandle.className = 'rotate-handle';
                    element.appendChild(rotateHandle);
                }
                rotateHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.startRotation(element, e);
                });
            }

            // Modifica il metodo addConnectionPoints nella classe SchemaEditor

            addConnectionPoints(element) {
                const positions = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];

                positions.forEach(pos => {
                    let point = element.querySelector(`.connection-point.${pos}`);
                    if (!point) {
                        point = document.createElement('div');
                        point.className = `connection-point ${pos}`;
                        element.appendChild(point);
                    }

                    // MODIFICA: Rimuovi il vecchio listener e aggiungi quello nuovo
                    const newPoint = point.cloneNode(true);
                    point.parentNode.replaceChild(newPoint, point);

                    newPoint.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        this.startConnection({ objectId: element.id, position: pos }, e);
                    });

                    newPoint.style.pointerEvents = 'auto';
                });
            }

            handleCanvasMouseDown(e) {
                if (this.freehandMode) {
                    this.startFreehand(e);
                    return;
                }

                const freehandPath = e.target.closest('.freehand-path');
                if (freehandPath) {
                    this.selectFreehand(freehandPath.closest('.freehand-svg').id);
                    return;
                }
                if (e.target.closest('.resize-handle') || e.target.closest('.rotate-handle') || e.target.closest('.connection-point')) {
                    return;
                }

                if (this.arrowMode) {
                    this.startConnection({ objectId: null, position: { x: (e.clientX - e.currentTarget.getBoundingClientRect().left) / this.getCurrentTab().zoom, y: (e.clientY - e.currentTarget.getBoundingClientRect().top) / this.getCurrentTab().zoom } }, e);
                    return;
                }

                const target = e.target.closest('.canvas-object');
                const arrowPath = e.target.closest('.arrow-path');
                const arrowControlPoint = e.target.closest('.control-point');
                const groupRotationCenter = e.target.closest('.group-rotation-center');

                if (groupRotationCenter) {
                    e.stopPropagation();
                    this.startGroupRotation(e);
                } else if (arrowControlPoint) {
                    e.stopPropagation();
                    this.isDraggingControlPoint = true;
                    this.selectedArrow = arrowControlPoint.closest('.arrow-svg').id;
                } else if (target) {
                    if (e.ctrlKey || e.metaKey) {
                        this.toggleMultiSelection(target);
                    } else if (!this.selectedObjects.has(target.id)) {
                        this.selectObject(target);
                    }
                    this.startDrag(e);
                } else if (arrowPath) {
                    this.selectArrow(arrowPath.closest('.arrow-svg').id);
                } else {
                    // Solo se non stiamo cliccando su nessun oggetto, inizia la selezione ad area
                    if (e.target === document.getElementById('canvas') || e.target.classList.contains('canvas')) {
                        this.deselectAll();
                        this.startAreaSelection(e);
                    }
                }
            }
            handleGroupRotation(e) {
                if (!this.groupRotationData) return;

                const currentAngle = Math.atan2(
                    e.clientY - this.groupRotationData.centerY,
                    e.clientX - this.groupRotationData.centerX
                );

                const deltaAngle = currentAngle - this.groupRotationData.startAngle;
                const degrees = deltaAngle * (180 / Math.PI);

                const tab = this.getCurrentTab();
                const centerX = this.groupRotationData.centerX;
                const centerY = this.groupRotationData.centerY;

                this.groupRotationData.initialPositions.forEach((initialPos, id) => {
                    const obj = tab.objects.get(id);
                    if (obj) {
                        // Ruota la posizione dell'oggetto attorno al centro del gruppo
                        const dx = initialPos.x - centerX;
                        const dy = initialPos.y - centerY;

                        const rotatedX = dx * Math.cos(deltaAngle) - dy * Math.sin(deltaAngle);
                        const rotatedY = dx * Math.sin(deltaAngle) + dy * Math.cos(deltaAngle);

                        obj.x = centerX + rotatedX;
                        obj.y = centerY + rotatedY;
                        obj.rotation = (initialPos.rotation + degrees) % 360;

                        // Aggiorna l'elemento visuale
                        const element = document.getElementById(id);
                        element.style.left = obj.x + 'px';
                        element.style.top = obj.y + 'px';
                        element.style.transform = `rotate(${obj.rotation}deg)`;

                        this.updateArrowsForObject(id);
                    }
                });
            }

            handleCanvasMouseMove(e) {
                if (this.isDrawing && this.freehandMode) {
                    this.continueFreehand(e);
                    return;
                }

                if (this.isDraggingControlPoint && this.selectedArrow) {
                    const arrow = this.getCurrentTab().arrows.get(this.selectedArrow);
                    if (arrow) {
                        const rect = document.getElementById('canvas').getBoundingClientRect();
                        const newX = (e.clientX - rect.left) / this.getCurrentTab().zoom;
                        const newY = (e.clientY - rect.top) / this.getCurrentTab().zoom;

                        arrow.controlPoint = { x: newX, y: newY };
                        this.renderArrow(arrow);
                    }
                    return;
                }

                if (this.isDragging) {
                    const deltaX = (e.clientX - this.dragStart.x) / this.getCurrentTab().zoom;
                    const deltaY = (e.clientY - this.dragStart.y) / this.getCurrentTab().zoom;

                    const tab = this.getCurrentTab();

                    this.selectedObjects.forEach((initialPos, id) => {
                        const objectData = tab.objects.get(id);
                        if (objectData) {
                            objectData.x = initialPos.x + deltaX;
                            objectData.y = initialPos.y + deltaY;

                            const element = document.getElementById(id);
                            if (element) {
                                element.style.left = objectData.x + 'px';
                                element.style.top = objectData.y + 'px';
                            }
                            this.updateArrowsForObject(id);
                        }
                        else if (initialPos.type === 'freehand') {
                            const freehand = tab.freehands.get(id);
                            if (freehand) {
                                freehand.points = initialPos.points.map(p => ({
                                    x: p.x + deltaX,
                                    y: p.y + deltaY
                                }));
                                this.renderFreehand(freehand);
                            }
                        }
                    });
                } else if (this.isResizing && this.selectedObject) {
                    this.handleResize(e);
                } else if (this.isRotating && this.selectedObject) {
                    this.handleRotation(e);
                } else if (this.isRotatingGroup) {
                    this.handleGroupRotation(e);
                } else if (this.isConnecting) {
                    this.updateConnectionPreview(e);
                } else if (this.isSelecting) {
                    this.updateSelectionBox(e);
                } else if (this.isDraggingEndpoint && this.selectedArrow) {
                    const arrow = this.getCurrentTab().arrows.get(this.selectedArrow);
                    const rect = document.getElementById('canvas').getBoundingClientRect();
                    const newX = (e.clientX - rect.left) / this.getCurrentTab().zoom;
                    const newY = (e.clientY - rect.top) / this.getCurrentTab().zoom;

                    const nearbyPoint = this.findNearbyConnectionPoint(e);

                    if (nearbyPoint) {
                        if (this.draggedEndpointType === 'start') {
                            arrow.from = {
                                objectId: nearbyPoint.objectId,
                                position: nearbyPoint.position
                            };
                        } else {
                            arrow.to = {
                                objectId: nearbyPoint.objectId,
                                position: nearbyPoint.position
                            };
                        }
                        this.highlightConnectionPoint(nearbyPoint.objectId, nearbyPoint.position);
                    } else {
                        if (this.draggedEndpointType === 'start') {
                            arrow.from = { x: newX, y: newY };
                        } else {
                            arrow.to = { x: newX, y: newY };
                        }
                        this.clearConnectionPointHighlights();
                    }

                    this.renderArrow(arrow);
                }
            }


            handleCanvasMouseUp(e) {
                if (this.isDrawing && this.freehandMode) {
                    this.finishFreehand();
                }

                if (this.isDraggingEndpoint) {
                    // Verifica snap finale
                    const nearbyPoint = this.findNearbyConnectionPoint(e);
                    const arrow = this.getCurrentTab().arrows.get(this.selectedArrow);

                    if (nearbyPoint && arrow) {
                        if (this.draggedEndpointType === 'start') {
                            arrow.from = {
                                objectId: nearbyPoint.objectId,
                                position: nearbyPoint.position
                            };
                        } else {
                            arrow.to = {
                                objectId: nearbyPoint.objectId,
                                position: nearbyPoint.position
                            };
                        }
                        this.renderArrow(arrow);
                    }

                    this.clearConnectionPointHighlights();
                    this.saveState(`Modificato endpoint freccia ${this.selectedArrow}`);
                } else if (this.isConnecting) {
                    this.finishConnection(e);
                } else if (this.isDragging || this.isResizing || this.isRotating || this.isDraggingControlPoint || this.isRotatingGroup) {
                    this.saveState(`Modificato posizione oggetto${this.selectedObjects.size > 1 ? 's' : ''}`);
                    this.updateCurrentFrame();
                } else if (this.isSelecting) {
                    this.finalizeSelectionBox(e);
                }

                this.isDragging = false;
                this.isResizing = false;
                this.isRotating = false;
                this.isRotatingGroup = false;
                this.isDraggingControlPoint = false;
                this.isDraggingEndpoint = false;
                this.draggedEndpointType = null;
                this.isSelecting = false;
                this.groupRotationData = null;

                const selectionBox = document.getElementById('selectionBox');
                if (selectionBox) selectionBox.style.display = 'none';
                document.body.classList.remove('dragging-endpoint');
            }

            findNearbyConnectionPoint(event) {
                const snapDistance = 20; // pixel di distanza per lo snap
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();

                // Trova tutti i connection points
                const connectionPoints = document.querySelectorAll('.connection-point');

                for (const point of connectionPoints) {
                    const pointRect = point.getBoundingClientRect();
                    const pointCenterX = pointRect.left + pointRect.width / 2;
                    const pointCenterY = pointRect.top + pointRect.height / 2;

                    const distance = Math.sqrt(
                        Math.pow(event.clientX - pointCenterX, 2) +
                        Math.pow(event.clientY - pointCenterY, 2)
                    );

                    if (distance < snapDistance) {
                        const objectElement = point.closest('.canvas-object');
                        const position = point.classList.contains('top') ? 'top' :
                            point.classList.contains('bottom') ? 'bottom' :
                                point.classList.contains('left') ? 'left' : 'right';

                        return {
                            objectId: objectElement.id,
                            position: position,
                            element: point
                        };
                    }
                }

                return null;
            }
            highlightConnectionPoint(objectId, position) {
                // Rimuovi evidenziazioni precedenti
                this.clearConnectionPointHighlights();

                // Trova e evidenzia il punto
                const object = document.getElementById(objectId);
                if (object) {
                    const point = object.querySelector(`.connection-point.${position}`);
                    if (point) {
                        point.style.backgroundColor = '#2ecc71';
                        point.style.transform = 'scale(1.5)';
                        point.classList.add('highlighted');
                    }
                }
            }
            clearConnectionPointHighlights() {
                document.querySelectorAll('.connection-point.highlighted').forEach(point => {
                    point.style.backgroundColor = '';
                    point.style.transform = '';
                    point.classList.remove('highlighted');
                });
            }
            startAreaSelection(e) {
                this.isSelecting = true;
                const rect = document.getElementById('canvas').getBoundingClientRect();
                this.selectionStart = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                this.canvasRect = rect;
                this.createSelectionBox();
            }

            createSelectionBox() {
                let box = document.getElementById('selectionBox');
                if (!box) {
                    box = document.createElement('div');
                    box.id = 'selectionBox';
                    box.className = 'selection-box';
                    box.style.position = 'absolute';
                    box.style.border = '2px dashed #3498db';
                    box.style.backgroundColor = 'rgba(52, 152, 219, 0.1)';
                    box.style.pointerEvents = 'none';
                    box.style.zIndex = '9999';
                    box.style.display = 'none';
                    document.getElementById('canvas').appendChild(box);
                }
                box.style.display = 'block';
            }

            startDrag(e) {
                this.isDragging = true;
                this.dragStart = { x: e.clientX, y: e.clientY };

                if (!e.ctrlKey && !e.metaKey && this.selectedObject) {
                    this.selectedObjects.clear();
                    const objData = this.getCurrentTab().objects.get(this.selectedObject.id);
                    if (objData) {
                        this.selectedObjects.set(this.selectedObject.id, { x: objData.x, y: objData.y });
                    }
                }

                this.updateObjectControls();
            }

            updateSelectionBox(e) {
                const box = document.getElementById('selectionBox');
                if (!box) return;

                const rect = document.getElementById('canvas').getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                const left = Math.min(this.selectionStart.x, currentX);
                const top = Math.min(this.selectionStart.y, currentY);
                const width = Math.abs(this.selectionStart.x - currentX);
                const height = Math.abs(this.selectionStart.y - currentY);

                box.style.left = `${left}px`;
                box.style.top = `${top}px`;
                box.style.width = `${width}px`;
                box.style.height = `${height}px`;
            }

            finalizeSelectionBox(e) {
                const box = document.getElementById('selectionBox');
                if (!box) return;

                const rect = document.getElementById('canvas').getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                const zoom = this.getCurrentTab().zoom;
                const selectionRect = {
                    left: Math.min(this.selectionStart.x, currentX) / zoom,
                    top: Math.min(this.selectionStart.y, currentY) / zoom,
                    right: Math.max(this.selectionStart.x, currentX) / zoom,
                    bottom: Math.max(this.selectionStart.y, currentY) / zoom
                };

                const tab = this.getCurrentTab();
                this.deselectAll();

                // Controlla oggetti
                tab.objects.forEach((objData, objId) => {
                    const objLeft = objData.x;
                    const objTop = objData.y;
                    const objRight = objData.x + objData.width;
                    const objBottom = objData.y + objData.height;

                    if (objLeft < selectionRect.right && objRight > selectionRect.left &&
                        objTop < selectionRect.bottom && objBottom > selectionRect.top) {

                        this.selectedObjects.set(objId, { x: objData.x, y: objData.y });
                        const element = document.getElementById(objId);
                        if (element) {
                            element.classList.add('selected', 'group-selected');
                        }
                    }
                });

                // AGGIUNTO: Controlla disegni a mano libera
                tab.freehands.forEach((freehand, freehandId) => {
                    const xs = freehand.points.map(p => p.x);
                    const ys = freehand.points.map(p => p.y);
                    const fhLeft = Math.min(...xs);
                    const fhTop = Math.min(...ys);
                    const fhRight = Math.max(...xs);
                    const fhBottom = Math.max(...ys);

                    if (fhLeft < selectionRect.right && fhRight > selectionRect.left &&
                        fhTop < selectionRect.bottom && fhBottom > selectionRect.top) {

                        // Memorizza il freehand come selezionato
                        this.selectedObjects.set(freehandId, {
                            type: 'freehand',
                            points: freehand.points
                        });

                        const svg = document.getElementById(freehandId);
                        if (svg) {
                            const path = svg.querySelector('.freehand-path');
                            if (path) path.classList.add('selected');
                        }
                    }
                });

                box.style.display = 'none';

                if (this.selectedObjects.size > 1) {
                    this.showGroupRotationCenter();
                }

                this.updateObjectControls();
            }

            startResize(element, e) {
                this.isResizing = true;
                this.selectedObject = element;
                this.resizeStart = {
                    x: e.clientX,
                    y: e.clientY,
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
            }
            showGroupRotationCenter() {
                this.hideGroupRotationCenter();

                if (this.selectedObjects.size <= 1) return;

                const bounds = this.getGroupBounds();
                const centerX = bounds.centerX;
                const centerY = bounds.centerY;

                const center = document.createElement('div');
                center.className = 'group-rotation-center';
                center.id = 'groupRotationCenter';
                center.style.position = 'absolute';
                center.style.left = `${centerX - 6}px`;
                center.style.top = `${centerY - 6}px`;
                center.style.width = '12px';
                center.style.height = '12px';
                center.style.background = '#e74c3c';
                center.style.border = '2px solid white';
                center.style.borderRadius = '50%';
                center.style.cursor = 'grab';
                center.style.zIndex = '10000';
                center.title = 'Trascina per ruotare il gruppo';

                document.getElementById('canvas').appendChild(center);
            }

            hideGroupRotationCenter() {
                const center = document.getElementById('groupRotationCenter');
                if (center) {
                    center.remove();
                }
            }

            getGroupBounds() {
                const tab = this.getCurrentTab();
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                this.selectedObjects.forEach((pos, id) => {
                    const obj = tab.objects.get(id);
                    if (obj) {
                        minX = Math.min(minX, obj.x);
                        minY = Math.min(minY, obj.y);
                        maxX = Math.max(maxX, obj.x + obj.width);
                        maxY = Math.max(maxY, obj.y + obj.height);
                    }
                });

                return {
                    left: minX,
                    top: minY,
                    width: maxX - minX,
                    height: maxY - minY,
                    centerX: minX + (maxX - minX) / 2,
                    centerY: minY + (maxY - minY) / 2
                };
            }

            startGroupRotation(e) {
                this.isRotatingGroup = true;
                const bounds = this.getGroupBounds();
                this.groupRotationData = {
                    centerX: bounds.centerX,
                    centerY: bounds.centerY,
                    startAngle: Math.atan2(e.clientY - bounds.centerY, e.clientX - bounds.centerX),
                    initialPositions: new Map()
                };

                // Salva le posizioni iniziali di tutti gli oggetti selezionati
                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const obj = tab.objects.get(id);
                    if (obj) {
                        this.groupRotationData.initialPositions.set(id, {
                            x: obj.x,
                            y: obj.y,
                            rotation: obj.rotation
                        });
                    }
                });
            }

            handleResize(e) {
                if (!this.isResizing) return;

                const deltaX = (e.clientX - this.resizeStart.x) / this.getCurrentTab().zoom;
                const deltaY = (e.clientY - this.resizeStart.y) / this.getCurrentTab().zoom;

                const newWidth = Math.max(20, this.resizeStart.width + deltaX);
                const newHeight = Math.max(20, this.resizeStart.height + deltaY);

                this.selectedObject.style.width = newWidth + 'px';
                this.selectedObject.style.height = newHeight + 'px';

                const objectData = this.getCurrentTab().objects.get(this.selectedObject.id);
                if (objectData) {
                    objectData.width = newWidth;
                    objectData.height = newHeight;
                }

                this.resizeContent(this.selectedObject, newWidth, newHeight, objectData.type);

                this.updateArrowsForObject(this.selectedObject.id);
            }

            startRotation(element, e) {
                this.isRotating = true;
                this.selectedObject = element;
                const rect = element.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.rotationStart = {
                    centerX: centerX,
                    centerY: centerY,
                    startAngle: Math.atan2(e.clientY - centerY, e.clientX - centerX)
                };
            }

            handleRotation(e) {
                if (!this.rotationStart) return;

                const currentAngle = Math.atan2(
                    e.clientY - this.rotationStart.centerY,
                    e.clientX - this.rotationStart.centerX
                );

                const deltaAngle = currentAngle - this.rotationStart.startAngle;
                const degrees = deltaAngle * (180 / Math.PI);

                const objectData = this.getCurrentTab().objects.get(this.selectedObject.id);
                if (objectData) {
                    objectData.rotation = (objectData.rotation + degrees) % 360;
                    this.selectedObject.style.transform = `rotate(${objectData.rotation}deg)`;
                }

                this.rotationStart.startAngle = currentAngle;
                this.updateArrowsForObject(this.selectedObject.id);
            }

            selectObject(element) {
                this.deselectAll();
                this.selectedObject = element;
                this.selectedObjects.set(element.id, { x: this.getCurrentTab().objects.get(element.id).x, y: this.getCurrentTab().objects.get(element.id).y });
                element.classList.add('selected');
                this.updateObjectControls();
            }

            toggleMultiSelection(element) {
                const objectId = element.id;
                const tab = this.getCurrentTab();
                if (this.selectedObjects.has(objectId)) {
                    this.selectedObjects.delete(objectId);
                    element.classList.remove('selected');
                } else {
                    this.selectedObjects.set(objectId, { x: tab.objects.get(objectId).x, y: tab.objects.get(objectId).y });
                    element.classList.add('selected');
                }

                this.selectedObject = this.selectedObjects.size > 0 ? element : null;
                this.updateObjectControls();
            }

            updateObjectControls() {
                if (this.selectedObjects.size > 0) {
                    const firstSelectedId = this.selectedObjects.keys().next().value;
                    const objectData = this.getCurrentTab().objects.get(firstSelectedId);

                    const spriteControls = document.getElementById('spriteControls');
                    if (objectData.type === 'sprite' && objectData.spriteData) {
                        // Nascondi altri controlli
                        document.getElementById('objectControls').style.display = 'none';
                        document.getElementById('arrowControls').style.display = 'none';
                        document.getElementById('freehandControls').style.display = 'none';

                        // Mostra controlli sprite
                        spriteControls.style.display = 'flex';

                        // Popola i campi
                        const sprite = objectData.spriteData;
                        const maxFrame = (sprite.cols * sprite.rows) - 1;

                        document.getElementById('spriteCurrentFrame').value = sprite.frame;
                        document.getElementById('spriteCurrentFrame').max = maxFrame;
                        document.getElementById('spriteFrameInfo').textContent = `(0-${maxFrame})`;

                        document.getElementById('spriteFrameWidth').value = sprite.frameWidth;
                        document.getElementById('spriteFrameHeight').value = sprite.frameHeight;

                        // Imposta sequenza default se vuota
                        const animInput = document.getElementById('spriteAnimationFrames');
                        if (!animInput.value) {
                            const defaultSequence = Array.from({ length: maxFrame + 1 }, (_, i) => i).join(',');
                            animInput.value = defaultSequence;
                        }

                        // Mostra stato animazione
                        const isAnimating = objectData.animationInterval !== undefined;
                        document.getElementById('spritePlayAnimation').style.display = isAnimating ? 'none' : 'inline-block';
                        document.getElementById('spriteStopAnimation').style.display = isAnimating ? 'inline-block' : 'none';

                        document.getElementById('objectInfo').textContent = `Sprite selezionato (Frame ${sprite.frame}/${maxFrame})`;

                    } else {
                        // Nascondi controlli sprite per altri tipi
                        spriteControls.style.display = 'none';

                        // Resto della logica esistente per altri oggetti
                        const iconControls = document.getElementById('iconControls');
                        if (objectData.type === 'icon') {
                            iconControls.style.display = 'flex';
                            document.getElementById('iconSelect').value = objectData.icon;
                        } else {
                            iconControls.style.display = 'none';
                        }

                        document.getElementById('objectColor').value = objectData.color;
                        document.getElementById('objectText').value = objectData.text;
                        document.getElementById('objectNumber').value = objectData.objectNumber || '';
                        document.getElementById('objectOpacity').value = objectData.opacity || 1;
                        document.getElementById('objectOpacityValue').textContent = (objectData.opacity || 1).toFixed(2);
                        document.getElementById('objectInfo').textContent = `Selezionati: ${this.selectedObjects.size} oggetti`;

                        const dashedObjectToggleBtn = document.getElementById('dashedObjectToggle');
                        dashedObjectToggleBtn.style.display = 'inline-block';
                        dashedObjectToggleBtn.classList.toggle('active', objectData.dashed);

                        document.getElementById('objectControls').style.display = 'flex';
                        document.getElementById('arrowControls').style.display = 'none';
                        document.getElementById('freehandControls').style.display = 'none';
                    }
                    // NUOVO: Aggiungi pulsante animazione
                    const animButton = document.getElementById('showAnimationControls');
                    if (animButton) {
                        animButton.style.display = 'inline-block';
                    }

                } else {
                    document.getElementById('objectInfo').textContent = 'Nessun oggetto selezionato';
                    document.getElementById('objectText').value = '';
                    document.getElementById('dashedObjectToggle').style.display = 'none';
                    document.getElementById('spriteControls').style.display = 'none';

                    document.getElementById('objectControls').style.display = 'flex';
                    document.getElementById('arrowControls').style.display = 'none';
                    document.getElementById('freehandControls').style.display = 'none';
                }
            }

            updateArrowControls() {
                if (this.selectedArrow) {
                    const arrowData = this.getCurrentTab().arrows.get(this.selectedArrow);
                    document.getElementById('arrowColor').value = arrowData.color;
                    document.getElementById('arrowThickness').value = arrowData.thickness;
                    document.getElementById('thicknessValue').textContent = arrowData.thickness;

                    document.getElementById('arrowOpacity').value = arrowData.opacity || 1;
                    document.getElementById('arrowOpacityValue').textContent = (arrowData.opacity || 1).toFixed(2);

                    // Checkbox terminali
                    document.getElementById('arrowMarkerStart').checked = arrowData.markerStart || false;
                    document.getElementById('arrowMarkerEnd').checked = arrowData.markerEnd !== false;

                    const dashedBtn = document.getElementById('dashedArrowToggle');
                    dashedBtn.style.display = 'inline-block';
                    dashedBtn.classList.toggle('active', arrowData.dashed);

                    document.getElementById('objectInfo').textContent = 'Freccia selezionata';
                    document.getElementById('objectControls').style.display = 'none';
                    document.getElementById('arrowControls').style.display = 'flex';

                    document.querySelectorAll('.arrow-type-btn').forEach(btn => btn.classList.remove('active'));
                    document.getElementById(`arrowType${arrowData.type.charAt(0).toUpperCase() + arrowData.type.slice(1)}`).classList.add('active');
                } else {
                    this.deselectAll();
                }
            }

            deselectAll() {
                if (this.selectedObject) {
                    const objectData = this.getCurrentTab().objects.get(this.selectedObject.id);
                    if (objectData && objectData.type === 'sprite' && objectData.animationInterval) {
                        // Non fermiamo l'animazione, ma aggiorniamo solo l'UI
                        // Se vuoi fermarla alla deselezione, decommentare:
                        // clearInterval(objectData.animationInterval);
                        // delete objectData.animationInterval;
                    }
                }

                document.querySelectorAll('.canvas-object.selected').forEach(obj => {
                    obj.classList.remove('selected', 'group-selected');
                });

                // ‚úÖ AGGIUNGI QUESTO BLOCCO
                // Nascondi i pallini degli endpoint delle frecce
                document.querySelectorAll('.endpoint-control').forEach(endpoint => {
                    endpoint.style.opacity = '0';
                    endpoint.style.pointerEvents = 'none';
                });

                // Nascondi i punti di controllo delle curve
                document.querySelectorAll('.control-point').forEach(cp => {
                    cp.style.opacity = '0';
                    cp.style.pointerEvents = 'none';
                });

                document.querySelectorAll('.arrow-path.selected').forEach(arrow => {
                    arrow.classList.remove('selected');
                });

                this.hideGroupRotationCenter();
                document.querySelectorAll('.arrow-path.selected').forEach(arrow => {
                    arrow.classList.remove('selected');
                });

                this.hideGroupRotationCenter();
                this.selectedObject = null;
                this.selectedObjects.clear();
                this.selectedArrow = null;

                document.getElementById('objectInfo').textContent = 'Nessun oggetto selezionato';
                document.getElementById('objectText').value = '';
                document.getElementById('dashedObjectToggle').style.display = 'none';
                document.getElementById('objectControls').style.display = 'flex';
                document.getElementById('arrowControls').style.display = 'none';
                document.querySelectorAll('.freehand-path.selected').forEach(path => {
                    path.classList.remove('selected');
                });
                this.selectedFreehand = null;
                document.getElementById('freehandControls').style.display = 'none';
                document.getElementById('spriteControls').style.display = 'none';
            }

            startConnection(from, e) {
                e.preventDefault();
                this.isConnecting = true;
                this.connectionStart = from;
                document.getElementById('canvas').style.cursor = 'crosshair';
                this.createConnectionPreview(e);
            }

            createConnectionPreview(e) {
                const startPos = this.getConnectionPointAbsolutePosition(
                    this.connectionStart.objectId,
                    this.connectionStart.position
                );

                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.id = 'connection-preview';
                svg.style.position = 'absolute';
                svg.style.left = '0px';
                svg.style.top = '0px';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '9999';

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('stroke', '#3498db');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('stroke-dasharray', '5,5');
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', 'url(#arrowhead)');

                svg.appendChild(path);
                document.getElementById('canvas').appendChild(svg);

                this.connectionPreview = { svg, path, startPos };
            }

            updateConnectionPreview(e) {
                if (!this.connectionPreview) return;

                const rect = document.getElementById('canvas').getBoundingClientRect();
                const currentX = (e.clientX - rect.left) / this.getCurrentTab().zoom;
                const currentY = (e.clientY - rect.top) / this.getCurrentTab().zoom;

                const pathData = this.generateArrowPath(this.connectionPreview.startPos, { x: currentX, y: currentY }, this.arrowType);
                this.connectionPreview.path.setAttribute('d', pathData);
            }

            finishConnection(e) {
                if (!this.isConnecting || !this.connectionStart) return;

                const target = e.target.closest('.connection-point');
                const targetObject = target?.closest('.canvas-object');

                const rect = document.getElementById('canvas').getBoundingClientRect();
                const endPos = { x: (e.clientX - rect.left) / this.getCurrentTab().zoom, y: (e.clientY - rect.top) / this.getCurrentTab().zoom };

                let to;
                if (target && targetObject && targetObject.id !== this.connectionStart.objectId) {
                    const targetPosition = target.classList.contains('top') ? 'top' :
                        target.classList.contains('bottom') ? 'bottom' :
                            target.classList.contains('left') ? 'left' : 'right';
                    to = { objectId: targetObject.id, position: targetPosition };
                } else {
                    to = endPos;
                }

                this.createArrow(this.connectionStart, to, this.arrowType);

                this.isConnecting = false;
                this.connectionStart = null;
                if (this.connectionPreview) {
                    this.connectionPreview.svg.remove();
                    this.connectionPreview = null;
                }
                document.getElementById('canvas').style.cursor = 'default';
            }

            getConnectionPointAbsolutePosition(objectId, position) {
                if (!objectId) {
                    return position;
                }
                const element = document.getElementById(objectId);
                if (!element) return { x: 0, y: 0 };

                const rect = element.getBoundingClientRect();
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();

                const centerX = (rect.left - canvasRect.left) + (rect.width / 2);
                const centerY = (rect.top - canvasRect.top) + (rect.height / 2);
                const halfWidth = rect.width / 2;
                const halfHeight = rect.height / 2;

                const rotation = this.getCurrentTab().objects.get(objectId)?.rotation || 0;
                const angle = rotation * (Math.PI / 180);

                let offset = { x: 0, y: 0 };
                switch (position) {
                    case 'top':
                        offset = { x: 0, y: -halfHeight };
                        break;
                    case 'top-right':
                        offset = { x: halfWidth, y: -halfHeight };
                        break;
                    case 'right':
                        offset = { x: halfWidth, y: 0 };
                        break;
                    case 'bottom-right':
                        offset = { x: halfWidth, y: halfHeight };
                        break;
                    case 'bottom':
                        offset = { x: 0, y: halfHeight };
                        break;
                    case 'bottom-left':
                        offset = { x: -halfWidth, y: halfHeight };
                        break;
                    case 'left':
                        offset = { x: -halfWidth, y: 0 };
                        break;
                    case 'top-left':
                        offset = { x: -halfWidth, y: -halfHeight };
                        break;
                }

                const rotatedX = offset.x * Math.cos(angle) - offset.y * Math.sin(angle);
                const rotatedY = offset.x * Math.sin(angle) + offset.y * Math.cos(angle);

                return {
                    x: (centerX + rotatedX) / this.getCurrentTab().zoom,
                    y: (centerY + rotatedY) / this.getCurrentTab().zoom
                };
            }

            animateSprite(objectId, frames, fps = 10) {
                const tab = this.getCurrentTab();
                const obj = tab.objects.get(objectId);
                if (!obj || obj.type !== 'sprite') return;

                const delay = 1000 / fps;
                let currentFrame = 0;

                const interval = setInterval(() => {
                    obj.spriteData.frame = frames[currentFrame];
                    this.renderObject(obj);
                    currentFrame = (currentFrame + 1) % frames.length;
                }, delay);

                // Salva l'intervallo nell'oggetto per poterlo fermare
                obj.animationInterval = interval;
            }

            stopSpriteAnimation(objectId) {
                const obj = this.getCurrentTab().objects.get(objectId);
                if (obj && obj.animationInterval) {
                    clearInterval(obj.animationInterval);
                    delete obj.animationInterval;
                }
            }

            createArrow(from, to, type, dashed = this.dashedMode, color = document.getElementById('arrowColor').value, thickness = parseInt(document.getElementById('arrowThickness').value)) {
                const tab = this.getCurrentTab();
                const arrowId = 'arrow-' + tab.nextArrowId++;

                // RIMUOVI QUESTO BLOCCO SE ESISTE:
                // if (from.objectId && to.objectId) {
                //     const existingArrow = Array.from(tab.arrows.values()).find(a => 
                //         a.from.objectId === from.objectId && 
                //         a.from.position === from.position &&
                //         a.to.objectId === to.objectId && 
                //         a.to.position === to.position
                //     );
                //     if (existingArrow) return existingArrow;
                // }

                const arrow = {
                    id: arrowId,
                    from: from,
                    to: to,
                    type: type,
                    dashed: dashed,
                    color: color,
                    thickness: thickness,
                    opacity: 1,
                    controlPoint: null,
                    markerStart: false,
                    markerEnd: true
                };

                const fromPos = this.getArrowPoint(arrow.from);
                const toPos = this.getArrowPoint(arrow.to);
                arrow.controlPoint = this.generateDefaultControlPoint(fromPos, toPos);

                tab.arrows.set(arrowId, arrow);

                // NUOVO: Aggiorna il counter per visualizzare quante frecce partono da quel punto
                if (from.objectId && from.position) {
                    const key = `${from.objectId}-${from.position}`;
                    const counter = tab.connectionPointCounters.get(key) || 0;
                    tab.connectionPointCounters.set(key, counter + 1);
                    this.updateConnectionPointBadge(from.objectId, from.position, counter + 1);
                }

                this.renderArrow(arrow);
                this.saveState(`Aggiunta freccia da ${from.objectId}-${from.position} a ${to.objectId}-${to.position}`);

                return arrow;
            }

            updateConnectionPointBadge(objectId, position, count) {
                const element = document.getElementById(objectId);
                if (!element) return;

                const point = element.querySelector(`.connection-point.${position}`);
                if (!point) return;

                // Rimuovi badge esistente
                const existingBadge = point.querySelector('.connection-badge');
                if (existingBadge) existingBadge.remove();

                // Aggiungi badge solo se ci sono 2+ collegamenti
                if (count >= 2) {
                    const badge = document.createElement('span');
                    badge.className = 'connection-badge';
                    badge.textContent = count;
                    badge.style.cssText = `
            position: absolute;
            top: -8px;
            right: -8px;
            background: #e74c3c;
            color: white;
            font-size: 9px;
            font-weight: bold;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        `;
                    point.appendChild(badge);
                }
            }

            renderArrow(arrow) {
                let fromPos = this.getArrowPoint(arrow.from);
                let toPos = this.getArrowPoint(arrow.to);

                let svg = document.getElementById(arrow.id);
                const wasSelected = this.selectedArrow === arrow.id;

                if (!svg) {
                    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.classList.add('arrow-svg');
                    svg.id = arrow.id;
                    document.getElementById('canvas').appendChild(svg);
                } else {
                    svg.innerHTML = '';
                }

                // Ricrea sempre i defs con i colori aggiornati
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const markerId = `arrowhead-${arrow.id}`;

                // Marker per la fine (freccia verso destra)
                const markerEnd = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                markerEnd.id = `${markerId}-end`;
                markerEnd.setAttribute('markerWidth', '10');
                markerEnd.setAttribute('markerHeight', '7');
                markerEnd.setAttribute('refX', '9');
                markerEnd.setAttribute('refY', '3.5');
                markerEnd.setAttribute('orient', 'auto');

                const polygonEnd = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygonEnd.setAttribute('points', '0 0, 10 3.5, 0 7');
                polygonEnd.setAttribute('fill', arrow.color);
                markerEnd.appendChild(polygonEnd);
                defs.appendChild(markerEnd);

                // Marker per l'inizio (freccia verso sinistra)
                const markerStart = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                markerStart.id = `${markerId}-start`;
                markerStart.setAttribute('markerWidth', '10');
                markerStart.setAttribute('markerHeight', '7');
                markerStart.setAttribute('refX', '1');
                markerStart.setAttribute('refY', '3.5');
                markerStart.setAttribute('orient', 'auto');

                const polygonStart = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygonStart.setAttribute('points', '10 0, 0 3.5, 10 7');
                polygonStart.setAttribute('fill', arrow.color);
                markerStart.appendChild(polygonStart);
                defs.appendChild(markerStart);

                svg.appendChild(defs);

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.classList.add('arrow-path');
                if (arrow.dashed) path.classList.add('dashed');
                if (wasSelected) path.classList.add('selected');

                // Assicurati che il control point esista
                if (!arrow.controlPoint) {
                    arrow.controlPoint = this.generateDefaultControlPoint(fromPos, toPos);
                }

                // Genera il path in base al tipo
                let pathData = this.generateArrowPath(fromPos, toPos, arrow.type, arrow.controlPoint);

                path.setAttribute('d', pathData);
                path.style.stroke = arrow.color;
                path.style.strokeWidth = arrow.thickness + 'px';
                path.setAttribute('fill', 'none');
                path.style.opacity = arrow.opacity || 1;

                // Applica o rimuovi i marker in base ai flag
                if (arrow.markerStart) {
                    path.setAttribute('marker-start', `url(#${markerId}-start)`);
                } else {
                    path.removeAttribute('marker-start');
                }

                if (arrow.markerEnd !== false) {
                    path.setAttribute('marker-end', `url(#${markerId}-end)`);
                } else {
                    path.removeAttribute('marker-end');
                }

                // Event listeners per il path
                path.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.selectArrow(arrow.id);
                });

                path.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (this.selectedArrow !== arrow.id) {
                        this.selectArrow(arrow.id);
                    }
                    this.showContextMenu(e, arrow.id, 'arrow');
                });

                svg.appendChild(path);

                // Aggiungi punti di controllo per spostare inizio e fine
                const startPoint = this.addArrowEndpointControl(svg, arrow, 'start', fromPos);
                const endPoint = this.addArrowEndpointControl(svg, arrow, 'end', toPos);

                svg.appendChild(startPoint);
                svg.appendChild(endPoint);

                // Aggiungi il punto di controllo per la curva
                const controlPointElement = this.addCurveControlPoint(svg, arrow);
                svg.appendChild(controlPointElement);

                const allPoints = [fromPos, toPos];
                if (arrow.controlPoint) {
                    allPoints.push(arrow.controlPoint);
                }

                const minX = Math.min(...allPoints.map(p => p.x)) - arrow.thickness - 10;
                const minY = Math.min(...allPoints.map(p => p.y)) - arrow.thickness - 10;
                const maxX = Math.max(...allPoints.map(p => p.x)) + arrow.thickness + 10;
                const maxY = Math.max(...allPoints.map(p => p.y)) + arrow.thickness + 10;

                svg.style.left = minX + 'px';
                svg.style.top = minY + 'px';
                svg.style.width = (maxX - minX) + 'px';
                svg.style.height = (maxY - minY) + 'px';
                svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
            }

            getArrowPoint(point) {
                if (point.objectId) {
                    return this.getConnectionPointAbsolutePosition(point.objectId, point.position);
                }
                return point;
            }

            calculateDistanceFromLine(p1, p2, point) {
                const A = point.x - p1.x;
                const B = point.y - p1.y;
                const C = p2.x - p1.x;
                const D = p2.y - p1.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;

                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;

                if (param < 0) {
                    xx = p1.x;
                    yy = p1.y;
                } else if (param > 1) {
                    xx = p2.x;
                    yy = p2.y;
                } else {
                    xx = p1.x + param * C;
                    yy = p1.y + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;

                return Math.sqrt(dx * dx + dy * dy);
            }

            addCurveControlPoint(svg, arrow) {
                const controlPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                controlPoint.setAttribute('cx', arrow.controlPoint.x);
                controlPoint.setAttribute('cy', arrow.controlPoint.y);
                controlPoint.setAttribute('r', '6');
                controlPoint.setAttribute('fill', '#f39c12');
                controlPoint.setAttribute('stroke', '#fff');
                controlPoint.setAttribute('stroke-width', '2');
                controlPoint.style.cursor = 'move';
                controlPoint.classList.add('control-point');

                controlPoint.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.isDraggingControlPoint = true;
                    this.selectedArrow = arrow.id;
                });

                return controlPoint;
            }

            generateDefaultControlPoint(from, to) {
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2;

                // NUOVO: Varia l'offset in base al numero di frecce esistenti
                const tab = this.getCurrentTab();
                const existingArrows = Array.from(tab.arrows.values()).filter(a =>
                    (a.from.x === from.x && a.from.y === from.y) ||
                    (a.from.objectId === from.objectId && a.from.position === from.position)
                );

                const offset = 50 + (existingArrows.length * 15); // Incrementa l'offset per ogni freccia

                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist === 0) return { x: midX + offset, y: midY };

                const controlX = midX + (from.y - to.y) * offset / dist;
                const controlY = midY + (to.x - from.x) * offset / dist;
                return { x: controlX, y: controlY };
            }

            generateArrowPath(from, to, type, controlPoint = null) {
                const cp = controlPoint || this.generateDefaultControlPoint(from, to);

                switch (type) {
                    case 'linear':
                        return `M ${from.x} ${from.y} L ${to.x} ${to.y}`;

                    case 'curved':
                        return `M ${from.x} ${from.y} Q ${cp.x} ${cp.y} ${to.x} ${to.y}`;

                    case 'zigzag':
                        const midXZ = (from.x + to.x) / 2;
                        return `M ${from.x} ${from.y} L ${midXZ} ${from.y} L ${midXZ} ${to.y} L ${to.x} ${to.y}`;

                    default:
                        return `M ${from.x} ${from.y} L ${to.x} ${to.y}`;
                }
            }


            updateArrowsForObject(objectId) {
                const tab = this.getCurrentTab();
                tab.arrows.forEach((arrow, arrowId) => {
                    if (arrow.from.objectId === objectId || arrow.to.objectId === objectId) {
                        this.renderArrow(arrow);
                    }
                });
            }

            selectArrow(arrowId) {
                this.deselectAll(); // ‚úÖ Questo √® gi√† presente
                this.selectedArrow = arrowId;

                const arrowElement = document.getElementById(arrowId);
                if (arrowElement) {
                    const path = arrowElement.querySelector('.arrow-path');
                    if (path) {
                        path.classList.add('selected');
                    }

                    // ‚úÖ VERIFICA CHE CI SIA QUESTO CODICE
                    // Mostra i punti di controllo endpoint
                    const endpoints = arrowElement.querySelectorAll('.endpoint-control');
                    endpoints.forEach(ep => {
                        ep.style.opacity = '1';
                        ep.style.pointerEvents = 'auto';
                    });

                    // Mostra il punto di controllo della curva
                    const controlPoint = arrowElement.querySelector('.control-point');
                    if (controlPoint) {
                        controlPoint.style.opacity = '1';
                        controlPoint.style.pointerEvents = 'auto';
                    }
                }
                this.updateArrowControls();
            }

            changeArrowType(newType) {
                if (!this.selectedArrow) return;
                const arrowData = this.getCurrentTab().arrows.get(this.selectedArrow);
                if (arrowData) {
                    arrowData.type = newType;
                    // Mantieni il punto di controllo esistente
                    if (!arrowData.controlPoint) {
                        const fromPos = this.getArrowPoint(arrowData.from);
                        const toPos = this.getArrowPoint(arrowData.to);
                        arrowData.controlPoint = this.generateDefaultControlPoint(fromPos, toPos);
                    }
                    this.renderArrow(arrowData);
                    this.updateArrowControls();
                    this.saveState(`Modificato tipo freccia ${arrowData.from.objectId}-${arrowData.from.position} a ${arrowData.to.objectId}-${arrowData.to.position}`);
                }
            }
            // Nel metodo changeSelectedObjectsColor(), aggiungi alla fine:
            changeSelectedObjectsColor(color) {
                if (this.selectedObjects.size === 0) return;

                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (!objectData) return;
                    objectData.color = color;

                    if (objectData.type === 'icon') {
                        const element = document.getElementById(id);
                        const iconContent = element.querySelector('.icon-object');
                        if (iconContent) {
                            iconContent.style.color = color;
                        }
                    }

                    if (objectData.type === 'local-svg') {
                        const element = document.getElementById(id);
                        const img = element.querySelector('img');
                        if (img) {
                            img.style.filter = `invert(1) sepia(1) saturate(5) hue-rotate(${getHue(color)}deg)`;
                        }
                    }

                    this.renderObject(objectData);
                });

                this.saveState(`Modificato colore di ${this.selectedObjects.size} oggetti`);
                this.updateCurrentFrame();
            }

            // Nel metodo changeSelectedObjectsText(), aggiungi alla fine:
            changeSelectedObjectsText(text) {
                if (this.selectedObjects.size === 0) return;

                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (!objectData) return;
                    objectData.text = text;
                    this.renderObject(objectData);
                });

                this.saveState(`Modificato testo di ${this.selectedObjects.size} oggetti`);
                this.updateCurrentFrame();
            }

            // Nel metodo changeSelectedObjectsOpacity(), aggiungi alla fine:
            changeSelectedObjectsOpacity(opacity) {
                if (this.selectedObjects.size === 0) return;

                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (!objectData) return;
                    objectData.opacity = parseFloat(opacity);

                    const element = document.getElementById(id);
                    if (element) {
                        element.style.opacity = opacity;
                    }
                });

                this.saveState(`Modificato opacit√† di ${this.selectedObjects.size} oggetti`);
                this.updateCurrentFrame();
            }

            // Nel metodo rotateSelected(), aggiungi alla fine:
            rotateSelected(degrees) {
                if (this.selectedObjects.size === 0) return;

                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (objectData) {
                        objectData.rotation = (objectData.rotation + degrees) % 360;
                        document.getElementById(id).style.transform = `rotate(${objectData.rotation}deg)`;
                        this.updateArrowsForObject(id);
                    }
                });
                this.saveState(`Ruotato di ${degrees} gradi ${this.selectedObjects.size} oggetti`);
                this.updateCurrentFrame();
            }

            // Nel metodo toggleDashedObject(), aggiungi alla fine:
            toggleDashedObject() {
                if (this.selectedObjects.size === 0) return;
                const tab = this.getCurrentTab();

                const firstSelectedId = this.selectedObjects.keys().next().value;
                const isDashed = tab.objects.get(firstSelectedId).dashed;
                const newState = !isDashed;

                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (objectData) {
                        objectData.dashed = newState;
                        this.renderObject(objectData);
                    }
                });
                document.getElementById('dashedObjectToggle').classList.toggle('active', newState);
                this.saveState(`Modificato tratteggio di ${this.selectedObjects.size} oggetti`);
                this.updateCurrentFrame();
            }
            changeArrowColor(color) {
                if (!this.selectedArrow) return;
                const arrowData = this.getCurrentTab().arrows.get(this.selectedArrow);
                if (arrowData) {
                    arrowData.color = color;
                    this.renderArrow(arrowData);
                    this.saveState(`Modificato colore freccia ${arrowData.from.objectId}-${arrowData.from.position} a ${arrowData.to.objectId}-${arrowData.to.position}`);
                }
            }

            changeArrowThickness(thickness) {
                if (!this.selectedArrow) return;
                const arrowData = this.getCurrentTab().arrows.get(this.selectedArrow);
                if (arrowData) {
                    arrowData.thickness = parseInt(thickness);
                    this.renderArrow(arrowData);
                    this.saveState(`Modificato spessore freccia ${arrowData.from.objectId}-${arrowData.from.position} a ${arrowData.to.objectId}-${arrowData.to.position}`);
                }
            }
            changeArrowOpacity(opacity) {
                if (!this.selectedArrow) return;
                const arrowData = this.getCurrentTab().arrows.get(this.selectedArrow);
                if (arrowData) {
                    arrowData.opacity = parseFloat(opacity);
                    const svgElement = document.getElementById(this.selectedArrow);
                    if (svgElement) {
                        const path = svgElement.querySelector('.arrow-path');
                        if (path) {
                            path.style.opacity = opacity;
                        }
                    }
                    this.saveState(`Modificato opacit√† freccia ${arrowData.from.objectId}-${arrowData.from.position} a ${arrowData.to.objectId}-${arrowData.to.position}`);
                }
            }

            toggleDashedArrow() {
                if (!this.selectedArrow) return;
                const arrowData = this.getCurrentTab().arrows.get(this.selectedArrow);
                if (arrowData) {
                    arrowData.dashed = !arrowData.dashed;
                    const svgElement = document.getElementById(this.selectedArrow);
                    if (svgElement) {
                        const path = svgElement.querySelector('.arrow-path');
                        if (path) {
                            if (arrowData.dashed) {
                                path.classList.add('dashed');
                            } else {
                                path.classList.remove('dashed');
                            }
                        }
                    }
                    document.getElementById('dashedArrowToggle').classList.toggle('active', arrowData.dashed);
                    this.saveState(`Modificato tratteggio freccia ${arrowData.from.objectId}-${arrowData.from.position} a ${arrowData.to.objectId}-${arrowData.to.position}`);
                }
            }
            toggleDashedObject() {
                if (this.selectedObjects.size === 0) return;
                const tab = this.getCurrentTab();

                const firstSelectedId = this.selectedObjects.keys().next().value;
                const isDashed = tab.objects.get(firstSelectedId).dashed;
                const newState = !isDashed;

                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (objectData) {
                        objectData.dashed = newState;
                        this.renderObject(objectData);
                    }
                });
                document.getElementById('dashedObjectToggle').classList.toggle('active', newState);
                this.saveState(`Modificato tratteggio di ${this.selectedObjects.size} oggetti`);
            }

            rotateSelected(degrees) {
                if (this.selectedObjects.size === 0) return;

                const tab = this.getCurrentTab();
                this.selectedObjects.forEach((pos, id) => {
                    const objectData = tab.objects.get(id);
                    if (objectData) {
                        objectData.rotation = (objectData.rotation + degrees) % 360;
                        document.getElementById(id).style.transform = `rotate(${objectData.rotation}deg)`;
                        this.updateArrowsForObject(id);
                    }
                });
                this.saveState(`Ruotato di ${degrees} gradi ${this.selectedObjects.size} oggetti`);
            }

            deleteSelected() {
                const tab = this.getCurrentTab();

                if (this.selectedObjects.size > 0) {
                    this.selectedObjects.forEach((pos, objectId) => {
                        // Gestione eliminazione oggetti normali
                        if (!pos.type || pos.type !== 'freehand') {
                            // Elimina frecce collegate E aggiorna contatori
                            tab.arrows.forEach((arrow, arrowId) => {
                                if (arrow.from.objectId === objectId || arrow.to.objectId === objectId) {
                                    // Decrementa counter per from
                                    if (arrow.from.objectId && arrow.from.position) {
                                        const key = `${arrow.from.objectId}-${arrow.from.position}`;
                                        const counter = tab.connectionPointCounters.get(key) || 0;
                                        if (counter > 1) {
                                            tab.connectionPointCounters.set(key, counter - 1);
                                            this.updateConnectionPointBadge(arrow.from.objectId, arrow.from.position, counter - 1);
                                        } else {
                                            tab.connectionPointCounters.delete(key);
                                            this.updateConnectionPointBadge(arrow.from.objectId, arrow.from.position, 0);
                                        }
                                    }

                                    // Elimina la freccia
                                    document.getElementById(arrowId)?.remove();
                                    tab.arrows.delete(arrowId);
                                }
                            });

                            // Elimina l'oggetto
                            document.getElementById(objectId)?.remove();
                            tab.objects.delete(objectId);
                        }
                        // Gestione eliminazione freehands
                        else if (pos.type === 'freehand') {
                            document.getElementById(objectId)?.remove();
                            tab.freehands.delete(objectId);
                        }
                    });
                }
                // Elimina freccia selezionata
                else if (this.selectedArrow) {
                    const arrow = tab.arrows.get(this.selectedArrow);
                    if (arrow && arrow.from.objectId && arrow.from.position) {
                        const key = `${arrow.from.objectId}-${arrow.from.position}`;
                        const counter = tab.connectionPointCounters.get(key) || 0;
                        if (counter > 1) {
                            tab.connectionPointCounters.set(key, counter - 1);
                            this.updateConnectionPointBadge(arrow.from.objectId, arrow.from.position, counter - 1);
                        } else {
                            tab.connectionPointCounters.delete(key);
                            this.updateConnectionPointBadge(arrow.from.objectId, arrow.from.position, 0);
                        }
                    }

                    document.getElementById(this.selectedArrow)?.remove();
                    tab.arrows.delete(this.selectedArrow);
                }
                // Elimina freehand selezionato
                else if (this.selectedFreehand) {
                    document.getElementById(this.selectedFreehand)?.remove();
                    tab.freehands.delete(this.selectedFreehand);
                }

                this.deselectAll();
                this.saveState(`Eliminato ${this.selectedObjects.size} oggetti, ${this.selectedArrows.size} frecce, ${this.selectedFreehands.size} freehands`);
            }

            copySelected() {
                const tab = this.getCurrentTab();
                const copiedObjects = [];
                const copiedArrows = [];
                const copiedFreehands = [];

                try {
                    this.selectedObjects.forEach((pos, id) => {
                        // Gestione freehands
                        if (pos.type === 'freehand') {
                            const freehand = tab.freehands.get(id);
                            if (freehand) {
                                const newFreehand = {
                                    ...freehand,
                                    points: freehand.points.map(p => ({ ...p }))
                                };
                                copiedFreehands.push(newFreehand);
                            }
                        } else {
                            // Oggetti normali
                            const obj = tab.objects.get(id);
                            if (obj) {
                                const newObj = {
                                    ...obj,
                                    spriteData: obj.spriteData ? { ...obj.spriteData } : null
                                };
                                copiedObjects.push(newObj);
                            }
                        }
                    });

                    // ‚úÖ MODIFICA: Crea una mappa per tracciare gli ID originali
                    const originalIdMap = new Map();
                    copiedObjects.forEach(obj => {
                        originalIdMap.set(obj.id, obj);
                    });

                    // Copia frecce che collegano oggetti selezionati
                    tab.arrows.forEach(arrow => {
                        if (this.selectedObjects.has(arrow.from.objectId) &&
                            this.selectedObjects.has(arrow.to.objectId)) {
                            const newArrow = {
                                ...arrow,
                                from: { ...arrow.from },
                                to: { ...arrow.to },
                                // ‚úÖ CRITICO: Copia profonda del punto di controllo
                                controlPoint: arrow.controlPoint ? {
                                    x: arrow.controlPoint.x,
                                    y: arrow.controlPoint.y
                                } : null,
                                // ‚úÖ AGGIUNTO: Salva gli ID originali per ricalcolare il punto di controllo
                                _originalFromId: arrow.from.objectId,
                                _originalToId: arrow.to.objectId
                            };
                            copiedArrows.push(newArrow);
                        }
                    });

                    this.clipboard = {
                        objects: copiedObjects,
                        arrows: copiedArrows,
                        freehands: copiedFreehands,
                        // ‚úÖ AGGIUNTO: Salva la mappa degli ID originali
                        originalIdMap: originalIdMap
                    };

                    console.log(`‚úÖ Copiati: ${copiedObjects.length} oggetti, ${copiedArrows.length} frecce, ${copiedFreehands.length} disegni`);

                } catch (error) {
                    console.error('Errore durante la copia degli oggetti:', error);
                    alert('Errore durante la copia. Controlla la console per i dettagli.');
                }
            }


            cutSelected() {
                this.copySelected();
                this.deleteSelected();
            }

            paste() {
                if (!this.clipboard) return;

                this.deselectAll();

                const tab = this.getCurrentTab();
                const pastedObjectMap = new Map();
                const offset = 20;

                // Incolla oggetti normali
                this.clipboard.objects.forEach(obj => {
                    const oldId = obj.id;
                    const newObj = this.addObject(
                        obj.type,
                        obj.x + offset,
                        obj.y + offset,
                        obj.color,
                        obj.text,
                        obj.rotation,
                        obj.dashed,
                        obj.icon,
                        obj.src,
                        obj.spriteData
                    );

                    const objectData = tab.objects.get(newObj.id);
                    if (objectData) {
                        objectData.opacity = obj.opacity || 1;
                        objectData.zIndex = obj.zIndex || 1;
                        objectData.objectNumber = obj.objectNumber;
                        objectData.width = obj.width;
                        objectData.height = obj.height;
                        this.renderObject(objectData);
                    }

                    pastedObjectMap.set(oldId, newObj.id);
                    this.selectedObjects.set(newObj.id, { x: newObj.x, y: newObj.y });
                    const element = document.getElementById(newObj.id);
                    if (element) {
                        element.classList.add('selected', 'group-selected');
                    }
                });

                // Incolla disegni a mano libera
                if (this.clipboard.freehands) {
                    this.clipboard.freehands.forEach(freehand => {
                        const newPoints = freehand.points.map(p => ({
                            x: p.x + offset,
                            y: p.y + offset
                        }));

                        const newFreehand = this.createFreehand(
                            newPoints,
                            freehand.color,
                            freehand.thickness
                        );

                        newFreehand.opacity = freehand.opacity || 1;

                        this.selectedObjects.set(newFreehand.id, {
                            type: 'freehand',
                            points: [...newPoints]
                        });

                        const svg = document.getElementById(newFreehand.id);
                        if (svg) {
                            const path = svg.querySelector('.freehand-path');
                            if (path) path.classList.add('selected');
                        }
                    });
                }

                // ‚úÖ MODIFICA COMPLETA: Incolla frecce con punto di controllo corretto
                this.clipboard.arrows.forEach(arrow => {
                    const newFrom = { ...arrow.from };
                    const newTo = { ...arrow.to };

                    // Aggiorna gli ID degli oggetti collegati
                    if (newFrom.objectId) {
                        newFrom.objectId = pastedObjectMap.get(newFrom.objectId);
                    } else if (newFrom.x !== undefined) {
                        newFrom.x += offset;
                        newFrom.y += offset;
                    }

                    if (newTo.objectId) {
                        newTo.objectId = pastedObjectMap.get(newTo.objectId);
                    } else if (newTo.x !== undefined) {
                        newTo.x += offset;
                        newTo.y += offset;
                    }

                    // Solo se entrambi gli endpoint sono validi
                    if ((newFrom.objectId || (newFrom.x !== undefined)) &&
                        (newTo.objectId || (newTo.x !== undefined))) {

                        const newArrow = this.createArrow(
                            newFrom,
                            newTo,
                            arrow.type,
                            arrow.dashed,
                            arrow.color,
                            arrow.thickness
                        );

                        const arrowData = tab.arrows.get(newArrow.id);
                        if (arrowData && arrow.controlPoint) {
                            // ‚úÖ CRITICO: Sposta il punto di controllo mantenendo la distanza relativa
                            const fromPos = this.getArrowPoint(newFrom);
                            const toPos = this.getArrowPoint(newTo);

                            // Calcola la distanza relativa del punto di controllo rispetto alla linea originale
                            const originalFromId = arrow._originalFromId;
                            const originalToId = arrow._originalToId;

                            if (originalFromId && originalToId && this.clipboard.originalIdMap) {
                                const originalFromObj = this.clipboard.originalIdMap.get(originalFromId);
                                const originalToObj = this.clipboard.originalIdMap.get(originalToId);

                                if (originalFromObj && originalToObj) {
                                    // Calcola offset relativo del punto di controllo rispetto al centro della linea originale
                                    const originalMidX = (originalFromObj.x + originalToObj.x) / 2;
                                    const originalMidY = (originalFromObj.y + originalToObj.y) / 2;

                                    const controlOffsetX = arrow.controlPoint.x - originalMidX;
                                    const controlOffsetY = arrow.controlPoint.y - originalMidY;

                                    // Applica lo stesso offset al nuovo punto medio
                                    const newMidX = (fromPos.x + toPos.x) / 2;
                                    const newMidY = (fromPos.y + toPos.y) / 2;

                                    arrowData.controlPoint = {
                                        x: newMidX + controlOffsetX,
                                        y: newMidY + controlOffsetY
                                    };
                                } else {
                                    // Fallback: sposta semplicemente il punto di controllo con l'offset
                                    arrowData.controlPoint = {
                                        x: arrow.controlPoint.x + offset,
                                        y: arrow.controlPoint.y + offset
                                    };
                                }
                            } else {
                                // Fallback: sposta semplicemente il punto di controllo con l'offset
                                arrowData.controlPoint = {
                                    x: arrow.controlPoint.x + offset,
                                    y: arrow.controlPoint.y + offset
                                };
                            }

                            arrowData.opacity = arrow.opacity || 1;
                            arrowData.markerStart = arrow.markerStart || false;
                            arrowData.markerEnd = arrow.markerEnd !== false;
                            this.renderArrow(arrowData);
                        }
                    }
                });

                // Mostra il centro di rotazione del gruppo se necessario
                if (this.selectedObjects.size > 1) {
                    this.showGroupRotationCenter();
                }

                this.saveState(`Incollati: ${this.clipboard.objects.length} oggetti, ${this.clipboard.arrows.length} frecce, ${this.clipboard.freehands?.length || 0} disegni`);
                this.updateObjectControls();

                console.log(`‚úÖ Incollati: ${this.clipboard.objects.length} oggetti, ${this.clipboard.arrows.length} frecce, ${this.clipboard.freehands?.length || 0} disegni`);
            }

            changeZoom(delta) {
                const tab = this.getCurrentTab();
                tab.zoom = Math.max(0.2, Math.min(3, tab.zoom + delta));
                this.zoom = tab.zoom;
                this.updateZoom();
            }

            updateZoom() {
                const tab = this.getCurrentTab();
                const canvas = document.getElementById('canvas');
                canvas.style.transform = `scale(${tab.zoom})`;
                document.getElementById('zoomDisplay').textContent = Math.round(tab.zoom * 100) + '%';
            }

            updateBackground() {
                const tab = this.getCurrentTab();
                const canvas = document.getElementById('canvas');
                canvas.className = 'canvas';

                if (tab.gridVisible) canvas.classList.add('grid-visible');
                if (tab.bwMode) canvas.classList.add('bw-mode');

                switch (tab.background) {
                    case 'half-field':
                        canvas.classList.add('bg-half-field');
                        break;
                    case 'full-field':
                        canvas.classList.add('bg-full-field');
                        break;
                    case '3d-field':
                        canvas.classList.add('bg-3d-field');
                        break;
                }
            }

            updateGrid() {
                const tab = this.getCurrentTab();
                document.getElementById('gridToggle').classList.toggle('active', tab.gridVisible);
                this.updateBackground();
            }

            updateBWMode() {
                const tab = this.getCurrentTab();
                document.getElementById('bwToggle').classList.toggle('active', tab.bwMode);
                this.updateBackground();
            }

            addNewTab() {
                const id = this.nextTabId++;
                const name = `Schema ${id}`;

                this.initializeTab(id, name);
                this.createTabElement(id, name);
                this.switchToTab(id);
            }

            createTabElement(id, name) {
                const tabsContainer = document.querySelector('.tabs-container');
                const addButton = tabsContainer.querySelector('.add-tab');

                const tab = document.createElement('div');
                tab.className = 'tab';
                tab.dataset.tabId = id;
                tab.setAttribute('draggable', 'true');
                tab.innerHTML = `<input class='no-style tab-title' value='${name}'/><span class="tab-close">√ó</span>`;

                const tabTitleInput = tab.querySelector('.tab-title');
                tabTitleInput.addEventListener('input', (e) => {
                    this.updateTabName(id, e.target.value);
                });

                tabTitleInput.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                tabTitleInput.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });

                tabsContainer.insertBefore(tab, addButton);
            }


            initTabDragDrop() {
                const tabsContainer = document.querySelector('.tabs-container');
                let draggedTab = null;
                let placeholder = null;

                tabsContainer.addEventListener('dragstart', (e) => {
                    const tab = e.target.closest('.tab');
                    if (!tab || tab.classList.contains('add-tab')) return;

                    draggedTab = tab;
                    tab.style.opacity = '0.4';
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', tab.innerHTML);

                    // Crea placeholder
                    placeholder = document.createElement('div');
                    placeholder.className = 'tab tab-placeholder';
                    placeholder.style.width = tab.offsetWidth + 'px';
                    placeholder.style.height = tab.offsetHeight + 'px';
                    placeholder.style.opacity = '0.5';
                    placeholder.style.border = '2px dashed #3498db';
                });

                tabsContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    const tab = e.target.closest('.tab');
                    if (!tab || tab === draggedTab || tab.classList.contains('add-tab')) return;

                    const rect = tab.getBoundingClientRect();
                    const midpoint = rect.left + rect.width / 2;

                    if (placeholder && placeholder.parentNode) {
                        placeholder.parentNode.removeChild(placeholder);
                    }

                    if (!(placeholder instanceof Node) || !(tab instanceof Node) || !(tabsContainer instanceof Node)) {
                        console.warn('Nodo non valido in insertBefore');
                        return;
                    }

                    if (e.clientX < midpoint) {
                        tabsContainer.insertBefore(placeholder, tab);
                    } else {
                        tabsContainer.insertBefore(placeholder, tab.nextSibling);
                    }
                });

                tabsContainer.addEventListener('dragend', (e) => {
                    if (!draggedTab) return;

                    draggedTab.style.opacity = '1';

                    if (placeholder && placeholder.parentNode) {
                        tabsContainer.insertBefore(draggedTab, placeholder);
                        placeholder.parentNode.removeChild(placeholder);
                    }

                    draggedTab = null;
                    placeholder = null;
                });

                tabsContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });

                tabsContainer.addEventListener('dragleave', (e) => {
                    if (e.target === tabsContainer && placeholder && placeholder.parentNode) {
                        placeholder.parentNode.removeChild(placeholder);
                    }
                });

                // Rendi i tab trascinabili
                const observer = new MutationObserver(() => {
                    document.querySelectorAll('.tab:not(.add-tab)').forEach(tab => {
                        if (!tab.hasAttribute('draggable')) {
                            tab.setAttribute('draggable', 'true');
                        }
                    });
                });

                observer.observe(tabsContainer, { childList: true });

                // Imposta draggable sui tab esistenti
                document.querySelectorAll('.tab:not(.add-tab)').forEach(tab => {
                    tab.setAttribute('draggable', 'true');
                });
            }
            updateTabName(tabId, newName) {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.name = newName;
                    // Se √® il tab attivo, aggiorna anche il titolo dello schema se vuoto
                    if (this.activeTabId === tabId && !document.getElementById('schemaTitle').value.trim()) {
                        document.getElementById('schemaTitle').value = newName;
                    }
                }
            }

            switchToTab(id) {
                this.saveTabState();

                const oldActiveTab = document.querySelector('.tab.active');
                if (oldActiveTab) {
                    oldActiveTab.classList.remove('active');
                }

                this.activeTabId = id;

                const newActiveTab = document.querySelector(`.tab[data-tab-id="${id}"]`);
                if (newActiveTab) {
                    newActiveTab.classList.add('active');

                    const tabInput = newActiveTab.querySelector('.tab-title');
                    const tab = this.tabs.get(id);
                    if (tabInput && tab) {
                        tabInput.value = tab.name;
                    }
                }

                const tab = this.getCurrentTab();
                this.canvasSize = tab.canvasSize || 'custom';
                this.showCanvasBorder = tab.showBorder || false;

                document.getElementById('canvasSizeSelect').value = this.canvasSize;
                this.setCanvasSize(this.canvasSize);

                const canvas = document.getElementById('canvas');
                if (this.showCanvasBorder) {
                    canvas.classList.add('show-border');
                    document.getElementById('toggleCanvasBorder').classList.add('active');
                } else {
                    canvas.classList.remove('show-border');
                    document.getElementById('toggleCanvasBorder').classList.remove('active');
                }

                // AGGIUNGI RIPRISTINO maxZIndex
                if (tab.maxZIndex) {
                    this.maxZIndex = tab.maxZIndex;
                }
                document.getElementById('workoutPeriodo').value = tab.periodo || 'GEN';
                document.getElementById('workoutRuolo').value = tab.ruolo || 'GEN';
                document.getElementById('workoutTipologia').value = tab.tipologia || 'GEN';
                document.getElementById('workoutGenere').value = tab.genere || 'GEN';
                document.getElementById('workoutCategoria').value = tab.categoria || 'GEN';
                document.getElementById('workoutDescrizione').value = tab.descrizione || '';
                document.getElementById('workoutAutore').value = tab.autore || this.currentUser;

                document.getElementById('workoutDate').value = tab.date || new Date();
                document.getElementById('workoutPlace').value = tab.place || "-";
                document.getElementById('workoutNr').value = tab.nr || 1;
                document.getElementById('workoutSeries').value = tab.series || 1;
                document.getElementById('workoutGroups').value = tab.groups || 1;
                document.getElementById('workoutTiming').value = tab.timing || 10;    // ‚úÖ AGGIUNTO
                document.getElementById('workoutRec').value = tab.rec || 60;          // ‚úÖ AGGIUNTO

                this.filterCategoriesByGenere(tab.genere || 'GEN');

                this.initExerciseSteps();
                this.renderStepsList();

                this.loadTabState();
            }

            closeTab(id) {
                if (this.tabs.size <= 1) return;
                this.tabs.delete(id);
                document.querySelector(`[data-tab-id="${id}"]`).remove();
                if (this.activeTabId === id) {
                    const firstTabId = this.tabs.keys().next().value;
                    this.switchToTab(firstTabId);
                }
            }

            // MODIFICA saveTabState per salvare z-index
            saveTabState() {
                const tab = this.getCurrentTab();
                if (!tab) return;

                tab.background = document.getElementById('backgroundSelect').value;
                tab.gridVisible = document.getElementById('gridToggle').classList.contains('active');
                tab.bwMode = document.getElementById('bwToggle').classList.contains('active');
                tab.zoom = this.zoom;

                // AGGIUNGI SALVATAGGIO DIMENSIONE E BORDI
                tab.canvasSize = this.canvasSize;
                tab.showBorder = this.showCanvasBorder;

                // AGGIUNGI SALVATAGGIO maxZIndex
                tab.maxZIndex = this.maxZIndex;
                tab.floatingToolbars = [];
                this.floatingToolbarGroups.forEach((data, id) => {
                    tab.floatingToolbars.push({
                        id: id,
                        html: data.element.outerHTML,
                        x: data.x,
                        y: data.y
                    });
                });
            }

            loadTabState() {
                const tab = this.getCurrentTab();
                const canvas = document.getElementById('canvas');

                while (canvas.firstChild) {
                    canvas.removeChild(canvas.firstChild);
                }

                // ORDINA GLI OGGETTI PER z-index PRIMA DI RENDERIZZARLI
                const sortedObjects = Array.from(tab.objects.values()).sort((a, b) => {
                    return (a.zIndex || 1) - (b.zIndex || 1);
                });

                sortedObjects.forEach(obj => this.renderObject(obj));
                tab.arrows.forEach(arrow => this.renderArrow(arrow));
                tab.freehands.forEach(freehand => this.renderFreehand(freehand));

                document.getElementById('backgroundSelect').value = tab.background;
                this.zoom = tab.zoom;

                // RIPRISTINA DIMENSIONE E BORDI
                this.setCanvasSize(tab.canvasSize || 'custom');

                // ‚úÖ NUOVO: Ripristina dimensioni custom se presenti
                if (tab.canvasSize === 'custom' && tab.customWidth && tab.customHeight) {
                    canvas.style.width = tab.customWidth + 'px';
                    canvas.style.height = tab.customHeight + 'px';
                }

                // ‚úÖ AGGIUNGI TIMEOUT per aggiornare handle dopo il caricamento
                setTimeout(() => {
                    this.updateAllResizeHandles();
                }, 150);

                if (tab.showBorder) {
                    canvas.classList.add('show-border');
                } else {
                    canvas.classList.remove('show-border');
                }

                if (tab.floatingToolbars) {
                    tab.floatingToolbars.forEach(data => {
                        const group = document.createElement('div');
                        group.innerHTML = data.html;
                        const element = group.firstElementChild;
                        element.classList.add('floating');
                        element.style.position = 'fixed';
                        element.style.left = data.x + 'px';
                        element.style.top = data.y + 'px';
                        element.style.zIndex = '9999';
                        document.body.appendChild(element);

                        this.floatingToolbarGroups.set(data.id, {
                            element: element,
                            x: data.x,
                            y: data.y
                        });
                    });
                }

                this.updateResizeHandlePosition();
                this.updateBackground();
                this.updateZoom();
                this.updateGrid();
                this.updateBWMode();
                this.deselectAll();
                this.updateAllResizeHandles();
            }

            saveState(description = 'Modifica') {
                const tab = this.getCurrentTab();
                const state = {
                    objects: Array.from(tab.objects.entries()),
                    arrows: Array.from(tab.arrows.entries()),
                    freehands: Array.from(tab.freehands.entries()),
                    timestamp: Date.now(),
                    description: description
                };

                if (tab.historyIndex < tab.history.length - 1) {
                    tab.history = tab.history.slice(0, tab.historyIndex + 1);
                }

                tab.history.push(state);
                tab.historyIndex++;

                // Salva metadati per questa modifica
                const historyKey = `${this.activeTabId}-${tab.historyIndex}`;
                this.historyMetadata.set(historyKey, {
                    tabId: this.activeTabId,
                    index: tab.historyIndex,
                    timestamp: state.timestamp,
                    description: description,
                    objectCount: tab.objects.size,
                    arrowCount: tab.arrows.size,
                    freehandCount: tab.freehands.size
                });

                if (tab.history.length > 50) {
                    tab.history.shift();
                    tab.historyIndex--;
                }
            }

            undo() {
                const tab = this.getCurrentTab();
                if (tab.historyIndex > 0) {
                    tab.historyIndex--;
                    this.restoreState(tab.history[tab.historyIndex]);
                }
            }

            redo() {
                const tab = this.getCurrentTab();
                if (tab.historyIndex < tab.history.length - 1) {
                    tab.historyIndex++;
                    this.restoreState(tab.history[tab.historyIndex]);
                }
            }

            restoreState(state) {
                const tab = this.getCurrentTab();
                tab.objects = new Map(state.objects);
                tab.arrows = new Map(state.arrows);
                tab.freehands = new Map(state.freehands);
                this.loadTabState();
            }

            initHistoryDialog() {
                const dialog = document.getElementById('historyDialog');
                const header = document.getElementById('historyDialogHeader');
                const closeBtn = document.getElementById('closeHistoryDialog');

                let isDragging = false;
                let currentX = 0;
                let currentY = 0;
                let initialX = 0;
                let initialY = 0;

                header.addEventListener('mousedown', (e) => {
                    const rect = dialog.getBoundingClientRect();
                    initialX = e.clientX - rect.left;
                    initialY = e.clientY - rect.top;
                    isDragging = true;
                    header.style.cursor = 'grabbing';
                    dialog.style.transform = 'none';
                    dialog.style.left = rect.left + 'px';
                    dialog.style.top = rect.top + 'px';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    dialog.style.left = currentX + 'px';
                    dialog.style.top = currentY + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        header.style.cursor = 'move';
                    }
                });

                closeBtn.addEventListener('click', () => {
                    dialog.classList.remove('active');
                });

                document.getElementById('restoreHistoryBtn').addEventListener('click', () => {
                    this.restoreSelectedHistory();
                });

                document.getElementById('deleteHistoryBtn').addEventListener('click', () => {
                    this.deleteSelectedHistory();
                });

                document.getElementById('compareHistoryBtn').addEventListener('click', () => {
                    this.compareWithCurrent();
                });
            }

            showHistoryDialog() {
                const dialog = document.getElementById('historyDialog');
                dialog.classList.add('active');
                this.renderHistoryList();
            }

            renderHistoryList() {
                const tab = this.getCurrentTab();
                const container = document.getElementById('historyList');
                container.innerHTML = '';

                if (!tab.history || tab.history.length === 0) {
                    container.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Nessuna modifica nello storico</div>';
                    return;
                }

                tab.history.forEach((state, index) => {
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    item.dataset.index = index;

                    if (index === tab.historyIndex) {
                        item.classList.add('current');
                    }

                    const time = new Date(state.timestamp);
                    const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;

                    const historyKey = `${this.activeTabId}-${index}`;
                    const metadata = this.historyMetadata.get(historyKey) || {
                        description: state.description || 'Modifica',
                        objectCount: state.objects?.length || 0,
                        arrowCount: state.arrows?.length || 0,
                        freehandCount: state.freehands?.length || 0
                    };

                    item.innerHTML = `
            <div class="history-item-time">${timeStr}</div>
            <div class="history-item-info">${metadata.description}</div>
            <div class="history-item-details">
                üì¶ ${metadata.objectCount} obj | 
                ‚û°Ô∏è ${metadata.arrowCount} frecce | 
                ‚úèÔ∏è ${metadata.freehandCount} disegni
            </div>
        `;

                    item.addEventListener('click', () => {
                        this.selectHistoryItem(index);
                    });

                    container.appendChild(item);
                });

                // Scroll all'elemento corrente
                const currentItem = container.querySelector('.history-item.current');
                if (currentItem) {
                    currentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            selectHistoryItem(index) {
                const tab = this.getCurrentTab();

                // Rimuovi selezione precedente
                document.querySelectorAll('.history-item').forEach(item => {
                    item.classList.remove('selected');
                });

                // Seleziona nuovo item
                const selectedItem = document.querySelector(`.history-item[data-index="${index}"]`);
                if (selectedItem) {
                    selectedItem.classList.add('selected');
                }

                // Abilita i pulsanti
                document.getElementById('restoreHistoryBtn').disabled = false;
                document.getElementById('deleteHistoryBtn').disabled = (index === tab.historyIndex);
                document.getElementById('compareHistoryBtn').disabled = false;

                // Mostra preview
                this.showHistoryPreview(index);
            }

            showHistoryPreview(index) {
                const tab = this.getCurrentTab();
                const state = tab.history[index];

                if (!state) return;

                const previewCanvas = document.getElementById('historyPreviewCanvas');
                const previewTitle = document.getElementById('historyPreviewTitle');
                const previewStats = document.getElementById('historyPreviewStats');

                const time = new Date(state.timestamp);
                const timeStr = time.toLocaleString('it-IT');

                previewTitle.textContent = `Anteprima: ${state.description || 'Modifica'} (${timeStr})`;

                // Crea una preview miniaturizzata
                previewCanvas.innerHTML = '';

                const miniCanvas = document.createElement('div');
                miniCanvas.style.cssText = `
        width: 100%;
        height: 100%;
        position: relative;
        transform: scale(0.5);
        transform-origin: top left;
        background: white;
    `;

                // Rendering oggetti
                if (state.objects) {
                    state.objects.forEach(([id, obj]) => {
                        const element = document.createElement('div');
                        element.style.cssText = `
                position: absolute;
                left: ${obj.x}px;
                top: ${obj.y}px;
                width: ${obj.width}px;
                height: ${obj.height}px;
                background: ${obj.color};
                opacity: ${obj.opacity || 1};
                transform: rotate(${obj.rotation}deg);
                border: ${obj.dashed ? '2px dashed' : '2px solid'} #333;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
                color: white;
                text-shadow: 1px 1px 2px black;
            `;
                        element.textContent = obj.text || '';
                        miniCanvas.appendChild(element);
                    });
                }

                // Rendering frecce (semplificato)
                if (state.arrows) {
                    state.arrows.forEach(([id, arrow]) => {
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.style.cssText = `
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            `;

                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        const from = arrow.from.x !== undefined ? arrow.from : { x: 0, y: 0 };
                        const to = arrow.to.x !== undefined ? arrow.to : { x: 100, y: 100 };

                        line.setAttribute('x1', from.x);
                        line.setAttribute('y1', from.y);
                        line.setAttribute('x2', to.x);
                        line.setAttribute('y2', to.y);
                        line.setAttribute('stroke', arrow.color || '#000');
                        line.setAttribute('stroke-width', arrow.thickness || 2);

                        if (arrow.dashed) {
                            line.setAttribute('stroke-dasharray', '5,5');
                        }

                        svg.appendChild(line);
                        miniCanvas.appendChild(svg);
                    });
                }

                previewCanvas.appendChild(miniCanvas);

                // Mostra statistiche
                const historyKey = `${this.activeTabId}-${index}`;
                const metadata = this.historyMetadata.get(historyKey) || {};

                previewStats.innerHTML = `
        <div><strong>üìÖ Timestamp:</strong> ${timeStr}</div>
        <div><strong>üì¶ Oggetti:</strong> ${state.objects?.length || 0}</div>
        <div><strong>‚û°Ô∏è Frecce:</strong> ${state.arrows?.length || 0}</div>
        <div><strong>‚úèÔ∏è Disegni:</strong> ${state.freehands?.length || 0}</div>
        <div><strong>üìù Descrizione:</strong> ${state.description || 'Nessuna descrizione'}</div>
        ${index === tab.historyIndex ? '<div style="color: #28a745; font-weight: bold;">‚úÖ Stato Corrente</div>' : ''}
    `;
            }

            restoreSelectedHistory() {
                const selectedItem = document.querySelector('.history-item.selected');
                if (!selectedItem) return;

                const index = parseInt(selectedItem.dataset.index);
                const tab = this.getCurrentTab();

                if (confirm(`Ripristinare lo stato: "${tab.history[index].description}"?\n\nQuesta azione creer√† un nuovo punto nello storico.`)) {
                    tab.historyIndex = index;
                    this.restoreState(tab.history[index]);

                    // Crea un nuovo punto nello storico per il ripristino
                    this.saveState(`Ripristinato: ${tab.history[index].description}`);

                    this.renderHistoryList();
                    this.showHistoryPreview(tab.historyIndex);

                    alert('‚úÖ Stato ripristinato con successo!');
                }
            }

            deleteSelectedHistory() {
                const selectedItem = document.querySelector('.history-item.selected');
                if (!selectedItem) return;

                const index = parseInt(selectedItem.dataset.index);
                const tab = this.getCurrentTab();

                if (index === tab.historyIndex) {
                    alert('‚ùå Non puoi eliminare lo stato corrente');
                    return;
                }

                if (confirm(`Eliminare la modifica: "${tab.history[index].description}"?`)) {
                    tab.history.splice(index, 1);

                    // Aggiorna historyIndex se necessario
                    if (tab.historyIndex >= index) {
                        tab.historyIndex--;
                    }

                    // Rimuovi metadati
                    const historyKey = `${this.activeTabId}-${index}`;
                    this.historyMetadata.delete(historyKey);

                    this.renderHistoryList();
                    document.getElementById('historyPreviewCanvas').innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Seleziona una modifica</div>';
                    document.getElementById('historyPreviewStats').innerHTML = '';
                    document.getElementById('restoreHistoryBtn').disabled = true;
                    document.getElementById('deleteHistoryBtn').disabled = true;
                    document.getElementById('compareHistoryBtn').disabled = true;
                }
            }

            compareWithCurrent() {
                const selectedItem = document.querySelector('.history-item.selected');
                if (!selectedItem) return;

                const index = parseInt(selectedItem.dataset.index);
                const tab = this.getCurrentTab();
                const selectedState = tab.history[index];
                const currentState = tab.history[tab.historyIndex];

                const previewStats = document.getElementById('historyPreviewStats');

                const selectedObjects = selectedState.objects?.length || 0;
                const currentObjects = currentState.objects?.length || 0;
                const selectedArrows = selectedState.arrows?.length || 0;
                const currentArrows = currentState.arrows?.length || 0;
                const selectedFreehands = selectedState.freehands?.length || 0;
                const currentFreehands = currentState.freehands?.length || 0;

                previewStats.innerHTML = `
        <div class="history-comparison">
            <div class="comparison-side">
                <div class="comparison-title">Stato Selezionato</div>
                <div>üì¶ Oggetti: ${selectedObjects}</div>
                <div>‚û°Ô∏è Frecce: ${selectedArrows}</div>
                <div>‚úèÔ∏è Disegni: ${selectedFreehands}</div>
            </div>
            <div class="comparison-side">
                <div class="comparison-title">Stato Corrente</div>
                <div>üì¶ Oggetti: ${currentObjects}</div>
                <div>‚û°Ô∏è Frecce: ${currentArrows}</div>
                <div>‚úèÔ∏è Disegni: ${currentFreehands}</div>
            </div>
        </div>
        <div style="margin-top: 10px; padding: 10px; background: ${selectedObjects === currentObjects && selectedArrows === currentArrows && selectedFreehands === currentFreehands ? '#d4edda' : '#fff3cd'}; border-radius: 4px;">
            ${selectedObjects === currentObjects && selectedArrows === currentArrows && selectedFreehands === currentFreehands ?
                        '‚úÖ Gli stati hanno lo stesso numero di elementi' :
                        `‚ö†Ô∏è Differenze: ${Math.abs(selectedObjects - currentObjects)} oggetti, ${Math.abs(selectedArrows - currentArrows)} frecce, ${Math.abs(selectedFreehands - currentFreehands)} disegni`
                    }
        </div>
    `;
            }


            saveSchema() {
                const tab = this.getCurrentTab();
                tab.objects.forEach(obj => {
                    if (obj.type === 'sprite' && obj.animationInterval) {
                        clearInterval(obj.animationInterval);
                        delete obj.animationInterval;
                    }
                });

                const data = {
                    title: tab.name || 'schema',
                    note: tab.descrizione || '',
                    tipologia: tab.tipologia || 'GEN',
                    ruolo: tab.ruolo || 'GEN',
                    periodo: tab.periodo || 'GEN',
                    autore: tab.autore || this.currentUser,
                    nr: tab.nr,
                    series: tab.series,
                    timing: tab.timing,
                    rec: tab.rec,
                    place: tab.place,
                    date: tab.date,
                    groups: tab.groups,
                    objects: Array.from(tab.objects.entries()),
                    arrows: Array.from(tab.arrows.entries()),
                    background: tab.background,
                    gridVisible: tab.gridVisible,
                    bwMode: tab.bwMode,
                    zoom: tab.zoom,
                    canvasSize: tab.canvasSize || 'custom',
                    showBorder: tab.showBorder || false,
                    maxZIndex: this.maxZIndex,
                    freehands: Array.from(tab.freehands.entries()),
                    frames: tab.frames.map(frame => ({
                        id: frame.id,
                        number: frame.number,
                        objects: Array.from(frame.objects.entries())
                    })),
                    animationSpeed: tab.animationSpeed || 1000,
                    exerciseSteps: tab.exerciseSteps || []
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${tab.periodo}.${tab.tipologia}.${tab.ruolo}.${tab.name.replace(/\s+/g, '_')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async loadSchema(source) {
                let data = null;

                // Caso 1: Caricamento da libreria (Promise)
                if (typeof source === 'object' && source !== null && typeof source.then === 'function') {
                    try {
                        data = await source;
                    } catch (error) {
                        alert('Errore nel caricamento dei dati dalla libreria.');
                        console.error('Errore Promise:', error);
                        return;
                    }
                }
                // Caso 2: Caricamento da file locale (Event)
                else if (source && source.target && source.target.files) {
                    const file = source.target.files[0];
                    if (!file) return;

                    try {
                        const fileContent = await file.text();
                        data = JSON.parse(fileContent);
                    } catch (error) {
                        alert('Errore nel caricamento del file: ' + error.message);
                        console.error('Errore caricamento file:', error);
                        return;
                    }

                    // Reset dell'input per permettere di caricare lo stesso file di nuovo
                    source.target.value = '';
                } else {
                    console.error('Formato di input non riconosciuto per loadSchema');
                    return;
                }

                // A questo punto 'data' contiene i dati caricati, procediamo con l'applicazione
                if (!data) {
                    alert('Nessun dato da caricare');
                    return;
                }

                const tab = this.getCurrentTab();

                // Pulisci lo stato corrente
                tab.objects.clear();
                tab.arrows.clear();
                tab.freehands.clear();
                tab.canvasSize = data.canvasSize || 'custom';
                tab.showBorder = data.showBorder || false;
                if (data.maxZIndex) {
                    this.maxZIndex = data.maxZIndex;
                    tab.maxZIndex = data.maxZIndex;
                }
                // APPLICA DIMENSIONE E BORDI
                this.setCanvasSize(tab.canvasSize);
                document.getElementById('canvasSizeSelect').value = tab.canvasSize;

                if (tab.showBorder) {
                    document.getElementById('canvas').classList.add('show-border');
                    document.getElementById('toggleCanvasBorder').classList.add('active');
                }
                // Carica gli oggetti
                if (data.objects) {
                    let maxNumber = 0;
                    data.objects.forEach(([id, obj]) => {
                        if (!obj.objectNumber) {
                            obj.objectNumber = ++maxNumber;
                        } else {
                            maxNumber = Math.max(maxNumber, obj.objectNumber);
                        }
                        tab.objects.set(id, obj);
                    });
                }
                if (data.arrows) {
                    data.arrows.forEach(([id, arrow]) => tab.arrows.set(id, arrow));
                }
                if (data.freehands) {
                    data.freehands.forEach(([id, freehand]) => tab.freehands.set(id, freehand));
                }

                // Imposta le propriet√† del tab
                tab.background = data.background || 'none';
                tab.gridVisible = data.gridVisible !== undefined ? data.gridVisible : true;
                tab.bwMode = data.bwMode || false;
                tab.zoom = data.zoom || 1;
                tab.periodo = data.periodo || 'GEN';
                tab.ruolo = data.ruolo || 'GEN';
                tab.tipologia = data.tipologia || 'GEN';
                tab.genere = data.genere || 'GEN';
                tab.categoria = data.categoria || 'GEN';
                tab.descrizione = data.note || data.descrizione || '';
                tab.autore = data.autore || this.currentUser || 'unknown';
                tab.date = data.date || new Date();
                tab.place = data.place || "";
                tab.nr = data.nr || 1;
                tab.series = data.series || 1;
                tab.groups = data.groups || 1;
                tab.timing = data.timing || 10;      // ‚úÖ AGGIUNTO
                tab.rec = data.rec || 60;            // ‚úÖ AGGIUNTO                
                tab.exerciseSteps = data.exerciseSteps || [];

                this.initExerciseSteps();
                this.renderStepsList();

                if (data.frames) {
                    tab.frames = data.frames.map(frameData => ({
                        id: frameData.id,
                        number: frameData.number,
                        objects: new Map(frameData.objects)
                    }));
                    tab.currentFrameIndex = 0;
                } else {
                    tab.frames = [];
                    tab.currentFrameIndex = 0;
                }

                if (data.animationSpeed) {
                    tab.animationSpeed = data.animationSpeed;
                    document.getElementById('animationSpeed').value = data.animationSpeed;
                }

                // Aggiorna il nome del tab se presente
                if (data.title) {
                    tab.name = data.title;
                    const activeTabElement = document.querySelector('.tab.active');
                    if (activeTabElement) {
                        const tabInput = activeTabElement.querySelector('.tab-title');
                        if (tabInput) {
                            tabInput.value = data.title;
                        }
                    }
                }

                // Aggiorna i campi della UI
                document.getElementById('schemaTitle').value = data.title || 'Schema';
                document.getElementById('workoutPeriodo').value = tab.periodo;
                document.getElementById('workoutRuolo').value = tab.ruolo;
                document.getElementById('workoutTipologia').value = tab.tipologia;
                document.getElementById('workoutGenere').value = tab.genere;
                document.getElementById('workoutCategoria').value = tab.categoria;
                document.getElementById('workoutDescrizione').value = tab.descrizione;
                document.getElementById('workoutAutore').value = tab.autore;
                document.getElementById('workoutDate').value = tab.date;
                document.getElementById('workoutPlace').value = tab.place;
                document.getElementById('workoutNr').value = tab.nr;
                document.getElementById('workoutSeries').value = tab.series;
                document.getElementById('workoutGroups').value = tab.groups;
                document.getElementById('workoutTiming').value = tab.timing;
                document.getElementById('workoutRec').value = tab.rec;
                // Applica il filtro per le categorie in base al genere
                this.filterCategoriesByGenere(tab.genere);

                // Ricarica lo stato visivo
                this.loadTabState();
                this.saveState(`Dati caricati con successo`);

                console.log("Dati caricati con successo");
            }

            async exportSchema() {
                const canvas = document.getElementById('canvas');
                const tab = this.getCurrentTab();

                // Nascondi elementi UI
                const sidebar = document.getElementById('sidebar');
                const rightSidebar = document.getElementById('rightSidebar');
                const watermark = document.getElementById('watermark');

                const originalSidebarDisplay = sidebar ? sidebar.style.display : 'none';
                const originalRightSidebarDisplay = rightSidebar ? rightSidebar.style.display : 'none';
                const originalWatermarkDisplay = watermark ? watermark.style.display : 'none';

                if (sidebar) sidebar.style.display = 'none';
                if (rightSidebar) rightSidebar.style.display = 'none';
                if (watermark) watermark.style.display = 'none';

                // Nascondi tutti i controlli interattivi
                const interactiveElements = canvas.querySelectorAll(
                    '.resize-handle, .rotate-handle, .connection-point, .control-point, .endpoint-control, .group-rotation-center, .object-label'
                );
                const hiddenElements = [];
                interactiveElements.forEach(el => {
                    if (el.style.display !== 'none') {
                        hiddenElements.push(el);
                        el.style.display = 'none';
                    }
                });

                try {
                    // Prepara il canvas per l'export
                    const originalState = this.prepareCanvasForExport();

                    // Attendi che il browser applichi tutte le modifiche
                    await new Promise(resolve => setTimeout(resolve, 300));

                    // Dimensioni fisse per evitare problemi di scala
                    const exportWidth = 1600;
                    const exportHeight = 1200;

                    const exportCanvas = await html2canvas(canvas, {
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,
                        backgroundColor: tab.bwMode ? null : '#ffffff',
                        logging: false,
                        width: exportWidth,
                        height: exportHeight,
                        windowWidth: exportWidth,
                        windowHeight: exportHeight,
                        scrollX: 0,
                        scrollY: 0,
                        foreignObjectRendering: false,
                        onclone: (clonedDoc) => {
                            const clonedCanvas = clonedDoc.getElementById('canvas');
                            if (clonedCanvas) {
                                clonedCanvas.style.transform = 'none';
                                clonedCanvas.style.position = 'relative';
                                clonedCanvas.style.overflow = 'visible';

                                // Forza SVG con posizioni assolute per frecce
                                const svgs = clonedCanvas.querySelectorAll('.arrow-svg');
                                svgs.forEach(svg => {
                                    svg.style.position = 'absolute';
                                    svg.style.left = '0';
                                    svg.style.top = '0';
                                });

                                // ‚úÖ AGGIUNTO: Forza SVG con posizioni assolute per freehands
                                const freehandSvgs = clonedCanvas.querySelectorAll('.freehand-svg');
                                freehandSvgs.forEach(svg => {
                                    svg.style.position = 'absolute';
                                    svg.style.left = '0';
                                    svg.style.top = '0';
                                    svg.style.pointerEvents = 'none';
                                });

                                // Assicura che tutti gli oggetti abbiano posizioni corrette
                                const objects = clonedCanvas.querySelectorAll('.canvas-object');
                                objects.forEach(obj => {
                                    const objData = tab.objects.get(obj.id);
                                    if (objData) {
                                        obj.style.left = objData.x + 'px';
                                        obj.style.top = objData.y + 'px';
                                        obj.style.transform = `rotate(${objData.rotation}deg)`;
                                    }
                                });
                            }
                        }
                    });

                    // Ripristina lo stato originale del canvas
                    canvas.style.transform = originalState.transform;
                    canvas.style.overflow = originalState.overflow;
                    canvas.style.position = originalState.position;

                    // Re-renderizza normalmente
                    tab.arrows.forEach(arrow => this.renderArrow(arrow));
                    // ‚úÖ AGGIUNTO: Re-renderizza i freehands normalmente
                    tab.freehands.forEach(freehand => this.renderFreehand(freehand));

                    const format = prompt('Formato di esportazione (png/jpg/pdf):', 'png');
                    const title = document.getElementById('schemaTitle').value || 'schema';

                    switch (format?.toLowerCase()) {
                        case 'png':
                            this.downloadCanvas(exportCanvas, `${title}.png`, 'image/png');
                            break;
                        case 'jpg':
                        case 'jpeg':
                            this.downloadCanvas(exportCanvas, `${title}.jpg`, 'image/jpeg');
                            break;
                        case 'pdf':
                            this.exportToPDF(exportCanvas, title);
                            break;
                        default:
                            this.downloadCanvas(exportCanvas, `${title}.png`, 'image/png');
                    }
                } catch (error) {
                    console.error('Errore durante l\'esportazione:', error);
                    alert('Errore durante l\'esportazione: ' + error.message);
                } finally {
                    // Ripristina tutti gli elementi nascosti
                    hiddenElements.forEach(el => el.style.display = '');

                    if (sidebar) sidebar.style.display = originalSidebarDisplay;
                    if (rightSidebar) rightSidebar.style.display = originalRightSidebarDisplay;
                    if (watermark) watermark.style.display = originalWatermarkDisplay;
                }
            }

            // Metodo downloadCanvas rimane invariato
            downloadCanvas(canvas, filename, mimeType) {
                const link = document.createElement('a');
                link.download = filename;
                link.href = canvas.toDataURL(mimeType);
                link.click();

            }

            // Metodo exportToPDF aggiornato per utilizzare il canvas gi√† esportato correttamente
            exportToPDF(exportCanvas, title) {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('l', 'pt', 'a4');
                const imgData = exportCanvas.toDataURL('image/png');

                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();

                // Margini
                const margin = 40;
                const availableWidth = pageWidth - (margin * 2);
                const availableHeight = pageHeight - (margin * 2);

                // Calcola dimensioni mantenendo proporzioni
                const ratio = Math.min(availableWidth / exportCanvas.width, availableHeight / exportCanvas.height);
                const imgWidth = exportCanvas.width * ratio;
                const imgHeight = exportCanvas.height * ratio;

                // Centra l'immagine
                const x = (pageWidth - imgWidth) / 2;
                const y = (pageHeight - imgHeight) / 2;

                pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);

                // Watermark in basso a destra
                pdf.setFontSize(12);
                pdf.setTextColor(150, 150, 150);
                pdf.text("spikecode", pageWidth - 80, pageHeight - 20);

                pdf.save(`${title}.pdf`);
            }


            handleKeyboard(e) {
                // NUOVO: Gestione movimento con frecce direzionali
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();

                    if (this.selectedObjects.size === 0) return;

                    // Distanza di movimento (pixel)
                    const moveStep = e.shiftKey ? 10 : 1; // Shift per movimento pi√π veloce

                    let deltaX = 0;
                    let deltaY = 0;

                    switch (e.key) {
                        case 'ArrowUp':
                            deltaY = -moveStep;
                            break;
                        case 'ArrowDown':
                            deltaY = moveStep;
                            break;
                        case 'ArrowLeft':
                            deltaX = -moveStep;
                            break;
                        case 'ArrowRight':
                            deltaX = moveStep;
                            break;
                    }

                    const tab = this.getCurrentTab();

                    this.selectedObjects.forEach((pos, id) => {
                        const objectData = tab.objects.get(id);
                        if (objectData) {
                            objectData.x += deltaX;
                            objectData.y += deltaY;

                            const element = document.getElementById(id);
                            if (element) {
                                element.style.left = objectData.x + 'px';
                                element.style.top = objectData.y + 'px';
                            }

                            this.updateArrowsForObject(id);
                        } else if (pos.type === 'freehand') {
                            // Gestione freehands
                            const freehand = tab.freehands.get(id);
                            if (freehand) {
                                freehand.points = freehand.points.map(p => ({
                                    x: p.x + deltaX,
                                    y: p.y + deltaY
                                }));
                                this.renderFreehand(freehand);
                            }
                        }
                    });

                    this.updateCurrentFrame();
                    this.saveState(`Spostato ${this.selectedObjects.size} oggetti`);
                    return;
                }

                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 'c':
                            e.preventDefault();
                            this.copySelected();
                            break;
                        case 'x':
                            e.preventDefault();
                            this.cutSelected();
                            break;
                        case 'v':
                            e.preventDefault();
                            this.paste();
                            break;
                        case 'a':
                            e.preventDefault();
                            this.selectAll();
                            break;
                        case 'z':
                            e.preventDefault();
                            if (e.shiftKey) {
                                this.redo();
                            } else {
                                this.undo();
                            }
                            break;
                        case 'y':
                            e.preventDefault();
                            this.redo();
                            break;
                        case ']':
                            e.preventDefault();
                            this.bringToFront();
                            break;
                        case '[':
                            e.preventDefault();
                            this.sendToBack();
                            break;
                    }
                } else if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (this.selectedObjects.size > 0 || this.selectedArrow) {
                        e.preventDefault();
                        this.deleteSelected();
                    }
                } else if (e.key === 'Escape') {
                    if (this.isConnecting) {
                        this.isConnecting = false;
                        this.connectionStart = null;
                        if (this.connectionPreview) {
                            this.connectionPreview.svg.remove();
                            this.connectionPreview = null;
                        }
                        document.getElementById('canvas').style.cursor = 'default';
                    } else {
                        this.deselectAll();
                    }
                }
            }
            selectAll() {
                this.deselectAll();
                const tab = this.getCurrentTab();

                // Seleziona tutti gli oggetti
                tab.objects.forEach((obj, id) => {
                    this.selectedObjects.set(id, { x: obj.x, y: obj.y });
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.add('selected', 'group-selected');
                    }
                });

                // ‚úÖ AGGIUNTO: Seleziona anche tutti i disegni a mano libera
                tab.freehands.forEach((freehand, id) => {
                    this.selectedObjects.set(id, {
                        type: 'freehand',
                        points: [...freehand.points] // Copia i punti
                    });
                    const svg = document.getElementById(id);
                    if (svg) {
                        const path = svg.querySelector('.freehand-path');
                        if (path) path.classList.add('selected');
                    }
                });

                // Mostra il centro di rotazione del gruppo se ci sono pi√π oggetti
                if (this.selectedObjects.size > 1) {
                    this.showGroupRotationCenter();
                }

                this.updateObjectControls();
            }

            updateUI() {
                this.updateBackground();
                this.updateGrid();
                this.updateBWMode();
                this.updateZoom();
            }
            prepareCanvasForExport() {
                const canvas = document.getElementById('canvas');
                const tab = this.getCurrentTab();

                // Salva lo stato corrente
                const originalState = {
                    transform: canvas.style.transform,
                    overflow: canvas.style.overflow,
                    position: canvas.style.position
                };

                // Resetta le trasformazioni per l'export
                canvas.style.transform = 'none';
                canvas.style.overflow = 'visible';
                canvas.style.position = 'relative';

                // Forza il re-render di tutti gli oggetti e frecce con posizioni assolute
                tab.objects.forEach(obj => {
                    const element = document.getElementById(obj.id);
                    if (element) {
                        element.style.left = obj.x + 'px';
                        element.style.top = obj.y + 'px';
                        element.style.transform = `rotate(${obj.rotation}deg)`;
                    }
                });

                // Re-renderizza tutte le frecce
                tab.arrows.forEach(arrow => {
                    this.renderArrowForExport(arrow);
                });

                // ‚úÖ AGGIUNTO: Re-renderizza tutti i disegni a mano libera
                tab.freehands.forEach(freehand => {
                    this.renderFreehandForExport(freehand);
                });

                return originalState;
            }
            renderFreehandForExport(freehand) {
                let svg = document.getElementById(freehand.id);
                if (!svg) return;

                // Usa viewBox assoluto invece di relativo
                const minX = 0;
                const minY = 0;
                const maxX = Math.max(document.getElementById('canvas').offsetWidth, 2000);
                const maxY = Math.max(document.getElementById('canvas').offsetHeight, 2000);

                svg.style.left = '0px';
                svg.style.top = '0px';
                svg.style.width = maxX + 'px';
                svg.style.height = maxY + 'px';
                svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);

                // Aggiorna il path con coordinate assolute
                const path = svg.querySelector('.freehand-path');
                if (path) {
                    const pathData = this.pointsToPath(freehand.points);
                    path.setAttribute('d', pathData);
                }
            }

            renderArrowForExport(arrow) {
                let fromPos = this.getArrowPoint(arrow.from);
                let toPos = this.getArrowPoint(arrow.to);

                let svg = document.getElementById(arrow.id);
                if (!svg) return;

                // Usa viewBox assoluto invece di relativo
                const minX = 0;
                const minY = 0;
                const maxX = Math.max(document.getElementById('canvas').offsetWidth, 2000);
                const maxY = Math.max(document.getElementById('canvas').offsetHeight, 2000);

                svg.style.left = '0px';
                svg.style.top = '0px';
                svg.style.width = maxX + 'px';
                svg.style.height = maxY + 'px';
                svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);

                // Aggiorna il path con coordinate assolute
                const path = svg.querySelector('.arrow-path');
                if (path) {
                    const pathData = this.generateArrowPath(fromPos, toPos, arrow.type, arrow.controlPoint);
                    path.setAttribute('d', pathData);
                }
            }

            async exportWorkoutToPDF() {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'p',
                    unit: 'mm',
                    format: 'a4'
                });

                const margin = 15;
                const lineSpacing = 5; // Ridotto da 6 a 5
                const fontTitleSize = 11; // Ridotto da 14 a 11
                const fontSubtitleSize = 10; // Ridotto da 12 a 10
                const fontNormalSize = 8; // Ridotto da 10 a 8
                const colWidth = 85;
                const drawingX = margin;
                const stepsX = margin + colWidth + 5;
                const pageHeight = doc.internal.pageSize.getHeight();
                const maxY = pageHeight - 20;

                let yOffset = 15;
                let isFirstTab = true;

                for (const [tabId, tab] of this.tabs) {
                    const previousActiveTab = this.activeTabId;
                    if (this.activeTabId !== tabId) {
                        this.switchToTab(tabId);
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }

                    let estimatedHeight = lineSpacing * 3;

                    if (tab.descrizione && tab.descrizione.trim() !== "") {
                        const descLines = doc.splitTextToSize(tab.descrizione, 180);
                        estimatedHeight += (descLines.length * lineSpacing) + lineSpacing * 2;
                    }

                    estimatedHeight += 80;

                    if (!isFirstTab && yOffset + estimatedHeight > maxY) {
                        doc.addPage();
                        yOffset = margin;
                    }

                    // Titolo esercizio
                    doc.setFontSize(fontTitleSize);
                    doc.setFont(undefined, 'bold');
                    doc.text(tab.name.toUpperCase(), margin, yOffset);
                    yOffset += lineSpacing * 1.2;

                    // Info base
                    doc.setFontSize(fontNormalSize);
                    doc.setFont(undefined, 'normal');
                    const date = tab.date ? new Date(tab.date).toLocaleDateString('it-IT') : new Date().toLocaleDateString('it-IT');

                    const categoryOptions = document.getElementById('workoutCategoria').options;
                    const category = Array.from(categoryOptions).find(opt => opt.value === tab.categoria)?.text || tab.categoria || '-';

                    const genreOptions = document.getElementById('workoutGenere').options;
                    const genre = Array.from(genreOptions).find(opt => opt.value === tab.genere)?.text || tab.genere || '-';

                    doc.text(`Data: ${date}`, margin, yOffset);
                    doc.text(`Categoria: ${category}`, margin + 45, yOffset);
                    doc.text(`Genere: ${genre}`, margin + 100, yOffset);
                    yOffset += lineSpacing * 1.2;

                    // Descrizione/Obiettivo (pi√π compatta)
                    if (tab.descrizione && tab.descrizione.trim() !== "") {
                        const descLines = doc.splitTextToSize(tab.descrizione, 180);
                        const descHeight = (descLines.length * lineSpacing) + lineSpacing * 1.5;

                        if (yOffset + descHeight > maxY) {
                            doc.addPage();
                            yOffset = margin;
                        }

                        doc.setFontSize(fontSubtitleSize);
                        doc.setFont(undefined, 'bold');
                        doc.text('Descrizione/Obiettivo', margin, yOffset);
                        doc.setLineWidth(0.3);
                        doc.line(margin, yOffset + 0.8, 195, yOffset + 0.8);
                        yOffset += lineSpacing * 0.8;

                        doc.setFontSize(fontNormalSize);
                        doc.setFont(undefined, 'normal');
                        doc.text(descLines, margin, yOffset);
                        yOffset += descLines.length * lineSpacing + lineSpacing;
                    }

                    if (yOffset + lineSpacing * 2 > maxY) {
                        doc.addPage();
                        yOffset = margin;
                    }

                    const startYSection = yOffset;

                    // Serie, Ripetizioni, Recupero e Timing (pi√π compatti)
                    doc.setFontSize(fontNormalSize);
                    doc.setFont(undefined, 'normal');
                    const series = tab.series || '-';
                    const repetitions = tab.nr || '-';
                    const timing = tab.timing || 10;
                    const rec = tab.rec || 60;
                    doc.text(`Serie: ${series} | Rip: ${repetitions} | Rec: ${rec}s | Tempo: ${timing}min`, drawingX, yOffset);
                    yOffset += lineSpacing;

                    const canvasElement = document.getElementById('canvas');
                    const sidebar = document.getElementById('sidebar');
                    const rightSidebar = document.getElementById('rightSidebar');
                    const watermark = document.getElementById('watermark');

                    const originalSidebarDisplay = sidebar ? sidebar.style.display : 'none';
                    const originalRightSidebarDisplay = rightSidebar ? rightSidebar.style.display : 'none';
                    const originalWatermarkDisplay = watermark ? watermark.style.display : 'none';

                    if (sidebar) sidebar.style.display = 'none';
                    if (rightSidebar) rightSidebar.style.display = 'none';
                    if (watermark) watermark.style.display = 'none';

                    const interactiveElements = canvasElement.querySelectorAll(
                        '.resize-handle, .rotate-handle, .connection-point, .control-point, .endpoint-control, .group-rotation-center, .object-label'
                    );
                    const hiddenElements = [];
                    interactiveElements.forEach(el => {
                        if (el.style.display !== 'none') {
                            hiddenElements.push(el);
                            el.style.display = 'none';
                        }
                    });

                    try {
                        const originalState = this.prepareCanvasForExport();
                        await new Promise(resolve => setTimeout(resolve, 300));

                        const exportWidth = 1200;
                        const exportHeight = 800;

                        const canvasImage = await html2canvas(canvasElement, {
                            scale: 2,
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: tab.bwMode ? null : '#ffffff',
                            logging: false,
                            width: exportWidth,
                            height: exportHeight,
                            windowWidth: exportWidth,
                            windowHeight: exportHeight,
                            scrollX: 0,
                            scrollY: 0,
                            foreignObjectRendering: false,
                            onclone: (clonedDoc) => {
                                const clonedCanvas = clonedDoc.getElementById('canvas');
                                if (clonedCanvas) {
                                    clonedCanvas.style.transform = 'none';
                                    clonedCanvas.style.position = 'relative';
                                    const svgs = clonedCanvas.querySelectorAll('.arrow-svg');
                                    svgs.forEach(svg => {
                                        svg.style.position = 'absolute';
                                        svg.style.left = '0';
                                        svg.style.top = '0';
                                    });
                                }
                            }
                        });

                        canvasElement.style.transform = originalState.transform;
                        canvasElement.style.overflow = originalState.overflow;
                        canvasElement.style.position = originalState.position;
                        tab.arrows.forEach(arrow => this.renderArrow(arrow));

                        const imgWidth = colWidth;
                        const imgHeight = (canvasImage.height * imgWidth) / canvasImage.width;
                        const maxImgHeight = 120; // Ridotto da 150 a 120
                        const finalImgHeight = imgHeight > maxImgHeight ? maxImgHeight : imgHeight;

                        if (yOffset + finalImgHeight > maxY) {
                            doc.addPage();
                            yOffset = margin;
                        }

                        doc.addImage(canvasImage.toDataURL('image/jpeg', 0.9), 'JPEG', drawingX, yOffset, imgWidth, finalImgHeight);

                        const nextDrawingY = yOffset + finalImgHeight + lineSpacing;

                        let currentStepsY = startYSection + lineSpacing;

                        // Step (pi√π compatti)
                        const stepsArray = tab.exerciseSteps || [];
                        let stepsText = '';
                        stepsArray.forEach((step, index) => {
                            stepsText += `${index + 1}. ${step}\n`;
                        });

                        if (stepsText === '') {
                            stepsText = 'Nessuno step definito.';
                        }

                        doc.setFontSize(fontNormalSize);
                        doc.setFont(undefined, 'normal');
                        const stepsLines = doc.splitTextToSize(stepsText, colWidth);

                        stepsLines.forEach(line => {
                            if (currentStepsY > maxY) {
                                doc.addPage();
                                currentStepsY = margin;
                            }
                            doc.text(line, stepsX, currentStepsY);
                            currentStepsY += lineSpacing * 0.9; // Ridotto leggermente
                        });

                        yOffset = Math.max(nextDrawingY, currentStepsY) + lineSpacing * 1.5;

                    } finally {
                        hiddenElements.forEach(el => el.style.display = '');
                        if (sidebar) sidebar.style.display = originalSidebarDisplay;
                        if (rightSidebar) rightSidebar.style.display = originalRightSidebarDisplay;
                        if (watermark) watermark.style.display = originalWatermarkDisplay;
                    }

                    isFirstTab = false;
                }

                // Watermark finale
                const totalPages = doc.internal.getNumberOfPages();
                doc.setPage(totalPages);
                const pageWidth = doc.internal.pageSize.getWidth();
                doc.setFontSize(10);
                doc.setTextColor(150, 150, 150);
                doc.text("spikecode", pageWidth - 60, pageHeight - 20);

                const now = new Date();
                const timestamp = now.getFullYear() +
                    String(now.getMonth() + 1).padStart(2, '0') +
                    String(now.getDate()).padStart(2, '0') + "_" +
                    String(now.getHours()).padStart(2, '0') +
                    String(now.getMinutes()).padStart(2, '0');

                doc.save(`Allenamento_${timestamp}.pdf`);
                alert('Esportazione PDF completata con successo!');
            }

            async exportFormationSheet() {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'p',
                    unit: 'mm',
                    format: 'a4'
                });

                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 15;

                // Titolo
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text('FOGLIO FORMAZIONI', pageWidth / 2, 20, { align: 'center' });

                // Info partita
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');

                let yOffset = 35;

                // ============ PRIMA RIGA: 3 CAMPI ============
                const fieldWidth1 = 50;
                const spacing = 5;

                doc.text('SQUADRA: _____________________', margin, yOffset);
                doc.text('DATA: _____________', margin + fieldWidth1 + spacing, yOffset);
                doc.text('LUOGO: _____________', margin + (fieldWidth1 + spacing) * 2, yOffset);

                yOffset += 8;

                // ============ SECONDA RIGA: 2 CAMPI ============
                const fieldWidth2 = 80;

                doc.text('AVVERSARIO: __________________________________', margin, yOffset);
                doc.text('ARBITRO: __________________________________', margin + fieldWidth2 + spacing, yOffset);

                yOffset += 10;

                // ============ ELENCO NOMI FORMAZIONI ============
                doc.setFontSize(11);
                doc.setFont(undefined, 'bold');
                doc.text('ELENCO GIOCATORI:', margin, yOffset);
                yOffset += 5;

                doc.setFontSize(9);
                doc.setFont(undefined, 'normal');

                // Crea 3 colonne per i giocatori
                const col1X = margin;
                const col2X = margin + 60;
                const col3X = margin + 120;
                const lineHeight = 5;
                const maxPlayersPerColumn = 6;

                // Disegna le linee per i nomi (3 colonne da 6 righe)
                for (let i = 0; i < maxPlayersPerColumn; i++) {
                    const currentY = yOffset + (i * lineHeight);

                    // Colonna 1
                    doc.text(`${i + 1}.`, col1X, currentY);
                    doc.line(col1X + 5, currentY + 0.5, col1X + 50, currentY + 0.5);

                    // Colonna 2
                    doc.text(`${i + 7}.`, col2X, currentY);
                    doc.line(col2X + 5, currentY + 0.5, col2X + 50, currentY + 0.5);

                    // Colonna 3
                    doc.text(`${i + 13}.`, col3X, currentY);
                    doc.line(col3X + 5, currentY + 0.5, col3X + 50, currentY + 0.5);
                }

                yOffset += (maxPlayersPerColumn * lineHeight) + 10;

                // ============ DISEGNA I 5 SET (3 PER RIGA) ============
                const courtWidth = 55;
                const courtHeight = 45;
                const notesHeight = 25; // Altezza sezione note
                const horizontalSpacing = 8;
                const verticalSpacing = 8;
                const setsPerRow = 3;

                for (let set = 1; set <= 5; set++) {
                    // Calcola posizione nella griglia (3 colonne)
                    const col = (set - 1) % setsPerRow;
                    const row = Math.floor((set - 1) / setsPerRow);

                    const courtX = margin + col * (courtWidth + horizontalSpacing);
                    const courtY = yOffset + row * (courtHeight + notesHeight + verticalSpacing);

                    // Numero del set
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'bold');
                    doc.text(`SET ${set}`, courtX + courtWidth / 2, courtY, { align: 'center' });

                    // Disegna il mezzo campo
                    const fieldY = courtY + 3;

                    // Perimetro del campo
                    doc.setLineWidth(0.5);
                    doc.rect(courtX, fieldY, courtWidth, courtHeight);

                    // Linea dei 3 metri
                    const threeMetersLine = fieldY + (courtHeight / 3);
                    doc.setLineWidth(0.3);
                    doc.line(courtX, threeMetersLine, courtX + courtWidth, threeMetersLine);

                    // Rete (linea centrale pi√π spessa)
                    doc.setLineWidth(1);
                    doc.line(courtX - 3, fieldY, courtX + courtWidth + 3, fieldY);

                    // Lineette per indicare la zona di battuta
                    const serveLineLength = 2;
                    const serveLineOffset = 1;
                    const serveLineBelow = 2;

                    doc.setLineWidth(0.5);

                    // Lineetta sinistra
                    doc.line(
                        courtX + serveLineOffset,
                        fieldY + courtHeight + serveLineBelow,
                        courtX + serveLineOffset,
                        fieldY + courtHeight + serveLineBelow + serveLineLength
                    );

                    // Lineetta destra
                    doc.line(
                        courtX + courtWidth - serveLineOffset,
                        fieldY + courtHeight + serveLineBelow,
                        courtX + courtWidth - serveLineOffset,
                        fieldY + courtHeight + serveLineBelow + serveLineLength
                    );

                    // Posizioni dei giocatori (cerchi)
                    doc.setLineWidth(0.3);
                    const positions = [
                        { x: courtWidth * 0.15, y: courtHeight * 0.15 },
                        { x: courtWidth * 0.50, y: courtHeight * 0.15 },
                        { x: courtWidth * 0.85, y: courtHeight * 0.15 },
                        { x: courtWidth * 0.15, y: courtHeight * 0.75 },
                        { x: courtWidth * 0.50, y: courtHeight * 0.75 },
                        { x: courtWidth * 0.85, y: courtHeight * 0.75 }
                    ];

                    doc.setFontSize(7);
                    doc.setFont(undefined, 'normal');
                    positions.forEach(pos => {
                        const cx = courtX + pos.x;
                        const cy = fieldY + pos.y;
                        doc.setDrawColor(200);
                        doc.circle(cx, cy, 5, 'S');
                    });

                    // ============ SOSTITUZIONI E NOTE SOTTO IL CAMPO ============
                    const notesY = fieldY + courtHeight + 10;

                    doc.setFontSize(8);
                    doc.setFont(undefined, 'bold');
                    doc.text('Sostituzioni:', courtX, notesY);

                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(7);
                    // 3 linee per sostituzioni
                    doc.line(courtX, notesY + 2, courtX + courtWidth, notesY + 2);
                    doc.line(courtX, notesY + 5, courtX + courtWidth, notesY + 5);
                    doc.line(courtX, notesY + 8, courtX + courtWidth, notesY + 8);

                    doc.setFontSize(8);
                    doc.setFont(undefined, 'bold');
                    doc.text('Note:', courtX, notesY + 12);

                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(7);
                    // 2 linee per note
                    doc.line(courtX, notesY + 14, courtX + courtWidth, notesY + 14);
                    doc.line(courtX, notesY + 17, courtX + courtWidth, notesY + 17);

                    // Firma allenatore (solo per i primi 3 set, allineati in basso)
                    if (set <= 3) {
                        doc.setFontSize(7);
                        doc.text('Firma All.: ______________', courtX, notesY + 22);
                    }
                }

                // Footer
                doc.setFontSize(8);
                doc.setTextColor(150, 150, 150);
                doc.text('Generato da VolleyProW4 - spikecode', pageWidth / 2, pageHeight - 10, { align: 'center' });

                // Salva il PDF
                const now = new Date();
                const timestamp = now.getFullYear() +
                    String(now.getMonth() + 1).padStart(2, '0') +
                    String(now.getDate()).padStart(2, '0') + '_' +
                    String(now.getHours()).padStart(2, '0') +
                    String(now.getMinutes()).padStart(2, '0');

                doc.save(`Formazioni_${timestamp}.pdf`);

                console.log('‚úÖ Foglio formazioni generato con successo');
            }




        }
        const editor = new SchemaEditor();
        // document.addEventListener('DOMContentLoaded', () => {
        //     window.editor = new SchemaEditor();
        // });
        // Ottieni la data e ora correnti
        const now = new Date();

        // Formatta la data e ora come vuoi, ad esempio: "2025-09-24 15:30"
        const formattedDate = now.getFullYear() +
            String(now.getMonth() + 1).padStart(2, '0') +
            String(now.getDate()).padStart(2, '0') + "_ " +
            String(now.getHours()).padStart(2, '0') +
            String(now.getMinutes()).padStart(2, '0');




        // Imposta il value dinamicamente
        document.getElementById("schemaTitle").value = "Nuovo Allenamento " + formattedDate;
    </script>
    <div id="libraryDialog" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeLibraryDialog">&times;</span>
            <h2>Carica Allenamento da Libreria</h2>

            <div class="filters">
                <label for="filterPeriodo">Periodo:</label>
                <select id="filterPeriodo"></select>

                <label for="filterTipologia">Tipologia:</label>
                <select id="filterTipologia"></select>

                <label for="filterRuolo">Ruolo:</label>
                <select id="filterRuolo"></select>
            </div>

            <div class="workout-list-container">
                <ul id="workoutList">
                </ul>
            </div>
            <button id="loadSelectedWorkout" disabled>Carica Allenamento</button>
        </div>
    </div>


    <!-- Popup per nome allenamento -->
    <div id="saveWorkoutModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="close-button" id="closeSaveWorkout">&times;</span>
            <h2>Salva Allenamento Completo</h2>

            <div id="workOutListName"></div>

            <div style="padding: 20px 0;">
                <label for="workoutFileName" style="display: block; margin-bottom: 10px; font-weight: bold;">
                    Nome del file:
                </label>
                <input type="text" id="workoutFileName"
                    style="width: 100%; padding: 8px; border: 1px solid #bdc3c7; border-radius: 4px; margin-bottom: 15px;"
                    placeholder="es: Allenamento_Settimana1">

                <label for="workoutGlobalObjective" style="display: block; margin-bottom: 10px; font-weight: bold;">
                    Obiettivo dell'allenamento:
                </label>
                <textarea id="workoutGlobalObjective"
                    style="width: 100%; padding: 8px; border: 1px solid #bdc3c7; border-radius: 4px; margin-bottom: 15px; resize: vertical; min-height: 80px; font-family: inherit;"
                    placeholder="Descrivi l'obiettivo generale di questo allenamento..."></textarea>

                <label for="workoutGlobalObservations" style="display: block; margin-bottom: 10px; font-weight: bold;">
                    Osservazioni:
                </label>
                <textarea id="workoutGlobalObservations"
                    style="width: 100%; padding: 8px; border: 1px solid #bdc3c7; border-radius: 4px; resize: vertical; min-height: 100px; font-family: inherit;"
                    placeholder="Aggiungi eventuali osservazioni o note post-allenamento..."></textarea>
            </div>

            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="cancelSaveWorkout"
                    style="padding: 8px 16px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Annulla
                </button>
                <button id="confirmSaveWorkout"
                    style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Salva
                </button>
            </div>
        </div>
    </div>


    <!-- Login Modal - VolleyProW4 Edition -->
    <div id="loginModal" class="login-modal">
        <div class="volley-bg"></div>
        <div class="volley-ball"></div>

        <div class="login-content">
            <h2 class="login-title">Benvenuto in <span class="highlight">VolleyPro<span class="w4">W4</span></span>
            </h2>
            <h3 class="login-subtitle">Editor Professionale per Allenatori di Pallavolo</h3>

            <form id="loginForm">
                <div class="login-field">
                    <label for="username">Username</label>
                    <input type="text" id="username" name="username" required placeholder="Inserisci username"
                        value="admin">
                </div>
                <div class="login-field">
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password" required placeholder="Inserisci password"
                        value="1234">
                </div>
                <div class="login-error" id="loginError">Username o password errati</div>
                <button type="submit" class="login-button">Accedi</button>
            </form>
        </div>
    </div>




    <!-- Aggiungi questa dialog FUORI da object-controls, prima della chiusura di </body> -->
    <div id="animationDialog">
        <div class="animation-dialog-header" id="animationDialogHeader">
            <h3>üé¨ Controlli Animazione</h3>
            <button class="animation-dialog-close" id="closeAnimationDialog">&times;</button>
        </div>
        <div class="animation-dialog-body">
            <!-- Controlli Riproduzione -->
            <div class="animation-control-section">
                <h4>‚ñ∂Ô∏è Riproduzione</h4>
                <div class="animation-controls-row">
                    <button id="animationPlay" title="Play">‚ñ∂Ô∏è</button>
                    <button id="animationPause" title="Pause" style="display: none;">‚è∏Ô∏è</button>
                    <button id="animationStop" title="Stop">‚èπÔ∏è</button>
                    <button id="animationPrevFrame" title="Frame Precedente">‚èÆÔ∏è</button>
                    <button id="animationNextFrame" title="Frame Successivo">‚è≠Ô∏è</button>
                    <span class="frame-display" id="currentFrameDisplay">Frame: 0</span>
                </div>
            </div>

            <!-- Velocit√† -->
            <div class="animation-control-section">
                <h4>‚ö° Velocit√†</h4>
                <div class="animation-controls-row">
                    <label>ms/frame:</label>
                    <input type="number" id="animationSpeed" min="100" max="5000" value="1000" step="100">
                </div>
            </div>

            <!-- Gestione Frame -->
            <div class="animation-control-section">
                <h4>üìã Frame Timeline</h4>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <button id="addFrameBtn" style="background: #27ae60; color: white; border: none;">‚ûï Nuovo
                        Frame</button>
                </div>
                <div id="framesList">
                    <!-- Popolato dinamicamente -->
                </div>
            </div>

            <!-- Propriet√† Frame Selezionato -->
            <div id="frameProperties" style="display: none;">
                <h5>üé® Propriet√† Frame <span id="frameNumber"></span></h5>
                <div style="margin-bottom: 10px;">
                    <label style="font-weight: bold;">‚è±Ô∏è Timestamp (ms): <input type="number" id="frameTimestamp"
                            min="0" step="100" style="width: 100px;"></label>
                    <span style="font-size: 10px; color: #7f8c8d; margin-left: 10px;">(tempo in millisecondi nella
                        timeline)</span>
                </div>
                <div class="frame-properties-grid">
                    <label>X: <input type="number" id="frameX" step="1"></label>
                    <label>Y: <input type="number" id="frameY" step="1"></label>
                    <label>Larghezza: <input type="number" id="frameWidth" step="1"></label>
                    <label>Altezza: <input type="number" id="frameHeight" step="1"></label>
                    <label>Rotazione: <input type="number" id="frameRotation" step="15"></label>
                    <label>Opacit√†: <input type="number" id="frameOpacity" min="0" max="1" step="0.1"></label>
                    <label>Colore: <input type="color" id="frameColor"></label>
                    <label style="flex-direction: row; align-items: center;">
                        <input type="checkbox" id="frameDashed"> Tratteggiato
                    </label>
                </div>
                <div class="frame-actions">
                    <button id="updateFrameBtn">üíæ Aggiorna</button>
                    <button id="deleteFrameBtn">üóëÔ∏è Elimina</button>
                </div>
            </div>
        </div>
    </div>


    <div id="historyDialog" class="windows-dialog">
        <div class="windows-dialog-header" id="historyDialogHeader">
            <h3>üìú Storico Modifiche</h3>
            <button class="windows-dialog-close" id="closeHistoryDialog">&times;</button>
        </div>
        <div class="windows-dialog-body">
            <div class="history-list-panel">
                <div id="historyList">
                    <!-- Popolato dinamicamente -->
                </div>
            </div>
            <div class="history-preview-panel">
                <div class="history-preview-header">
                    <strong id="historyPreviewTitle">Seleziona una modifica per visualizzare l'anteprima</strong>
                </div>
                <div class="history-preview-content">
                    <div class="history-preview-canvas" id="historyPreviewCanvas">
                        <!-- Canvas di preview -->
                    </div>
                    <div class="history-preview-stats" id="historyPreviewStats">
                        <!-- Statistiche della modifica -->
                    </div>
                </div>
                <div class="history-actions">
                    <button class="btn-delete-history" id="deleteHistoryBtn" disabled>üóëÔ∏è Elimina</button>
                    <button class="btn-compare" id="compareHistoryBtn" disabled>üîÑ Confronta</button>
                    <button class="btn-restore" id="restoreHistoryBtn" disabled>‚úÖ Ripristina</button>
                </div>
            </div>
        </div>
    </div>



    <div id="watermark">
        VBProW4 by <a href="https://www.filippomorano.com" target="_blank" rel="noopener noreferrer">spikecode</a>
    </div>
    <team-management-dialog></team-management-dialog>

    <script>
        let zCounter = 200; // baseline z-index for windows
        const minWidth = 200;
        const minHeight = 80;
        // createWindow factory
        function createWindow({ title = "Finestra", contentHTML = "", buttons = [], modal = false, icon = "üìù" } = {}) {
            let overlay;
            if (modal) {
                overlay = document.createElement('div');
                overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center';
                overlay.style.zIndex = zCounter + 1000; // ensure above other windows
                document.body.appendChild(overlay);

                // click on overlay closes modal (only if clicked outside the modal)
                overlay.addEventListener('click', () => {
                    // remove the win + overlay
                    if (win) win.remove();
                    overlay.remove();
                });
            }

            const win = document.createElement('div');
            win.className = 'win absolute bg-white shadow-lg';
            win.style.width = '540px';
            win.style.height = '360px';
            win.style.left = `${120 + Math.random() * 60}px`;
            win.style.top = `${120 + Math.random() * 60}px`;
            win.style.zIndex = modal ? (zCounter + 1001) : zCounter + 1;
            if (modal) {
                // append inside overlay so it's above the overlay background but clicks inside must not propagate
                overlay.appendChild(win);
                win.addEventListener('click', e => e.stopPropagation());
            } else {
                document.body.appendChild(win);
            }

            // titlebar
            const titlebar = document.createElement('div');
            titlebar.className = 'win-titlebar flex items-center justify-between px-3 py-2 win-titlebar';
            titlebar.innerHTML = `
    <div class="flex items-center gap-2">
      <div style="width:10px;height:10px;background:#34d399;border-radius:4px"></div>
      <div style="font-weight:600">${title}</div>
    </div>
    <div class="flex items-center gap-2">
      <button class="btn-min w-6 h-6 rounded-full" title="Minimize" style="background:#fbbf24"></button>
      <button class="btn-max w-6 h-6 rounded-full" title="Maximize" style="background:#60a5fa"></button>
      <button class="btn-close w-6 h-6 rounded-full" title="Close" style="background:#f87171"></button>
    </div>
  `;
            titlebar.style.background = 'linear-gradient(90deg,#0ea5e9,#0369a1)';
            titlebar.style.color = '#fff';
            win.appendChild(titlebar);

            // content
            const content = document.createElement('div');
            content.className = 'p-4';
            content.style.height = 'calc(100% - 48px)';
            content.innerHTML = contentHTML;
            win.appendChild(content);

            // bottom buttons area (optional)
            if (buttons && buttons.length) {
                const btnArea = document.createElement('div');
                btnArea.className = 'absolute left-0 right-0 bottom-0 p-2 flex justify-end bg-gray-100 border-t';
                buttons.forEach(b => {
                    const btn = document.createElement('button');
                    btn.textContent = b.label;
                    btn.className = 'ml-2 px-3 py-1 rounded bg-sky-600 text-white';
                    btn.addEventListener('click', b.onClick);
                    btnArea.appendChild(btn);
                });
                win.appendChild(btnArea);
                // shrink content area
                content.style.height = 'calc(100% - 48px - 44px)';
            }

            // resize handles
            const handles = ["t", "b", "l", "r", "tl", "tr", "bl", "br"];
            handles.forEach(hc => {
                const h = document.createElement('div');
                h.className = `resize-handle ${hc}`;
                win.appendChild(h);
            });

            // --- interactions: bring to front on mousedown anywhere in window ---
            win.addEventListener('mousedown', () => bringToFront(win));

            // drag from titlebar
            let dragging = false, dx = 0, dy = 0;
            titlebar.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON') return;
                dragging = true;
                dx = e.clientX - win.offsetLeft;
                dy = e.clientY - win.offsetTop;
                bringToFront(win);
                // prevent selection
                document.body.style.userSelect = 'none';
            });
            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                win.style.left = `${e.clientX - dx}px`;
                win.style.top = `${e.clientY - dy}px`;
            });
            window.addEventListener('mouseup', () => {
                dragging = false;
                document.body.style.userSelect = '';
            });

            // resize logic (shared)
            let resizing = false, handleType = null, startX = 0, startY = 0, startW = 0, startH = 0, startL = 0, startT = 0;
            win.querySelectorAll('.resize-handle').forEach(hEl => {
                hEl.addEventListener('mousedown', e => {
                    e.stopPropagation();
                    resizing = true;
                    handleType = hEl.classList[1];
                    startX = e.clientX; startY = e.clientY;
                    startW = win.offsetWidth; startH = win.offsetHeight;
                    startL = win.offsetLeft; startT = win.offsetTop;
                    bringToFront(win);
                    document.body.style.userSelect = 'none';
                });
            });

            window.addEventListener('mousemove', (e) => {
                if (!resizing) return;
                const mx = e.clientX - startX;
                const my = e.clientY - startY;
                let newW = startW, newH = startH, newL = startL, newT = startT;
                switch (handleType) {
                    case 'r': newW = Math.max(minWidth, startW + mx); break;
                    case 'l': newW = Math.max(minWidth, startW - mx); newL = startL + mx; break;
                    case 'b': newH = Math.max(minHeight, startH + my); break;
                    case 't': newH = Math.max(minHeight, startH - my); newT = startT + my; break;
                    case 'br': newW = Math.max(minWidth, startW + mx); newH = Math.max(minHeight, startH + my); break;
                    case 'bl': newW = Math.max(minWidth, startW - mx); newL = startL + mx; newH = Math.max(minHeight, startH + my); break;
                    case 'tr': newW = Math.max(minWidth, startW + mx); newH = Math.max(minHeight, startH - my); newT = startT + my; break;
                    case 'tl': newW = Math.max(minWidth, startW - mx); newL = startL + mx; newH = Math.max(minHeight, startH - my); newT = startT + my; break;
                }
                win.style.width = newW + 'px';
                win.style.height = newH + 'px';
                win.style.left = newL + 'px';
                win.style.top = newT + 'px';
            });

            window.addEventListener('mouseup', () => {
                if (resizing) {
                    resizing = false;
                    document.body.style.userSelect = '';
                }
            });

            // window control buttons
            const btnClose = titlebar.querySelector('.btn-close');
            const btnMin = titlebar.querySelector('.btn-min');
            const btnMax = titlebar.querySelector('.btn-max');

            btnClose.addEventListener('click', () => {
                win.remove();
                if (overlay) overlay.remove();
            });

            btnMin.addEventListener('click', () => {
                win.classList.add('hidden');
                if (overlay) overlay.classList.add('hidden'); // nasconde l‚Äôoverlay con la finestra modale

                const icon = document.createElement('div');
                icon.className = 'w-8 h-8 rounded flex items-center justify-center bg-yellow-400 text-sm cursor-pointer';
                icon.textContent = "ü™ü"; // icona generica
                icon.title = title;
                icon.addEventListener('click', () => {
                    win.classList.remove('hidden');
                    if (overlay) overlay.classList.remove('hidden'); // riporta anche l‚Äôoverlay visibile
                    icon.remove();
                });
                taskbarIcons.appendChild(icon);
            });

            let maximized = false;
            let prev = {};
            btnMax.addEventListener('click', () => {
                if (!maximized) {
                    prev = { left: win.offsetLeft, top: win.offsetTop, width: win.offsetWidth, height: win.offsetHeight };
                    win.style.left = `${sidebarLeft.offsetWidth + 12}px`;
                    win.style.top = `${topbar.offsetHeight + 8}px`;
                    win.style.width = `${window.innerWidth - sidebarLeft.offsetWidth - sidebarRight.offsetWidth - 24}px`;
                    win.style.height = `${window.innerHeight - topbar.offsetHeight - taskbar.offsetHeight - 24}px`;
                    maximized = true;
                } else {
                    win.style.left = prev.left + 'px';
                    win.style.top = prev.top + 'px';
                    win.style.width = prev.width + 'px';
                    win.style.height = prev.height + 'px';
                    maximized = false;
                }
            });

            return win;
        }

        /* =========================
           Menu buttons - example windows
           ========================= */
        document.getElementById('menu-notepad').addEventListener('click', () => {
            createWindow({
                title: 'Blocco Note',
                contentHTML: `<textarea style="width:100%;height:100%;box-sizing:border-box">Qui puoi scrivere...</textarea>`,
                buttons: [
                    { label: 'Conferma', onClick: () => alert('Confermato') },
                    { label: 'Annulla', onClick: () => alert('Annullato') }
                ]
            });
        });

        document.addEventListener("DOMContentLoaded", () => {
            setDefaultDate('workoutDate');
            window.editor = new SchemaEditor();
            // Associa la funzione al pulsante 'Esporta PDF'
            const exportBtn = document.getElementById('exportPdfBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    if (window.editor && window.editor.exportWorkoutToPDF) {
                        window.editor.exportWorkoutToPDF();
                    } else {
                        alert('Errore: La funzione di esportazione non √® stata caricata correttamente.');
                    }
                });
            }
        });
    </script>
    <script defer src="components/components.js"></script>

</body>

</html>